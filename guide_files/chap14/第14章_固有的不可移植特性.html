<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul:nth-of-type(1) > li > ul > li > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li:not(:nth-child(1)) > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li > ul > li > a { background-image: none; } .site-nav > ul:not(:nth-of-type(1)) a, .site-nav li.external a { background-image: none; } .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(14) > ul > li:nth-child(1) > a { font-weight: 600; text-decoration: none; } .site-nav > ul.nav-category-list > li > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(14) > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(14) > ul > li:nth-child(1) > button svg { transform: rotate(-90deg); } .site-nav > ul.nav-category-list > li.nav-list-item > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(14) > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(14) > ul.nav-list > li.nav-list-item:nth-child(1) > ul.nav-list { display: block; } </style> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.stemmer.support.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.zh.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.multi.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>固有的不可移植特性概念详解 | C++语法教程</title> <meta name="generator" content="Jekyll v3.9.3" /> <meta property="og:title" content="固有的不可移植特性概念详解" /> <meta name="author" content="BBK" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="14.1 不可移植特性的概念" /> <meta property="og:description" content="14.1 不可移植特性的概念" /> <link rel="canonical" href="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html" /> <meta property="og:url" content="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html" /> <meta property="og:site_name" content="C++语法教程" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2025-02-11T03:16:47+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="固有的不可移植特性概念详解" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BBK"},"dateModified":"2025-02-11T03:16:47+00:00","datePublished":"2025-02-11T03:16:47+00:00","description":"14.1 不可移植特性的概念","headline":"固有的不可移植特性概念详解","mainEntityOfPage":{"@type":"WebPage","@id":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html"},"url":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/Cpp_Guide_detailed/" class="site-title lh-tight"> C++语法教程 </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第一章 c++入门介绍 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap1/index.html" class="nav-list-link">第一章 c++入门介绍</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html" class="nav-list-link">预处理指令概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第二章 基本类型与变量 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap2/index.html" class="nav-list-link">第二章 基本类型与变量</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html" class="nav-list-link">类型与变量</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html" class="nav-list-link">复合类型</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html" class="nav-list-link">限定符与说明符</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第三章 表达式 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap3/index.html" class="nav-list-link">第三章 表达式</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" class="nav-list-link">表达式概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第四章 语句 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap4/index.html" class="nav-list-link">第四章 语句</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html" class="nav-list-link">语句概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第五章 函数 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap5/index.html" class="nav-list-link">第五章 函数</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html" class="nav-list-link">函数概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第六章 动态内存管理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap6/index.html" class="nav-list-link">第六章 动态内存管理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" class="nav-list-link">动态内存管理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第七章 类 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap7/index.html" class="nav-list-link">第七章 类</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">类概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第八章 重载运算符 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap8/index.html" class="nav-list-link">第八章 重载运算符</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html" class="nav-list-link">重载运算符概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第九章 异常处理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap9/index.html" class="nav-list-link">第九章 异常处理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html" class="nav-list-link">异常处理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十章 模板 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap10/index.html" class="nav-list-link">第十章 模板</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html" class="nav-list-link">模板概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十一章 派生类类型 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap11/index.html" class="nav-list-link">第十一章 派生类类型</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">派生类类型概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十二章 命名空间 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap12/index.html" class="nav-list-link">第十二章 命名空间</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html" class="nav-list-link">命名空间概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十三章 分离式编译 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap13/index.html" class="nav-list-link">第十三章 分离式编译</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html" class="nav-list-link">分离式编译概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十四章 固有的不可移植特性 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap14/index.html" class="nav-list-link">第十四章 固有的不可移植特性</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html" class="nav-list-link">固有的不可移植特性概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十五章 标准库 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap15/index.html" class="nav-list-link">第十五章 标准库</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html" class="nav-list-link">标准库详解</a></li></ul></li></ul> </nav> <footer class="site-footer"> <button type="button" id="theme_switch_button" class="site-button btn-reset" theme_id="dark" onclick="switch_theme()">切换到<b id="current_theme_name">明亮</b>主题 </button> <script src=/Cpp_Guide_detailed/assets/js/cookie_manager.js></script> <script src=/Cpp_Guide_detailed/assets/js/theme_switch.js></script> </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search C++语法教程" aria-label="Search C++语法教程" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://github.com/bobokick/Cpp_Guide_detailed" class="site-button" > Cpp_Guide_detailed on GitHub </a> </li> </ul> </nav> </div> <div class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap14/index.html">第十四章 固有的不可移植特性</a></li> <li class="breadcrumb-nav-list-item"><span>固有的不可移植特性概念详解</span></li> </ol> </nav> <div id="main-content" class="main-content"> <main> <div> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h1"><a href="#141-不可移植特性的概念">14.1 不可移植特性的概念</a></li> <li class="toc-entry toc-h1"><a href="#142-位域">14.2 位域</a></li> <li class="toc-entry toc-h1"><a href="#143-volatile限定符">14.3 volatile限定符</a></li> <li class="toc-entry toc-h1"><a href="#144-链接指示">14.4 链接指示</a> <ul> <li class="toc-entry toc-h2"><a href="#1441-c调用其他语言的函数">14.41 C++调用其他语言的函数</a> <ul> <li class="toc-entry toc-h3"><a href="#14411-链接指示指针">14.411 链接指示指针</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#1442-其他语言调用c的函数">14.42 其他语言调用C++的函数</a></li> </ul> </li> </ul> </div> <div id="markdown-content"> <h1 id="141-不可移植特性的概念"> <a href="#141-不可移植特性的概念" class="anchor-heading" aria-labelledby="141-不可移植特性的概念"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 14.1 不可移植特性的概念 </h1> <p>为了支持低层编程，C++定义了一些固有的不可移植(nonportable)的特性。所谓不可移植的特性是指因机器或者操作系统而异的特性，当我们将含有不可移植特性的程序从一台机器或者操作系统转移到另一台机器或者操作系统上时，通常需要重新编写该程序。</p> <p>对于C++的不可移植特性，一般有以下几种：</p> <ul> <li>算术类型的所占字节的大小</li> <li>位域</li> <li><code class="language-plaintext highlighter-rouge">volatile</code>限定符</li> <li>链接指示</li> </ul> <p>算术类型的所占字节的大小我们在将数据类型时介绍过，接下来我们主要介绍后三种不可移植特性。</p> <h1 id="142-位域"> <a href="#142-位域" class="anchor-heading" aria-labelledby="142-位域"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 14.2 位域 </h1> <p>类可以将其非静态数据成员定义成位域(bit-field),在一个位域中含有一定数量的二进制位。 当一个程序需要向其他程序或硬件设备传递二进制数据吋，通常会用到位域。</p> <p>位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式。</p> <p>位域的声明形式为：</p> <blockquote> <p>类型说明符(可含类型修饰符) 位域名: 常量表达式;</p> </blockquote> <p>位域的类型必须是整型或枚举类型。</p> <blockquote> <p>因为带符号位域的行为是由具体实现确定的，所以在通常情况下我们使用无符号类型保存一个位域。</p> </blockquote> <p>声明中的常量表达式用于说明该位域所占的二进制位数的数量。</p> <blockquote> <p>位域不能有类内初始值。</p> </blockquote> <blockquote> <p>一般来说, 在类的内部连续定义的位域内存空间会被压缩在同一整数的相邻位，从而提供存储压缩。</p> </blockquote> <p>取地址运算符<code class="language-plaintext highlighter-rouge">&amp;</code>不能作用于位域，因此任何指针都无法指向类的位域。</p> <p>位域和其他的整型变量一样，可以被初始化或赋值，也可以初始化或赋值其他对象，只要所给的值的类型是该位域的类型或者能隐式转换成该类型就行。 因为位域所占的空间只有给定位数的大小，所以当位域被初始化或赋值时，从低位向高位储存每位的值，直至达到规定位数；如果用于初始化或赋值的值的位数小于位域时，则位域也是从低位向高位储存每位的值，高位如有空，则其位值为0。用位域来初始化或赋值与其类似。</p> <blockquote> <p>位域在内存中的布局是与机器相关的。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="c1">// 位域bits的声明</span>
    <span class="kt">unsigned</span> <span class="n">bits</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span> 
    <span class="n">Cls</span><span class="p">()</span><span class="o">:</span> <span class="n">bits</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="c1">// 位域bits被int型字面值初始化</span>
<span class="c1">// 字面值9的最低的4位二进制为</span>
<span class="c1">// 1001</span>
<span class="c1">// 位域bits的位数为3位，按照赋值规则，bits初始化后的位数为</span>
<span class="c1">// 001</span>
<span class="c1">// 按无符号int型就表示数字1</span>
<span class="n">Cls</span> <span class="n">obj</span><span class="p">;</span>
<span class="c1">// 输出1</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
</code></pre></div></div> <h1 id="143-volatile限定符"> <a href="#143-volatile限定符" class="anchor-heading" aria-labelledby="143-volatile限定符"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 14.3 volatile限定符 </h1> <p>直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制。例如，程序可能包含一个由系统时钟定时更新的变量。 当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为<code class="language-plaintext highlighter-rouge">volatile</code>，关键字<code class="language-plaintext highlighter-rouge">volatile</code>告诉编译器不应对这样的对象进行优化。</p> <p><code class="language-plaintext highlighter-rouge">volatile</code>限定符的用法和<code class="language-plaintext highlighter-rouge">const</code>几乎一样，遵循各种<code class="language-plaintext highlighter-rouge">const</code>的规则，且<code class="language-plaintext highlighter-rouge">const</code>能和<code class="language-plaintext highlighter-rouge">volatile</code>同时作用与一个对象中。</p> <p>一般定义<code class="language-plaintext highlighter-rouge">volatile</code>对象的语句形式为</p> <ol> <li> <blockquote> <p>volatile 类型说明符 变量名 (初始化);</p> </blockquote> </li> <li> <blockquote> <p>类型说明符 volatile 变量名 (初始化);</p> </blockquote> </li> </ol> <p>类的非静态函数成员能定义成<code class="language-plaintext highlighter-rouge">const</code>成员函数，所以非静态函数成员也能定义成<code class="language-plaintext highlighter-rouge">volatile</code>的。 <code class="language-plaintext highlighter-rouge">volatile</code>对象为类类型时，其不能使用该类型的非<code class="language-plaintext highlighter-rouge">volatile</code>的非静态成员函数。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="c1">// volatile的成员函数prints</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">volatile</span>
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"vo"</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">nprints</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="k">volatile</span> <span class="n">Cls</span> <span class="n">obj</span><span class="p">;</span>
<span class="c1">// 正确：volatile对象可以调用其volatile成员函数prints</span>
<span class="n">obj</span><span class="p">.</span><span class="n">prints</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
<span class="c1">// 错误：volatile对象不能使用非volatile的非静态成员函数</span>
<span class="n">obj</span><span class="p">.</span><span class="n">nprints</span><span class="p">();</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">volatile</code>限定符的用法有一点与<code class="language-plaintext highlighter-rouge">const</code>不同，这也就是： 我们不能使用合成的拷贝/移动构造函数及赋值运算符来初始化或赋值类类型中的<code class="language-plaintext highlighter-rouge">volatile</code>数据成员。 所以我们必须自定义这些函数来初始化或赋值<code class="language-plaintext highlighter-rouge">volatile</code>数据成员。</p> <h1 id="144-链接指示"> <a href="#144-链接指示" class="anchor-heading" aria-labelledby="144-链接指示"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 14.4 链接指示 </h1> <p>C++程序有时需要调用其他语言编写的函数，或者其他语言有时也需要调用C++编写的函数，最常见的是C和C++。 C++使用链接指示（linkage directive）指出任意非C++函数所用的语言。</p> <blockquote> <p>链接指示语句只能用C++编译器编译，所以所有涉及到链接指示语句的文件要用C++编译器编译。</p> </blockquote> <blockquote> <p>要想把C++代码和其他语言（包括C语言）编写的代码放在一起使用(也就是相互都可以使用)，要求我们所使用的C++编译器必须能够有权访问该语言的编译器，并且也兼容这个语言的编译器。</p> </blockquote> <h2 id="1441-c调用其他语言的函数"> <a href="#1441-c调用其他语言的函数" class="anchor-heading" aria-labelledby="1441-c调用其他语言的函数"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 14.41 C++调用其他语言的函数 </h2> <p>像所有其他名字一样，其他语言中的函数名字也必须在C++中进行声明，并且该声明必须指定返回类型和形参列表。 对于其他语言编写的函数来说，编译器检查其调用的方式与处理普通C++函数的方式相同，但是生成的代码有所区别。</p> <p>链接指示可以有两种形式：单个的或复合的：</p> <ol> <li> <blockquote> <p>extern 字符串字面值 函数声明或定义语句</p> </blockquote> </li> <li> <blockquote> <p>extern 字符串字面值 { 多个函数的声明或定义语句 }</p> </blockquote> </li> </ol> <p>这两种形式都是首先包含一个关键字<code class="language-plaintext highlighter-rouge">extern</code>，后面跟是一个字符串字面值以及一个普通的函数声明或定义。</p> <p>字符串字面值指出了编写函数所用的语言。比如<code class="language-plaintext highlighter-rouge">"C"</code>、<code class="language-plaintext highlighter-rouge">"Ada"</code>、<code class="language-plaintext highlighter-rouge">"FORTRAN"</code>等。</p> <p>函数声明或定义语句也就是其他语言编写的函数，这些函数必须指定返回类型和形参列表。</p> <p>对于第二种花括号括起的形式，它可以支持多个其他语言函数的链接指示。 花括号的作用是将其中的多个声明或定义聚合在一起，一次性建立多个链接，花括号中声明或定义的函数名字就是可见的，就好像在花括号之外声明或定义的一样。 花括号中还可以包含<code class="language-plaintext highlighter-rouge">#include</code>指令，当一个<code class="language-plaintext highlighter-rouge">#include</code>指令被放置在的花括号中时，头文件中的所有普通函数声明或定义都会被认为是由链接指示的语言编写的。</p> <p>链接指示可以嵌套，如果花括号中包含带自带链接指示的函数，则该函数的还是按自己的链接来，不受外层链接指示的影响。</p> <blockquote> <p>对于某个函数来说，如果其函数声明已带有链接指示，则该函数的定义可以不用再显式写明其链接指示，编译器会自动匹配该函数的定义并将其视为对应语言的函数。 对于某个带有链接指示的函数声明或定义，其函数的其他声明最好也应带有链接指示，且链接指示必须一致。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 文件test.h</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span> <span class="nf">print</span><span class="p">();</span>
<span class="k">extern</span> <span class="s">"C"</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 文件test.cpp</span>
<span class="c1">// 会编译为test.o</span>
<span class="cp">#include "test.h"
</span><span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/*···*/</span> <span class="p">}</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">int</span> <span class="nf">ret</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/*···*/</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*···*/</span> <span class="p">}</span>

<span class="c1">// 文件test2.cpp</span>
<span class="c1">// 会链接test.o</span>
<span class="cp">#include "test.h"
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">print</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="n">ret</span><span class="p">();</span>
    <span class="n">get</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="14411-链接指示指针"> <a href="#14411-链接指示指针" class="anchor-heading" aria-labelledby="14411-链接指示指针"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 14.411 链接指示指针 </h3> <p>我们还可以声明或定义指向其他语言的函数的指针，该指针的声明或定义与普通的指针声明或定义类似，就在前面加上关键字<code class="language-plaintext highlighter-rouge">extern</code>和表示语言的字符串字面值</p> <p>链接指示指针的形式为：</p> <blockquote> <p>extern 字符串字面值 函数指针声明或定义语句</p> </blockquote> <p>该函数指针声明或定义语句也必须指定返回类型和形参列表。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pf指向一个C函数，该函数接受一个int返回void</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</code></pre></div></div> <p>链接指示指针可以初始化、赋值和使用，但是它只能对该语言对应声明的函数使用，C++的函数不能和它起作用，否则出错。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//指向一个C++函数 </span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pf1</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="c1">//指向一个C函数</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pf2</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="c1">//错误：pfl和pf2的类型不同</span>
<span class="n">pf1</span> <span class="o">=</span> <span class="n">pf</span><span class="p">;</span>
</code></pre></div></div> <p>如果链接指示指针的返回类型或者某形参是函数指针类型时，这些返回类型或者形参也是链接指示指针。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// f1是一个C函数，它的形参是一个指向C函数的指针</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</code></pre></div></div> <p>如果我们希望某个C++函数的返回类型或者某形参是链接指示指针类型时，则我们必须使用类型别名，来声明这些链接指示指针可以当做C++函数的返回类型或者某形参。</p> <p>形式为：</p> <blockquote> <p>extern 字符串字面值 typedef 函数指针声明语句</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// FC是一个指向C函数的指针</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="k">typedef</span> <span class="kt">void</span> <span class="nf">FC</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="c1">// f2是一个C++函數，该函数的形参是指向C函数的指针</span>
<span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="n">FC</span><span class="o">*</span><span class="p">);</span>
</code></pre></div></div> <h2 id="1442-其他语言调用c的函数"> <a href="#1442-其他语言调用c的函数" class="anchor-heading" aria-labelledby="1442-其他语言调用c的函数"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 14.42 其他语言调用C++的函数 </h2> <p>我们也可以令C++函数在其他语言编写的程序中可用，也可以在其他语言中声明或定义指向C++函数的指针(如果该语言有指针的话)。</p> <p>这些也是用链接指示来声明或定义的，形式一模一样，只要在表示语言的字符串字面值中写上所要用C++函数的语言就行。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// calc函数可以被C程序调用</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">double</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">double</span> <span class="n">dparm</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ...*/</span> <span class="p">}</span>
<span class="c1">// ptr函数指针可以在C程序中指向C++函数</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">double</span> <span class="p">(</span><span class="n">ptr</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</code></pre></div></div> <p>值得注意的是，可被其他语言使用的C++函数的返回类型或形参类型会受到很多限制。 例如，我们不太可能把一个C++类的对象传给C程序，因为C程序根本无法理解构造函数、析构函数以及其他类特有的操作。</p> <p>因为C语言也不支持函数重载，所以我们在定义能被C程序使用的C++函数时不能定义多个名字相同的函数。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//错误：两个extern "C"函数的名字相同</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</code></pre></div></div> </div> </div> </main> <hr> <footer> <!-- # Footer content # appears at the bottom of every page's main content --> <p class="text-small text-grey-dk-100 mb-0"> Copyright &copy; 2020-2024 bobokick. Distributed by an <a href="https://github.com/bobokick/Cpp_Guide_detailed/blob/master/LICENSE">Apache License 2.0.</a> </p> <div class="d-flex mt-2"> <p class="text-small text-grey-dk-000 mb-0"> <a href="https://github.com/bobokick/Cpp_Guide_detailed/tree/master/docs/my_collections/_guide_files/chap14/第14章_固有的不可移植特性.md" id="edit-this-page">Edit this page on GitHub.</a> </p> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js"></script> <script> var config = {} ; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid')); </script> </body> </html>
