<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul:nth-of-type(1) > li > ul > li > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li:not(:nth-child(1)) > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li > ul > li > a { background-image: none; } .site-nav > ul:not(:nth-of-type(1)) a, .site-nav li.external a { background-image: none; } .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(10) > ul > li:nth-child(1) > a { font-weight: 600; text-decoration: none; } .site-nav > ul.nav-category-list > li > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(10) > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(10) > ul > li:nth-child(1) > button svg { transform: rotate(-90deg); } .site-nav > ul.nav-category-list > li.nav-list-item > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(10) > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(10) > ul.nav-list > li.nav-list-item:nth-child(1) > ul.nav-list { display: block; } </style> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.stemmer.support.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.zh.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.multi.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>模板概念详解 | C++语法教程</title> <meta name="generator" content="Jekyll v3.9.3" /> <meta property="og:title" content="模板概念详解" /> <meta name="author" content="BBK" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="10.1 模板概念" /> <meta property="og:description" content="10.1 模板概念" /> <link rel="canonical" href="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html" /> <meta property="og:url" content="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html" /> <meta property="og:site_name" content="C++语法教程" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2025-02-11T03:16:47+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="模板概念详解" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BBK"},"dateModified":"2025-02-11T03:16:47+00:00","datePublished":"2025-02-11T03:16:47+00:00","description":"10.1 模板概念","headline":"模板概念详解","mainEntityOfPage":{"@type":"WebPage","@id":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html"},"url":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/Cpp_Guide_detailed/" class="site-title lh-tight"> C++语法教程 </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第一章 c++入门介绍 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap1/index.html" class="nav-list-link">第一章 c++入门介绍</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html" class="nav-list-link">预处理指令概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第二章 基本类型与变量 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap2/index.html" class="nav-list-link">第二章 基本类型与变量</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html" class="nav-list-link">类型与变量</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html" class="nav-list-link">复合类型</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html" class="nav-list-link">限定符与说明符</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第三章 表达式 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap3/index.html" class="nav-list-link">第三章 表达式</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" class="nav-list-link">表达式概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第四章 语句 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap4/index.html" class="nav-list-link">第四章 语句</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html" class="nav-list-link">语句概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第五章 函数 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap5/index.html" class="nav-list-link">第五章 函数</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html" class="nav-list-link">函数概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第六章 动态内存管理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap6/index.html" class="nav-list-link">第六章 动态内存管理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" class="nav-list-link">动态内存管理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第七章 类 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap7/index.html" class="nav-list-link">第七章 类</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">类概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第八章 重载运算符 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap8/index.html" class="nav-list-link">第八章 重载运算符</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html" class="nav-list-link">重载运算符概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第九章 异常处理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap9/index.html" class="nav-list-link">第九章 异常处理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html" class="nav-list-link">异常处理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十章 模板 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap10/index.html" class="nav-list-link">第十章 模板</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html" class="nav-list-link">模板概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十一章 派生类类型 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap11/index.html" class="nav-list-link">第十一章 派生类类型</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">派生类类型概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十二章 命名空间 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap12/index.html" class="nav-list-link">第十二章 命名空间</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html" class="nav-list-link">命名空间概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十三章 分离式编译 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap13/index.html" class="nav-list-link">第十三章 分离式编译</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html" class="nav-list-link">分离式编译概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十四章 固有的不可移植特性 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap14/index.html" class="nav-list-link">第十四章 固有的不可移植特性</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html" class="nav-list-link">固有的不可移植特性概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十五章 标准库 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap15/index.html" class="nav-list-link">第十五章 标准库</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html" class="nav-list-link">标准库详解</a></li></ul></li></ul> </nav> <footer class="site-footer"> <button type="button" id="theme_switch_button" class="site-button btn-reset" theme_id="dark" onclick="switch_theme()">切换到<b id="current_theme_name">明亮</b>主题 </button> <script src=/Cpp_Guide_detailed/assets/js/cookie_manager.js></script> <script src=/Cpp_Guide_detailed/assets/js/theme_switch.js></script> </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search C++语法教程" aria-label="Search C++语法教程" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://github.com/bobokick/Cpp_Guide_detailed" class="site-button" > Cpp_Guide_detailed on GitHub </a> </li> </ul> </nav> </div> <div class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap10/index.html">第十章 模板</a></li> <li class="breadcrumb-nav-list-item"><span>模板概念详解</span></li> </ol> </nav> <div id="main-content" class="main-content"> <main> <div> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"><a href="#101-模板概念">10.1 模板概念</a></li> <li class="toc-entry toc-h2"><a href="#102-模板分类">10.2 模板分类</a></li> <li class="toc-entry toc-h2"><a href="#103-模板的声明与定义">10.3 模板的声明与定义</a></li> <li class="toc-entry toc-h2"><a href="#104-模板参数">10.4 模板参数</a> <ul> <li class="toc-entry toc-h3"><a href="#1041-模板形参">10.41 模板形参</a> <ul> <li class="toc-entry toc-h4"><a href="#10411-类型形参">10.411 类型形参</a></li> <li class="toc-entry toc-h4"><a href="#10412-非类型形参">10.412 非类型形参</a></li> <li class="toc-entry toc-h4"><a href="#10413-模板类形参">10.413 模板类形参</a></li> <li class="toc-entry toc-h4"><a href="#10414-可变数目形参">10.414 可变数目形参</a> <ul> <li class="toc-entry toc-h5"><a href="#104141-模板参数包">10.4141 模板参数包</a></li> <li class="toc-entry toc-h5"><a href="#104142-函数参数包">10.4142 函数参数包</a></li> </ul> </li> <li class="toc-entry toc-h4"><a href="#10415-非参数包的模板形参使用">10.415 非参数包的模板形参使用</a></li> <li class="toc-entry toc-h4"><a href="#10416-参数包的使用">10.416 参数包的使用</a> <ul> <li class="toc-entry toc-h5"><a href="#104161-包扩展">10.4161 包扩展</a> <ul> <li class="toc-entry toc-h6"><a href="#1041611-包扩展的形式">10.41611 包扩展的形式</a></li> <li class="toc-entry toc-h6"><a href="#1041612-包扩展的作用">10.41612 包扩展的作用</a></li> <li class="toc-entry toc-h6"><a href="#1041613-包扩展适用范围">10.41613 包扩展适用范围</a></li> </ul> </li> <li class="toc-entry toc-h5"><a href="#104162-获取参数包的大小">10.4162 获取参数包的大小</a></li> </ul> </li> </ul> </li> <li class="toc-entry toc-h3"><a href="#1042-模板默认实参">10.42 模板默认实参</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#105-模板实例化">10.5 模板实例化</a> <ul> <li class="toc-entry toc-h3"><a href="#1051-模板编译流程">10.51 模板编译流程</a></li> <li class="toc-entry toc-h3"><a href="#1052-实例化分类">10.52 实例化分类</a></li> <li class="toc-entry toc-h3"><a href="#1053-隐式实例化">10.53 隐式实例化</a> <ul> <li class="toc-entry toc-h4"><a href="#10531-显式模板实参列表">10.531 显式模板实参列表</a></li> <li class="toc-entry toc-h4"><a href="#10532-模板实参推断">10.532 模板实参推断</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#1054-显式实例化">10.54 显式实例化</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#106-模板特例化">10.6 模板特例化</a> <ul> <li class="toc-entry toc-h3"><a href="#1061-全部特例化">10.61 全部特例化</a></li> <li class="toc-entry toc-h3"><a href="#1062-部分特例化">10.62 部分特例化</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#107-类模板再探">10.7 类模板再探</a> <ul> <li class="toc-entry toc-h3"><a href="#1071-类模板别名">10.71 类模板别名</a></li> <li class="toc-entry toc-h3"><a href="#1072-类模板的特性">10.72 类模板的特性</a></li> <li class="toc-entry toc-h3"><a href="#1073-类模板成员的类外定义">10.73 类模板成员的类外定义</a></li> <li class="toc-entry toc-h3"><a href="#1074-成员模板">10.74 成员模板</a> <ul> <li class="toc-entry toc-h4"><a href="#10741-成员模板的定义">10.741 成员模板的定义</a> <ul> <li class="toc-entry toc-h5"><a href="#107411-类类型的成员模板定义">10.7411 类类型的成员模板定义</a></li> <li class="toc-entry toc-h5"><a href="#107412-类模板的成员模板定义">10.7412 类模板的成员模板定义</a></li> </ul> </li> <li class="toc-entry toc-h4"><a href="#10742-成员模板的实例化">10.742 成员模板的实例化</a></li> <li class="toc-entry toc-h4"><a href="#10743-成员模板的特例化">10.743 成员模板的特例化</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#1075-类模板与友元">10.75 类模板与友元</a> <ul> <li class="toc-entry toc-h4"><a href="#10751-模板实例友元">10.751 模板实例友元</a></li> <li class="toc-entry toc-h4"><a href="#10752-模板友元">10.752 模板友元</a></li> </ul> </li> </ul> </li> <li class="toc-entry toc-h2"><a href="#108-模板重载">10.8 模板重载</a></li> </ul> </div> <div id="markdown-content"> <h2 id="101-模板概念"> <a href="#101-模板概念" class="anchor-heading" aria-labelledby="101-模板概念"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.1 模板概念 </h2> <p>模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。 模板本身不是类或函数，相反，可以将模板看作为编译器生成类或函数编写的一份说明。</p> <p>编译器根据模板创建类或函数的过程称为实例化(instantiation),当使用模板时，需要指出编译器应把类或函数实例化成何种类型。</p> <h2 id="102-模板分类"> <a href="#102-模板分类" class="anchor-heading" aria-labelledby="102-模板分类"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.2 模板分类 </h2> <p>根据模板类型，C++的模板可以分为两种：</p> <ul> <li>函数模板</li> <li>类模板</li> </ul> <p>模板的声明和定义和普通的函数和类的声明和定义类似，要在其声明或定义之前加上关键字<code class="language-plaintext highlighter-rouge">template</code>和模板参数列表。</p> <p>模板的声明和定义都不能在函数或函数模板内，但可以在类或类模板内。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 函数模板prints的声明</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">ty</span> <span class="nf">prints</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">);</span>
<span class="c1">// 函数模板prints的定义</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">ty</span> <span class="nf">prints</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="k">return</span> <span class="n">ty</span><span class="p">();</span> <span class="p">}</span>
<span class="c1">// 类模板Cls的声明</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">int_par</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="p">;</span>
<span class="c1">// 类模板Cls的定义</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">int_par</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{</span> <span class="n">ty</span> <span class="n">data_mem</span><span class="p">;</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data_mem</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">int_par</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <h2 id="103-模板的声明与定义"> <a href="#103-模板的声明与定义" class="anchor-heading" aria-labelledby="103-模板的声明与定义"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.3 模板的声明与定义 </h2> <p>模板也有声明和定义两种形式，形式为：</p> <p>模板的声明:</p> <blockquote> <p>template 模板参数列表 函数或类的声明语句</p> </blockquote> <p>模板的定义:</p> <blockquote> <p>template 模板参数列表 函数或类的定义语句</p> </blockquote> <p>模板参数列表(template parameter list)类似于函数形参表，是一个由逗号<code class="language-plaintext highlighter-rouge">,</code>分隔的一个或多个模板形参(template parameter)的列表，该列表用<code class="language-plaintext highlighter-rouge">&lt;&gt;</code>包围起来，且该形参表不能为空，必须至少有一个形参。</p> <blockquote> <p>对于函数模板来说函数模板的类型限定符和存储说明符(如constexpr、inline和static等)是放在模板参数列表后，函数声明或定义语句前的。</p> </blockquote> <p>和函数一样，模板的声明要与其定义严格一致，具体来说:</p> <ul> <li>对于函数模板来说： 模板形参表要一致(也就是形参表中的形参数量，顺序和类型(可以忽略顶层const)都要相同)，函数首部也要一致(包括函数声明或定义前的类型限定符也要一致)。</li> <li>对于类模板来说： 模板形参表要一致，类名也要相同。</li> </ul> <p>否则就变成了其他的模板声明，无意义了。</p> <blockquote> <p>函数模板支持重载，只要该模板的模板形参表或者函数形参表不一致就行。 类模板不支持重载，所以类名相同但模板形参表不同的模板会导致重复定义；而且同作用域下的类模板名也不能与其他的类类型同名。</p> </blockquote> <h2 id="104-模板参数"> <a href="#104-模板参数" class="anchor-heading" aria-labelledby="104-模板参数"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.4 模板参数 </h2> <h3 id="1041-模板形参"> <a href="#1041-模板形参" class="anchor-heading" aria-labelledby="1041-模板形参"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.41 模板形参 </h3> <p>模板参数遵循普通的作用域规则，一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。 与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。</p> <blockquote> <p>同一个模板形参表中，各个模板形参的名字不能相同。 函数模板中的函数形参和局部变量名或者类模板的成员名也不能与所属的模板形参表中的形参名相同。</p> </blockquote> <p>和函数形参一样：</p> <ul> <li> <p>模板形参可以存在于模板定义中任何需要使用该形参的位置。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
</span><span class="c1">// 函数模板</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">sumForList</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span>
<span class="p">{</span>
    <span class="c1">// 使用了模板形参中的类型形参T作为类型</span>
    <span class="n">T</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 使用了模板形参中的非类型形参N作为变量</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 类模板</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">N</span><span class="p">,</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="p">&gt;</span> <span class="k">typename</span> <span class="nc">Cls</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span>
<span class="p">{</span>
    <span class="c1">// 使用了模板形参中的模板类形参Cls、类型形参T和非类型形参N作为类型</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="nl">public:</span>
    <span class="c1">// 使用了模板形参中的模板类形参Cls、类型形参T和非类型形参N作为函数形参类型</span>
    <span class="k">explicit</span> <span class="n">Matrix</span><span class="p">(</span><span class="k">const</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">matrix</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// 使用了模板形参中的模板类形参Cls、类型形参T作为初始化值类型</span>
    <span class="n">Matrix</span><span class="p">()</span><span class="o">:</span> <span class="n">list</span><span class="p">({</span><span class="n">Cls</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{}})</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>
    <span class="p">{</span> <span class="n">printMatrix</span><span class="p">(</span><span class="n">list</span><span class="p">);</span> <span class="p">}</span>
    <span class="c1">// 使用了模板形参中的模板类形参Cls、类型形参T作为函数形参类型</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">printMatrix</span><span class="p">(</span><span class="k">const</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">matrix</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="c1">// 使用了模板形参中的模板类形参Cls、类型形参T作为变量类型</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">list</span><span class="o">:</span> <span class="n">matrix</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">uint64_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"["</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"]"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">arrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="o">-</span><span class="mi">48</span><span class="p">};</span>
    <span class="c1">// 输出3</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sumForList</span><span class="p">(</span><span class="n">arrs</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">48</span><span class="p">},{</span><span class="o">-</span><span class="mi">89</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">28</span><span class="p">},{</span><span class="o">-</span><span class="mi">78</span><span class="p">,</span><span class="mi">93</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">12</span><span class="p">}};</span>
    <span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">(</span><span class="n">matrix</span><span class="p">);</span>
    <span class="cm">/* 输出
      [2, 5, 0, -48]
      [-89, 0, 33, 28]
      [-78, 93, 0, 12]
    */</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li>模板声明中的模板形参名不必与定义中相同，甚至还可以省略。</li> <li>如果我们不需要用某个模板形参，我们就可以在模板定义中省略该形参的名字。</li> </ul> <p>模板形参和函数形参不同，模板形参根据其类型不同，可以分为两种：</p> <ul> <li>类型形参</li> <li>非类型形参</li> <li>模板类形参</li> </ul> <h4 id="10411-类型形参"> <a href="#10411-类型形参" class="anchor-heading" aria-labelledby="10411-类型形参"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.411 类型形参 </h4> <p>类型形参在模板形参的声明形式为：</p> <blockquote> <p>typename/class 类型形参名</p> </blockquote> <p>关键字<code class="language-plaintext highlighter-rouge">typename</code>和<code class="language-plaintext highlighter-rouge">class</code>的含义相同，可以互换使用。</p> <p>类型形参也就是表示类型的形参，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。 所以类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</p> <p>对于类型形参的实参来说，可以是任意可用的类型说明符(包括内置类型或者模板的实例)，类型说明符可以包括类型修饰符，但是不能有存储说明符和类型限定符等符号。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 含有两个类型形参的函数模板prints</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ty2</span><span class="p">&gt;</span> 
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">val</span><span class="p">,</span> <span class="n">ty2</span> <span class="n">val2</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div> <p>类型形参的实参还可以结合一些符号形成一些特殊的形式（因为函数的首部可以看作为某种函数指针类型）：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @brief 用于同调用形式不同实现的函数的比较声明，类似std::function
 * 
 * @tparam CallableType 
 */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CallableType</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">FunctionDiff</span> <span class="p">{};</span>

<span class="c1">// 定义正确，可以使用括号结合多个类型。</span>
<span class="c1">// 该形式源于functional头文件function的定义。</span>
<span class="n">FunctionDiff</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">g_obj</span><span class="p">;</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;functional&gt;
</span>
<span class="c1">// 普通函数，首部为void ()</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"normal callable"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 函数指针，首部为void ()</span>
<span class="k">auto</span> <span class="n">g_func_ptr</span> <span class="o">=</span> <span class="n">prints</span><span class="p">;</span>

<span class="c1">// 重载可调用运算符的对象，首部为void ()</span>
<span class="k">class</span> <span class="nc">Function</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="p">()()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"override opearator call"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// lambda对象，首部为void ()</span>
<span class="k">auto</span> <span class="n">g_func</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="k">auto</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"lambda"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="k">return</span> <span class="mf">3.6</span><span class="p">;</span> <span class="p">};</span>

<span class="c1">// function对象，首部为void ()</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">()</span><span class="o">&gt;</span> <span class="n">g_ffunc</span> <span class="o">=</span> <span class="n">prints</span><span class="p">;</span>

<span class="cm">/**
 * @brief 接收任何空形参表的可调用对象。
 * @note 要注意Signature不能是非空形参表的可调用对象或者非可调用对象
 * @tparam Signature 
 * @param func 
 */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Signature</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">runVoidFunction</span><span class="p">(</span><span class="n">Signature</span> <span class="n">func</span><span class="p">)</span> <span class="c1">// func的类型不能加任何的修饰词，限定词</span>
<span class="p">{</span>
    <span class="n">func</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Function</span> <span class="n">op_func</span><span class="p">;</span>
    <span class="n">runVoidFunction</span><span class="p">(</span><span class="n">prints</span><span class="p">);</span>
    <span class="n">runVoidFunction</span><span class="p">(</span><span class="n">g_func_ptr</span><span class="p">);</span>
    <span class="n">runVoidFunction</span><span class="p">(</span><span class="n">op_func</span><span class="p">);</span>
    <span class="n">runVoidFunction</span><span class="p">(</span><span class="n">g_func</span><span class="p">);</span>
    <span class="n">runVoidFunction</span><span class="p">(</span><span class="n">g_ffunc</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="10412-非类型形参"> <a href="#10412-非类型形参" class="anchor-heading" aria-labelledby="10412-非类型形参"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.412 非类型形参 </h4> <p>非类型形参在模板形参的声明形式为：</p> <blockquote> <p>类型说明符(可含类型修饰符) 非类型形参名</p> </blockquote> <p>非类型形参和函数形参一样，表示一个对象而非一个类型。 不过非类型形参中的类型说明符有很大的限制，c++11中非类型形参的类型不能用auto来自动推断，且只能是以下的类型：</p> <ul> <li>整数类型</li> <li>枚举类型</li> <li>指针或左值引用类型</li> </ul> <p>对于非类型形参的实参来说，<strong>该实参必须是常量表达式</strong>，必须要在编译时就能获得。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 含有一个类型形参，一个非类型形参的函数模板prints</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tval</span> <span class="o">=</span> <span class="mi">8</span><span class="p">&gt;</span> 
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val2</span> <span class="o">=</span> <span class="n">tval</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div> <p>根据形参的类型，非类型形参的实参还有以下的限制条件：</p> <ul> <li>对于整数类型和枚举类型的非类型形参的实参来说： 该实参只能是整数类型的常量表达式(可以不是对应类型的)。</li> <li>对于指针或左值引用类型的非类型形参的实参来说： 其必须要是能链接到的（也就是必须是外部或者内部链接，且不能是局部变量）对象。 这也就是指在静态存储区或者堆区的非局部变量对象(也就是不能是临时变量、局部变量以及类类型数据成员等子对象)，且其类型基本上要精确匹配，除了允许从非底层const向底层const的类型转换，其他的转换一律不行。</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
</span>
<span class="c1">// 含有字符串常量指针的非类型模板参数</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">Add</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="o">+</span><span class="n">string</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 内部链接（其他文件不能访问该对象）的静态区的全局对象</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">g_str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"string"</span><span class="p">;</span>
<span class="c1">// 外部链接（其他文件能访问该对象）的静态区的全局对象（不加extern默认就是外部链接）</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">g_str2</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"-string-"</span><span class="p">;</span>
<span class="c1">// 外部链接（其他文件能访问该对象）的堆区的全局对象（不加extern默认就是外部链接）</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">g_str3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">(</span><span class="sc">'d'</span><span class="p">)),</span> <span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">(</span><span class="sc">'s'</span><span class="p">))};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 不能被链接（也就是不能被其他文件或者本文件的其他函数类所访问的）的静态区的局部对象</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"ringle"</span><span class="p">;</span>
    <span class="c1">// 不能被链接（也就是不能被其他文件或者本文件的其他函数类所访问的）的栈区的局部对象</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="n">str2</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"local"</span><span class="p">;</span>
    <span class="c1">// 不能被链接（也就是不能被其他文件或者本文件的其他函数类所访问的）的堆区的的局部对象</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="n">str3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">(</span><span class="sc">'n'</span><span class="p">)),</span> <span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">(</span><span class="sc">'e'</span><span class="p">))};</span>
    <span class="c1">// 正确，g_str为内部链接的静态区的全局对象</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Add</span><span class="o">&lt;</span><span class="n">g_str</span><span class="o">&gt;</span><span class="p">(</span><span class="s">" great"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 正确，g_str2为外部链接的静态区的全局对象</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Add</span><span class="o">&lt;</span><span class="n">g_str2</span><span class="o">&gt;</span><span class="p">(</span><span class="s">" great"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 正确，g_str3为外部链接的堆区的全局对象</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Add</span><span class="o">&lt;</span><span class="n">g_str3</span><span class="o">&gt;</span><span class="p">(</span><span class="s">" great"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 错误，str为不能被链接的静态区的局部对象</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Add</span><span class="o">&lt;</span><span class="n">str</span><span class="o">&gt;</span><span class="p">(</span><span class="s">" great"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 错误，str2为不能被链接的静态区的栈区对象</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Add</span><span class="o">&lt;</span><span class="n">str2</span><span class="o">&gt;</span><span class="p">(</span><span class="s">" great"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 错误，str3为不能被链接的静态区的堆区对象</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Add</span><span class="o">&lt;</span><span class="n">str3</span><span class="o">&gt;</span><span class="p">(</span><span class="s">" great"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="10413-模板类形参"> <a href="#10413-模板类形参" class="anchor-heading" aria-labelledby="10413-模板类形参"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.413 模板类形参 </h4> <p>对于模板形参来说，还有一种特殊的形参，也就叫做模板类形参。 我们可以将一个类模板当做某个模板形参来使用，此时我们只需要在模板形参表写上关键字<code class="language-plaintext highlighter-rouge">template</code>、对应类模板的模板形参表和关键字<code class="language-plaintext highlighter-rouge">typename</code>或<code class="language-plaintext highlighter-rouge">class</code>就行。</p> <p>模板类形参在模板形参的声明形式为：</p> <blockquote> <p>template 类模板的模板形参表 typename/class 模板类形参名</p> </blockquote> <p>关键字<code class="language-plaintext highlighter-rouge">typename</code>和<code class="language-plaintext highlighter-rouge">class</code>的含义相同，可以互换使用。</p> <p>类模板的模板形参表中的模板形参可以有形参名和默认实参，如果填入了默认实参，则使用该模板类形参时会以此时的默认实参为主。</p> <p>对于模板类形参的实参来说，该实参必须是与对应的模板类形参的模板形参表一致的类模板。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 模板prints含有一个模板类形参，且该模板类形参的模板形参表中含有默认实参</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="o">=</span> <span class="n">string</span><span class="p">,</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">&gt;</span> <span class="k">typename</span> <span class="nc">cls</span><span class="p">&gt;</span> 
<span class="kt">void</span> <span class="nf">prints</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cls</span><span class="o">&lt;&gt;</span> <span class="n">ob</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ob</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">ob</span><span class="p">.</span><span class="n">ins</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 类模板Cls</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">18</span><span class="p">&gt;</span> 
<span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="n">ty</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"str"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 正确：默认实参以prints的为主，因此输出str 3</span>
<span class="n">prints</span><span class="o">&lt;</span><span class="n">Cls</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div></div> <h4 id="10414-可变数目形参"> <a href="#10414-可变数目形参" class="anchor-heading" aria-labelledby="10414-可变数目形参"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.414 可变数目形参 </h4> <p>可变数目形参就是指一个可以接受零个或多个对应类型实参的特殊形参，可变数目形参也叫做参数包(parameter packet)。</p> <p>C++中存在两种参数包：</p> <ul> <li>模板参数包(template parameter packet)： 是在模板形参表中的声明的参数包。</li> <li>函数参数包(function parameter packet)： 是在模板中的函数形参表(包括函数模板中的函数形参表和类模板中声明或定义的函数以及成员函数模板中的函数形参表)中声明的参数包。 函数参数包不是之前所说的省略符形参，函数参数包是基于模板参数包所形成的特殊形参。</li> </ul> <blockquote> <p>所有参数包都不能有默认实参。</p> </blockquote> <p>不管是哪一种参数包，含有参数包的形参表都还可以含有其他的非参数包形参，但是每个形参表最多只能含有一个参数包，且必须要放在该形参表的末尾。</p> <h5 id="104141-模板参数包"> <a href="#104141-模板参数包" class="anchor-heading" aria-labelledby="104141-模板参数包"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.4141 模板参数包 </h5> <p>含有模板参数包的模板叫做可变参数模板(variadic template)。</p> <p>根据模板形参的类型，模板参数包一共有三种：</p> <ul> <li>类型参数包</li> <li>非类型参数包</li> <li>模板类参数包</li> </ul> <p>模板参数包的声明形式与普通模板形参类似，任何普通模板形参声明表达式的关键字或者说明符(或修饰符)后，形参名前加上省略符<code class="language-plaintext highlighter-rouge">...</code>，就成了一个模板参数包的声明。</p> <p>模板参数包的声明形式为：</p> <p>类型参数包的声明：</p> <blockquote> <p>typename/class … 参数包名</p> </blockquote> <p>非类型参数包的声明：</p> <blockquote> <p>类型说明符(可含类型修饰符) … 参数包名</p> </blockquote> <p>模板类参数包的声明：</p> <blockquote> <p>template 类模板的模板形参表 typename/class … 参数包名</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 类模板Cls的模板形参表中含有1个类型参数包</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">class</span> <span class="o">...</span> <span class="nc">tys</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="p">{};</span>

<span class="c1">// 类模板Cls2的模板形参表中含有1个非类型参数包</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="p">...</span><span class="n">vals</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls2</span><span class="p">{};</span>

<span class="c1">// 类模板Cls3的模板形参表中含有1个模板类参数包</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span> <span class="k">class</span> <span class="o">...</span><span class="nc">temps</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls3</span><span class="p">{};</span>
</code></pre></div></div> <p>对于模板参数包来说，我们可以将其对应类型的零个或多个实参传递给该参数包，每个实参以逗号<code class="language-plaintext highlighter-rouge">,</code>分隔。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="p">...</span><span class="n">vals</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{};</span>
<span class="c1">// 实例obj中的模板参数包vals中含有5个int模板形参</span>
<span class="n">Cls</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">123</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">;</span>
</code></pre></div></div> <h5 id="104142-函数参数包"> <a href="#104142-函数参数包" class="anchor-heading" aria-labelledby="104142-函数参数包"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.4142 函数参数包 </h5> <p>函数参数包的介绍详见<a href="#1041612-包扩展的作用"><span style="color:green;font:normal bold 18px '楷体'">函数参数包</span></a></p> <h4 id="10415-非参数包的模板形参使用"> <a href="#10415-非参数包的模板形参使用" class="anchor-heading" aria-labelledby="10415-非参数包的模板形参使用"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.415 非参数包的模板形参使用 </h4> <p>各种非参数包的模板形参可以根据自身的类型，用在模板各种能用该类型的地方。 比如类型形参可以用于各种需要类型的地方，比如当做函数返回类型、形参类型、变量类型等；非类型形参可以当作函数默认实参或者用于需要值的某些类型中等；模板类形参以此类推。</p> <p>当我们将模板类型形参或者模板类形参实例当做类类型使用时，我们可以访问其成员，且编译器也不会在模板定义时去确定是否有该成员以及该成员的类型。</p> <p>所以这样会出现一些问题： 之前我们介绍过我们可以用作用域运算符<code class="language-plaintext highlighter-rouge">::</code>来访问一个类类型的静态成员或者类类型成员。 但对于模板来说，编译器不会在模板定义时去检查含有模板参数的表达式。默认情况下，编译器会认为含有模板参数的表达式使用作用域运算符所访问的成员为静态成员（非类类型成员），所以为了能够访问类类型成员，我们就要显式指定访问的是类类型成员。</p> <p>我们通过使用关键字<code class="language-plaintext highlighter-rouge">typename</code>来实现显式访问类类型成员，使用形式为：</p> <blockquote> <p>typename 含有模板参数的表达式::类类型成员名</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">typename</code>要紧跟在该模板类型形参名或模板类形参实例后面，所以static等修饰限定符要放在<code class="language-plaintext highlighter-rouge">typename</code>之前。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span> 
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">obj</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="c1">// 错误：编译器认为cls_int为静态成员，所以出错。</span>
    <span class="n">ty</span><span class="o">::</span><span class="n">cls_int</span> <span class="n">val2</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="c1">// 正确：显式指定cls_int为类类型成员。</span>
    <span class="k">typename</span> <span class="n">ty</span><span class="o">::</span><span class="n">cls_int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="c1">// 错误：编译器认为iterator为静态成员，所以出错。</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span>
    <span class="c1">// 正确：显式指定iterator为类类型成员。</span>
    <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ty</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter2</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">ins</span> <span class="o">+</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
   <span class="k">typedef</span> <span class="kt">int</span> <span class="n">cls_int</span><span class="p">;</span>
   <span class="n">cls_int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 输出83</span>
<span class="n">prints</span><span class="p">(</span><span class="n">Cls</span><span class="p">());</span>
</code></pre></div></div> <h4 id="10416-参数包的使用"> <a href="#10416-参数包的使用" class="anchor-heading" aria-labelledby="10416-参数包的使用"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.416 参数包的使用 </h4> <p>参数包并不是普通的形参，它是包含了多个同类型参数的形参。</p> <p>对于参数包来说，只有两种用法：</p> <ul> <li>包扩展</li> <li>获取包大小</li> </ul> <blockquote> <p>参数包或者包扩展不能单独成为一个语句，也就是不能单独使用，必须要结合其他真正能用上的操作才行。</p> </blockquote> <h5 id="104161-包扩展"> <a href="#104161-包扩展" class="anchor-heading" aria-labelledby="104161-包扩展"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.4161 包扩展 </h5> <p>包扩展是使用参数包最基本的用法，我们只有扩展（expand）了某个参数包后，才能使用该参数包。</p> <h6 id="1041611-包扩展的形式"> <a href="#1041611-包扩展的形式" class="anchor-heading" aria-labelledby="1041611-包扩展的形式"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.41611 包扩展的形式 </h6> <p>包扩展的形式为：</p> <blockquote> <p>扩展模式…</p> </blockquote> <p>扩展模式（pattern）是指==包含有某参数包名==的一个非声明或定义的表达式(比如类型模板参数包的引用，非类型模板参数包与其他表达式的运算，函数参数包的调用等等)。扩展模式会对该参数包中的所有参数应用该表达式。</p> <p>扩展模式后面必须要紧跟一个省略符<code class="language-plaintext highlighter-rouge">...</code>，省略符不能跟在非参数包名后面（圆括号除外）。 对于模板参数包来说，模式和省略符之间不能有空白符；而函数参数包则可以有。</p> <blockquote> <p>省略符优先级比算术运算符等符号要高，所以包扩展时要注意优先级的问题。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 类型模板参数包tys的扩展</span>
<span class="k">const</span> <span class="n">tys</span><span class="o">&amp;</span><span class="p">...</span> 
<span class="c1">// 模板类模板参数包temps的扩展</span>
<span class="n">temps</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">...</span>
<span class="c1">// 非类型模板参数包vals的扩展</span>
<span class="p">(</span><span class="n">vals</span> <span class="o">+</span> <span class="mi">20</span><span class="p">)...</span>
<span class="c1">// 函数参数包objs的扩展</span>
<span class="n">prints</span><span class="p">(</span><span class="n">objs</span><span class="p">)...</span>
</code></pre></div></div> <blockquote> <p>未命名的参数包无法扩展，因为无法指定未命名的对象。</p> </blockquote> <h6 id="1041612-包扩展的作用"> <a href="#1041612-包扩展的作用" class="anchor-heading" aria-labelledby="1041612-包扩展的作用"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.41612 包扩展的作用 </h6> <p>包的扩展就是将该参数包在使用扩展的位置替换为一个包含该参数包所有参数的列表，该列表中的每个参数都应用了其扩展模式，该列表没有括号包围，且每个参数之间由逗号<code class="language-plaintext highlighter-rouge">,</code>分隔。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 类型模板参数包tys，等价于\</span>
<span class="k">const</span> <span class="n">ty1</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">ty2</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">ty3</span><span class="o">&amp;</span><span class="p">,</span> <span class="err">···</span>
<span class="k">const</span> <span class="n">tys</span><span class="o">&amp;</span><span class="p">...</span> 
<span class="c1">// 模板类模板参数包temps，等价于\</span>
<span class="n">temp1</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">temp2</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">temp3</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="err">···</span>
<span class="n">temps</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">...</span>
<span class="c1">// 非类型模板参数包vals，等价于\</span>
<span class="p">((</span><span class="n">val1</span> <span class="o">+</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="n">val2</span> <span class="o">+</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="n">val3</span> <span class="o">+</span> <span class="mi">20</span><span class="p">),</span> <span class="err">···</span><span class="p">)</span>
<span class="p">(</span><span class="n">vals</span> <span class="o">+</span> <span class="mi">20</span><span class="p">)...</span>
<span class="c1">// 非类型模板参数包vals，等价于\</span>
<span class="p">((</span><span class="n">val1</span> <span class="o">+</span> <span class="mi">15</span> <span class="o">+</span> <span class="n">val1</span><span class="p">),</span> <span class="p">(</span><span class="n">val2</span> <span class="o">+</span> <span class="mi">15</span> <span class="o">+</span> <span class="n">val2</span><span class="p">),</span> <span class="p">(</span><span class="n">val3</span> <span class="o">+</span> <span class="mi">15</span> <span class="o">+</span> <span class="n">val3</span><span class="p">),</span> <span class="err">···</span><span class="p">)</span>
<span class="n">vals</span> <span class="o">+</span> <span class="mi">15</span> <span class="o">+</span> <span class="n">vals</span><span class="p">...</span>
<span class="c1">// 函数参数包objs，等价于\</span>
<span class="n">prints</span><span class="p">(</span><span class="n">obj1</span><span class="p">),</span> <span class="n">prints</span><span class="p">(</span><span class="n">obj2</span><span class="p">),</span> <span class="n">prints</span><span class="p">(</span><span class="n">obj3</span><span class="p">),</span> <span class="err">···</span>
<span class="n">prints</span><span class="p">(</span><span class="n">objs</span><span class="p">)...</span>
</code></pre></div></div> <p><strong>函数参数包</strong></p> <p>对于类型模板参数包和模板类模板参数包来说，它们的扩展还有另一种作用，就是可以声明函数参数包。</p> <blockquote> <p>只有这种形式才能声明函数参数包。</p> </blockquote> <blockquote> <p>函数参数包只能出现在模板的函数形参表中，不能出现在其他地方。函数参数包也遵循参数包的各种规则。</p> </blockquote> <p>声明函数参数包的形式为：</p> <blockquote> <p>类型或模板类的模板参数包的扩展 函数参数包名</p> </blockquote> <p>只有扩展模式为模板类模板参数包实例时，才能用模板类模板参数包来声明函数参数包。</p> <p>函数参数包的类型为声明该参数包的模板参数包的扩展类型。 和模板参数包一样，函数参数包可以包含与其类型相同的零个或多个参数(如不需要该参数包参与模板实参推断，则参数还可以是能隐式转成该参数包类型的)。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="c1">// 输出函数模板</span>
<span class="c1">// 返回类型不为void的目的是使包扩展能当作实参</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
<span class="c1">// 因为参数包或者包扩展不能单独成为一个语句，也就是不能单独使用，必须要结合其他真正能用上的操作。所以可以使用该函数来使其生效</span>
<span class="kt">void</span> <span class="nf">get_packet_work</span><span class="p">(...)</span> <span class="p">{}</span>
<span class="c1">// 该函数模板的函数形参表中含有函数参数包obj</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span><span class="nc">tys</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">makes</span><span class="p">(</span><span class="k">const</span> <span class="n">tys</span><span class="p">...</span> <span class="n">objs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 等价于\</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span><span class="n">obj1</span><span class="p">,</span><span class="n">obj2</span><span class="p">,</span><span class="n">obj3</span><span class="p">,</span><span class="err">···</span><span class="p">};</span>
    <span class="c1">// 其中的形参类型都为常量类型。</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span><span class="n">objs</span><span class="p">...};</span>
    <span class="c1">// 等价于\</span>
    <span class="n">get_packet_work</span><span class="p">(</span><span class="n">prints</span><span class="p">(</span><span class="n">obj1</span><span class="p">),</span> <span class="n">prints</span><span class="p">(</span><span class="n">obj2</span><span class="p">),</span> <span class="n">prints</span><span class="p">(</span><span class="n">obj3</span><span class="p">),</span> <span class="err">···</span><span class="p">);</span>
    <span class="n">get_packet_work</span><span class="p">(</span><span class="n">prints</span><span class="p">(</span><span class="n">objs</span><span class="p">)...);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 因为根据函数栈的特性，参数从最后一个开始取，</span>
    <span class="c1">// 所以输出为48 23 478 15</span>
    <span class="n">makes</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">478</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">48</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>调用包含函数参数包的函数时(包括函数模板实例)，该函数参数包所接受的实参数量不能小于声明该参数包的模板参数包所含的参数数量(主要说的是非模板实参推断的实例化)，否则出错。</p> </blockquote> <h6 id="1041613-包扩展适用范围"> <a href="#1041613-包扩展适用范围" class="anchor-heading" aria-labelledby="1041613-包扩展适用范围"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.41613 包扩展适用范围 </h6> <p>包扩展只适用于<a href="https://en.cppreference.com/w/cpp/language/parameter_pack">以下形式</a>，其他形式的语法都会导致编译错误：</p> <ol> <li>函数实参表中(Function argument lists)</li> <li>圆括号初始化表中(Parenthesized initializers)</li> <li>列表初始化表中(Brace-enclosed initializers)</li> <li>模板实参表中(Template argument lists)</li> <li>函数形参表中(Function parameter list)</li> <li>模板形参表中(Template parameter list)</li> <li>类继承表以及类类型数据成员初始化表中(Base specifiers and member initializer lists)</li> <li>lambda函数捕获列表中(Lambda captures)</li> <li><code class="language-plaintext highlighter-rouge">sizeof...</code>运算符表达式中(The operator)</li> <li>动态异常<code class="language-plaintext highlighter-rouge">throw</code>表达式中(Dynamic exception specifications)(c++17之前)</li> <li><code class="language-plaintext highlighter-rouge">alignas</code>对齐声明中(Alignment specifier)</li> <li>属性列表中(Attribute list)</li> <li>折叠表达式中(Fold-expressions)(c++17开始)</li> <li><code class="language-plaintext highlighter-rouge">using</code>声明中(Using-declarations)(c++17开始)</li> <li>包索引(下标运算符内)中(Pack indexing)(c++26开始)</li> </ol> <h5 id="104162-获取参数包的大小"> <a href="#104162-获取参数包的大小" class="anchor-heading" aria-labelledby="104162-获取参数包的大小"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.4162 获取参数包的大小 </h5> <p>当我们需要知道包中含有多少参数时，可以使用<code class="language-plaintext highlighter-rouge">sizeof...</code>运算符。</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">sizeof</code>和省略符<code class="language-plaintext highlighter-rouge">...</code>之间不能有空白符</p> </blockquote> <blockquote> <p><code class="language-plaintext highlighter-rouge">sizeof...</code>运算符为一元运算符，运算对象在右侧括号内。 运算对象为左值。运算结果为右值。</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">sizeof...</code>运算符的使用形式为：</p> <blockquote> <p>sizeof… (参数包名)</p> </blockquote> <p>该运算符的运算对象只能是参数包名，不能为其他的对象。</p> <p><code class="language-plaintext highlighter-rouge">sizeof...</code>返回一个常量表达式，该表达式的值就是所给参数包当前所含的参数数量。 类似<code class="language-plaintext highlighter-rouge">sizeof</code>运算符，不会对其运算对象求值。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span><span class="nc">tys</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">tys</span><span class="p">...</span> <span class="n">obj</span><span class="p">)</span> 
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">obj</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 输出5</span>
    <span class="n">prints</span><span class="p">(</span><span class="mf">3.15</span><span class="p">,</span> <span class="s">"str"</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="sc">'s'</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="1042-模板默认实参"> <a href="#1042-模板默认实参" class="anchor-heading" aria-labelledby="1042-模板默认实参"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.42 模板默认实参 </h3> <p>和函数形参一样，非参数包的模板形参和函数模板中的非参数包的函数形参都可以有默认实参，它们的规则大部分与普通默认实参的规则一样(比如默认实参要放在形参表末尾等)，只有以下的区别：</p> <ul> <li>对于非参数包模板形参的默认实参来说： 同一个模板中，==前面的模板形参可以作为后面模板形参的默认实参==。 一个模板的声明(包括模板友元的声明语句)和定义如果不在同一个文件中，则可以对同一个模板形参有不同的默认实参，但是该模板形参的默认实参只会按照该形参第一个出现的默认实参来决定。 如果在同一个文件中，则有以下特性： <ol> <li>对于函数模板来说，默认实参只能在该模板第一次出现的语句中(声明或定义语句都可以，也包括模板友元的声明语句)，其他语句出现的默认实参无效。 <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="c1">// Prints第一次出现的语句，声明语句，T2带有默认实参</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span> <span class="o">=</span> <span class="n">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">Prints</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="c1">// Prints的定义语句</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">Prints</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Prints2第一次出现的语句，声明语句，没有默认实参</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">Prints2</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="c1">// Prints的定义语句，T1，T2带有默认实参，但因为函数模板的默认实参只能在该模板第一次出现的语句中，所以模板实参推断无效</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">int32_t</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span> <span class="o">=</span> <span class="kt">int32_t</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">Prints2</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="c1">// 调用正确，T被模板实参推断为int</span>
   <span class="n">Prints</span><span class="p">(</span><span class="mi">1548</span><span class="p">);</span>
   <span class="c1">// 调用错误，T2的默认实参无效，模板实参推断无效。</span>
   <span class="n">Prints2</span><span class="p">(</span><span class="mi">1548</span><span class="p">,</span> <span class="mi">887</span><span class="p">);</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li>对于类模板来说，默认实参可以出现在任意的声明或定义语句中（包括模板友元的声明语句），只要遵循默认实参放在形参表末尾且同一形参没有多个默认实参的规则就行。 <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Cls声明语句，没有默认实参</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Cls</span><span class="p">;</span>
<span class="c1">// Cls定义语句，T2带有默认实参</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span> <span class="o">=</span> <span class="n">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Cls</span><span class="p">{};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 调用正确，T2被默认实参指定为int32_t</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">cls</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> </ol> </li> <li> <p>对于函数模板中非参数包的函数形参的默认实参来说： 不能像普通函数一样可以用多个声明来添加默认实参。 默认实参只能在该模板第一次出现的语句中(声明或定义语句都可以，也包括模板友元的声明语句)，其他语句都不能出现默认实参。 和普通函数一样，函数的==局部变量，包括其他形参都不能作为该函数的默认实参==。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 函数模板prints的声明，三个模板形参都有了默认实参</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="o">=</span> <span class="n">string</span><span class="p">,</span> <span class="k">class</span> <span class="o">=</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">prints</span><span class="p">();</span>
<span class="c1">// 函数模板prints的定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ty2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span> 
<span class="kt">void</span> <span class="nf">prints</span><span class="p">()</span> 
<span class="p">{</span> 
    <span class="n">ty1</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"str "</span><span class="p">;</span> 
    <span class="n">ty2</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">58</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">ins</span><span class="p">;</span> 
<span class="p">}</span>
<span class="c1">// 错误，同一个文件中同一个参数的默认实参只能出现一次。</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="p">,</span> <span class="k">class</span><span class="p">,</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">55</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">prints</span><span class="p">();</span>
<span class="c1">// 输出str 58</span>
<span class="n">prints</span><span class="p">();</span>

<span class="c1">// 函数模板，取最大值</span>
<span class="c1">// 因为AType在ResType之前，所以ResType的默认实参可以为AType</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">AType</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BType</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ResType</span> <span class="o">=</span> <span class="n">AType</span><span class="p">&gt;</span>
<span class="n">ResType</span> <span class="nf">Max</span><span class="p">(</span><span class="n">AType</span> <span class="n">a</span><span class="p">,</span> <span class="n">BType</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span><span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ResType与AType类型相同，都为int</span>
    <span class="c1">// dou的值为87</span>
    <span class="kt">double</span> <span class="n">dou</span> <span class="o">=</span> <span class="n">Max</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mf">87.8</span><span class="p">);</span>
    <span class="c1">// 输出为87</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dou</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> </ul> <blockquote> <p><strong>注意：</strong> 对于模板实参全部有默认实参的类模板来说，使用该模板时仍需加上空的显式实参表，否则会编译出错。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 模板实参全部有默认实参的函数模板</span>
<span class="c1">// 使用时可以不用加空的显式实参表</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">int</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">prints</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">T</span><span class="p">{};</span> <span class="p">}</span>

<span class="c1">// 模板实参全部有默认实参的函数模板</span>
<span class="c1">// 使用时必须要加空的显式实参表</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">int</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Coke</span><span class="p">{};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 编译错误</span>
    <span class="n">Coke</span> <span class="n">obj</span><span class="p">;</span>
    <span class="c1">// 正确</span>
    <span class="n">Coke</span><span class="o">&lt;&gt;</span> <span class="n">obj2</span><span class="p">;</span>
    <span class="c1">// 正确</span>
    <span class="n">prints</span><span class="p">();</span>
    <span class="c1">// 正确</span>
    <span class="n">prints</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="105-模板实例化"> <a href="#105-模板实例化" class="anchor-heading" aria-labelledby="105-模板实例化"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.5 模板实例化 </h2> <p>模板的实例化(instantiate)也就是编译器根据模板形参表里的实参或者函数模板中的函数实参来推断出模板形参的类型或者值是什么，并使用这个版本。 当编译器实例化一个模板吋，它使用实际的模板实参代替对应的模板参数来创建出模板的新“实例”，这些通常被称为模板的实例(instantiation)。</p> <p>模板的实例也可以说是根据模板实参，替换掉模板函数或者类里面的所有模板形参，所创建的一个具体的，有着固定内存大小的函数或者类。</p> <p>要注意模板并不是函数或者类，模板只是一个所谓的蓝图，只有模板的实例才是函数或者类。</p> <blockquote> <p>所以函数模板的实例可以被当做可调用对象；类模板的实例可以被当做类型说明符使用。</p> </blockquote> <p>实例创建后会一直保存在同文件中，直到程序结束。 所以当一个模板的实例将要被创建时，编译器会检查同文件中该模板是否已经创建过相同的实例，如果是，则会直接调用之前创建的实例进行操作，否则就创建一个新的实例。</p> <p>当编译器遇到一个模板的定义或声明时，它并不进行实例化，只有使用模板时，才有可能进行实例化。</p> <h3 id="1051-模板编译流程"> <a href="#1051-模板编译流程" class="anchor-heading" aria-labelledby="1051-模板编译流程"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.51 模板编译流程 </h3> <p>在介绍实例化的方式前，我们需要介绍一下模板编译的流程。</p> <p>模板直到实例化吋才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误：</p> <ol> <li>编译模板自身阶段： 在这个阶段，编译器只会对模板中的所有<strong>不依赖于模板参数的名字</strong>进行名字查找(不会进行类型检查)以及各种语法错误检查，例如忘记分号、变量名拼错等，但也就这么多了。</li> <li>模板使用阶段： 在此阶段，编译器才会检查与模板参数有关的部分。通常会检查模板中的模板实参数目是否正确：对于函数模板，会检查函数形参的数量和类型是否匹配；对于类模板，则会检查模板实参的数量和类型是否匹配。但除此之外，编译器仍然没有很多可检查的。</li> <li>模板实例化阶段： 编译器只有在这个阶段才能发现类型相关的错误，依赖于编译器如何管理实例化，这类错误可能在链接时才会报告。 在这一阶段，编译器会检查该模板内的模板调用和函数调用是否匹配。 对于含有包扩展参数的调用表达式，编译器会根据该包所含的实参数量，检查是否符合调用，如果该调用中又含有调用，则沿着调用链向里继续检查，直到所有调用都符合才行，否则编译出错。</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span><span class="nc">tys</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">string</span> <span class="n">str</span><span class="p">,</span> <span class="n">tys</span><span class="p">...</span> <span class="n">obj</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="c1">// 没有用，因为以下是编译阶段进行的检查。</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
       <span class="c1">// 该语句是该模板进行递归调用</span>
       <span class="c1">// 如果该模板要实例化，则在实例化阶段，\</span>
       <span class="err">编译器会沿着调用链检查所有的调用是否匹配，</span>\
       <span class="err">其中当</span><span class="n">obj</span><span class="err">中的参数数量为</span><span class="mi">0</span><span class="err">时，无法匹配到该函数模板，所以实例化会出错。</span>
       <span class="n">prints</span><span class="p">(</span><span class="n">obj</span><span class="p">...);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 调用出错</span>
    <span class="n">prints</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">"str"</span><span class="p">),</span> <span class="n">string</span><span class="p">(</span><span class="s">"str2"</span><span class="p">),</span> <span class="n">string</span><span class="p">(</span><span class="s">"str3"</span><span class="p">),</span> <span class="n">string</span><span class="p">(</span><span class="s">"str4"</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">prints</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span><span class="nc">tys</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">string</span> <span class="n">str</span><span class="p">,</span> <span class="n">tys</span><span class="p">...</span> <span class="n">obj</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="c1">// 该语句是该模板进行递归调用</span>
    <span class="c1">// 如果该模板要实例化，则在实例化阶段，\</span>
    <span class="err">编译器会沿着调用链检查所有的调用是否匹配，</span>\
    <span class="err">其中当</span><span class="n">obj</span><span class="err">中的参数数量为</span><span class="mi">0</span><span class="err">时，会调用空形参表的重载函数，所以会成功实例化。</span>
    <span class="n">prints</span><span class="p">(</span><span class="n">obj</span><span class="p">...);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 调用正确：</span>
    <span class="c1">// 输出str str2 str3 str4</span>
    <span class="n">prints</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">"str"</span><span class="p">),</span> <span class="n">string</span><span class="p">(</span><span class="s">"str2"</span><span class="p">),</span> <span class="n">string</span><span class="p">(</span><span class="s">"str3"</span><span class="p">),</span> <span class="n">string</span><span class="p">(</span><span class="s">"str4"</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p><strong>注意：</strong> 由于模板编译流程的特性，当某模板类的基类是类模板，且基类的类模板使用了模板参数时，如果该模板类直接使用基类的成员，则会报错说找不到该成员，解决方法就是显式使用该成员。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 类模板，充当基类</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Base</span>
<span class="p">{</span> 
    <span class="kt">int32_t</span> <span class="n">intObj</span><span class="p">{</span><span class="mi">55</span><span class="p">};</span> 
<span class="p">};</span>

<span class="c1">// 普通类继承模板基类，基类已实例化</span>
<span class="k">struct</span> <span class="nc">GeneralCls</span><span class="o">:</span> <span class="n">Base</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">test</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 正确：模板基类没有使用模板参数</span>
        <span class="kt">int32_t</span> <span class="n">intt</span> <span class="o">=</span> <span class="n">intObj</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">intt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 类模板继承模板基类，基类已实例化</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">TemplateCls</span><span class="o">:</span> <span class="n">Base</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">set</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="kt">void</span> <span class="n">test</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 正确：模板基类没有使用模板参数</span>
        <span class="kt">int32_t</span> <span class="n">intt</span> <span class="o">=</span> <span class="n">intObj</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">intt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 类模板继承模板基类，基类未实例化</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">TemplateCls2</span><span class="o">:</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">set</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="kt">void</span> <span class="n">test</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="cm">/* 
            错误：
            模板基类Base使用了模板参数，
            在模板TemplateCls2编译的第一阶段会忽略掉该基类Base的检查。
            因此编译器在第一阶段对intObj进行名字查找时由于忽略了基类Base，
            会出现找不到成员的错误。
            解决方法就是显式指明intObj的来源，如
            int32_t intt = this-&gt;intObj;
            int32_t intt = Base&lt;T&gt;::intObj;
        */</span>
        <span class="kt">int32_t</span> <span class="n">intt</span> <span class="o">=</span> <span class="n">intObj</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">intt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div> </div> </blockquote> <blockquote> <p><strong>注意:</strong> 对于模板函数来说，可以将其定义为constexpr函数，只要其满足constexpr函数的定义要求，就能用于需要常量表达式的场合，该模板的实例在编译期就能得出结果</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;array&gt;
</span>
<span class="c1">// 两数相加，constexpr函数</span>
<span class="c1">// 可在编译时得出结果</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n">T</span> <span class="nf">Add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 两数相加，非constexpr函数，不可在编译时得出结果</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">Add2</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="c1">// 错误，ins不是常量表达式，不能用于非类型模板参数</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">ins</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">;</span>
    <span class="c1">// 错误，Add2函数不是常量表达式函数，不能用于非类型模板参数</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Add2</span><span class="p">(</span><span class="mi">2lu</span><span class="p">,</span><span class="mi">8lu</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">arr2</span><span class="p">;</span>
    <span class="c1">// 正确，Add函数是constexpr常量表达式模板函数，可以用于非类型模板参数</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Add</span><span class="p">(</span><span class="mi">2lu</span><span class="p">,</span><span class="mi">8lu</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">arr3</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </blockquote> <h3 id="1052-实例化分类"> <a href="#1052-实例化分类" class="anchor-heading" aria-labelledby="1052-实例化分类"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.52 实例化分类 </h3> <p>模板实例化的方法有以下几种：</p> <ul> <li>隐式实例化</li> <li>显式实例化</li> </ul> <blockquote> <p><strong>注意：</strong> 不管隐式还是显式实例化，在模板实参列表中不能含有任何模板形参，否则就不能实例化了。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 类模板，充当基类</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Base</span>
<span class="p">{</span> 
    <span class="n">T</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 类模板</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">TemplateCls</span>
<span class="p">{</span>
    <span class="c1">// 错误：Base已被隐式实例化，而Base里不存在fakeObj成员，因此会报错</span>
    <span class="kt">int32_t</span> <span class="n">int32Obj</span> <span class="o">=</span> <span class="n">Base</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;::</span><span class="n">fakeObj</span><span class="p">;</span>
    <span class="c1">// 正确：Base已被隐式实例化，Base里存在类型相同的obj成员，编译通过</span>
    <span class="kt">int32_t</span> <span class="n">int32Obj</span> <span class="o">=</span> <span class="n">Base</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;::</span><span class="n">obj</span><span class="p">;</span>
    <span class="c1">// 正确：Base未被实例化，Base里存在类型相同的obj成员，编译通过</span>
    <span class="kt">int32_t</span> <span class="n">int32Obj2</span> <span class="o">=</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">fakeObj</span><span class="p">;</span>
 <span class="p">};</span>
</code></pre></div> </div> </blockquote> <h3 id="1053-隐式实例化"> <a href="#1053-隐式实例化" class="anchor-heading" aria-labelledby="1053-隐式实例化"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.53 隐式实例化 </h3> <p>隐式实例化是指我们在使用模板时所自动进行的实例化。</p> <p>隐式实例化的方法分为两种：</p> <ul> <li>使用显式模板实参列表</li> <li>模板实参推断</li> </ul> <h4 id="10531-显式模板实参列表"> <a href="#10531-显式模板实参列表" class="anchor-heading" aria-labelledby="10531-显式模板实参列表"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.531 显式模板实参列表 </h4> <p>显式模板实参列表(explicit template argument)也叫做模板实参表，它显式给出模板的各个实参，编译器通过这些实参来实例化具体的函数或类（所以实参表中不能含有任何模板形参）。</p> <p>使用模板实参表的形式为：</p> <blockquote> <p>模板名 <模板实参表></模板实参表></p> </blockquote> <p>模板实参表类似于函数实参表，是一个由逗号<code class="language-plaintext highlighter-rouge">,</code>分隔的多个模板实参的列表(可以为空)。</p> <p>和函数实参表一样，模板实参表中的模板实参的数量，顺序和类型要一致。对于有默认实参的模板形参，我们也可以在实参表中省略其实参。</p> <p>对于所有模板形参来说，实参赋值到形参时，会且仅会进行以下的隐式类型转换(不会进行其他的隐式类型转换)：</p> <ul> <li>编译器会忽略顶层const。</li> <li>对于非引用的函数形参来说，函数或者数组名会转换成对应的指针。</li> </ul> <blockquote> <p>所以非类型的模板形参的实参要与其形参类型一致才行。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{};</span>
<span class="c1">// 错误：4.8为double，与int不一致</span>
<span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mf">4.8</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">;</span>
<span class="c1">// 正确</span>
<span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">obj2</span><span class="p">;</span>
</code></pre></div></div> <p>当我们使用了模板实参表后，编译器就会生成一个实例，该实例也就是一个具体的函数或类，我们就可以像使用普通的函数或类一样来使用该实例了。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">v1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">multiple</span> <span class="o">=</span> <span class="n">val</span><span class="p">)</span> 
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v1</span> <span class="o">*</span> <span class="n">multiple</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">35</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="n">ty</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"str"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 使用函数模板实参表，\</span>
<span class="err">输出</span><span class="mf">64.8</span>
<span class="n">prints</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">8.1</span><span class="p">);</span>
<span class="c1">// 使用类模板实参表，\</span>
<span class="err">输出</span><span class="mi">35</span> <span class="n">str</span>
<span class="n">Cls</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ob</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ob</span><span class="p">.</span><span class="n">ins</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">ob</span><span class="p">.</span><span class="n">str</span><span class="p">;</span>
</code></pre></div></div> <p>对于==类模板的隐式实例化==来说，其成员并不是在生成实例后就全部实例化了。 默认情况下，==类模板的非数据成员只有在其被使用时才被实例化==。 这一特性使得即使某种类型不能符合模板操作的要求，我们仍然能用该类型来实例化类模板。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;string&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="n">ty</span> <span class="n">ob_</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">Prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ob_</span><span class="p">.</span><span class="n">str</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 正确：虽然int类型没有str成员，但此时prints没有实例化。</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">;</span>
    <span class="c1">// 正确：输出15</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">ob_</span><span class="p">;</span>
    <span class="c1">// 错误：非数据成员会在模板调用时就实例化</span>
    <span class="c1">// ob_中，int不能转换为std::string。</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">obj2</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="10532-模板实参推断"> <a href="#10532-模板实参推断" class="anchor-heading" aria-labelledby="10532-模板实参推断"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.532 模板实参推断 </h4> <p>编译器利用函数模板调用中的函数实参来确定其模板参数的过程被称为模板实参推断(template argument deduction)。</p> <p>模板实参推断只用于函数模板，模板实参推断也就是指当我们调用一个函数模板时，编译器通常会用函数实参来为我们推断模板实参而不需要显式提供模板实参。</p> <p>模板实参推断只能在以下这两种情况下使用：</p> <ul> <li>类似函数调用形式来调用函数模板。</li> <li>用函数模板来初始化或赋值函数指针。</li> </ul> <p>类似函数调用形式来调用函数模板的形式为：</p> <blockquote> <p>函数模板名(函数实参表)</p> </blockquote> <p>当我们用函数模板来初始化或赋值函数指针时，编译器自动使用指针的各个对应类型来推断模板的实参，此时也必须遵循函数指针的初始化或赋值规则(比如形参数量类型等都要一致)。</p> <p>当我们使用了没有默认实参的模板类型形参或模板类形参作为函数形参的类型时，编译器推断的类型与使用<code class="language-plaintext highlighter-rouge">auto</code>说明符的推断类型一样(也支持引用折叠等操作)：</p> <ul> <li>当函数实参的类型为以下这些时，编译器会自动对其进行类型转换(对于其他类型则不会进行类型转换)： <ul> <li>编译器会忽略顶层const。</li> <li>对于非引用的函数形参来说，函数或者数组名会转换成对应的指针。</li> </ul> </li> <li>每个模板类型形参的类型以第一个使用该形参的函数形参的实参来决定，所以之后使用该形参的函数形参的实参必须要与第一个的一致，否则出错。</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">v1</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints2</span><span class="p">(</span><span class="n">ty</span> <span class="n">v1</span><span class="p">,</span> <span class="n">ty</span> <span class="n">v2</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ar</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// ty为int</span>
  <span class="n">prints</span><span class="p">(</span><span class="n">ins</span><span class="p">);</span>
  <span class="c1">// ty为int*</span>
  <span class="n">prints</span><span class="p">(</span><span class="n">ar</span><span class="p">);</span>
  <span class="c1">// 正确：两个实参的类型一致</span>
  <span class="n">prints2</span><span class="p">(</span><span class="mf">3.45</span><span class="p">,</span> <span class="mf">6.15</span><span class="p">);</span>
  <span class="c1">// 错误：第一个为double，第二个为int</span>
  <span class="n">prints2</span><span class="p">(</span><span class="mf">3.45</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
  <span class="c1">// 正确</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">=</span> <span class="n">prints</span><span class="p">;</span>
  <span class="c1">// 正确</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr2</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">prints2</span><span class="p">;</span>
  <span class="c1">// 错误：第一个为double，第二个为int</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr3</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span> <span class="o">=</span> <span class="n">prints2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">sumForList</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">list</span><span class="p">[</span><span class="n">N</span><span class="p">])</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">sumForList2</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">arrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="o">-</span><span class="mi">48</span><span class="p">};</span>
    <span class="c1">// 错误：数组名arrs被转换成对应的指针，因此无法自动推断非类型参数N的值</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sumForList</span><span class="p">(</span><span class="n">arrs</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 正确：list为arrs的引用，因此可以推断非类型参数N的值为10</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sumForList2</span><span class="p">(</span><span class="n">arrs</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>对于满足以下任意一个条件的函数形参来说，其适用于正常的类型的转换：</p> <ul> <li>其类型不含有模板类型形参以及模板类形参。</li> <li>其类型含有有默认实参的模板形参。</li> </ul> </blockquote> <p>对于函数指针的初始化或赋值来说，如果两边都需要使用类型自动推断的操作时(也就是函数指针的类型为<code class="language-plaintext highlighter-rouge">auto</code>或<code class="language-plaintext highlighter-rouge">decltype</code>，且函数模板的某函数形参的类型使用了没有默认实参的模板类型形参或模板类形参时)则不能使用模板实参推断，只能使用模板实参表来隐式实例化。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">v1</span><span class="p">,</span> <span class="n">ty</span> <span class="n">v2</span><span class="p">)</span> <span class="p">{}</span>
<span class="c1">// 以下两个都错误：不能使用模板实参推断，因为两边都需要使用类型自动推断</span>
<span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">prints</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">prints</span><span class="p">)</span> <span class="o">*</span><span class="n">ptr2</span> <span class="o">=</span> <span class="n">prints</span><span class="p">;</span>

<span class="c1">// 以下两个都正确：使用模板实参表，类型为\</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
<span class="k">auto</span> <span class="n">ptr3</span> <span class="o">=</span> <span class="n">prints</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">prints</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">*</span><span class="n">ptr4</span> <span class="o">=</span> <span class="n">prints</span><span class="p">;</span>
</code></pre></div></div> <p>对于模板实参推断，其还有以下的限制：</p> <ol> <li>当使用函数调用形式的模板实参推断时，对于有默认实参的函数形参来说，满足以下任意一种情况时才能在隐式实例化时省略该实参，否则不能省略： <ul> <li>该函数形参类型不是模板形参。</li> <li>该函数形参类型是有默认实参的模板形参。</li> <li>该函数形参类型不含有模板形参。</li> <li>该函数形参类型含有有默认实参的模板形参。</li> </ul> </li> <li>模板实参推断只能用于满足以下这个条件的函数模板，不满足的函数模板不能使用模板实参推断： <ul> <li>对于函数调用形式的模板实参推断： 函数模板中所有没有默认实参的模板形参都应该出现在==函数形参表的形参类型==中。</li> <li>对于函数指针初始化或赋值的模板实参推断： 函数模板中所有没有默认实参的模板形参都应该出现在函数形参表的==形参类型或者返回类型==中。</li> </ul> </li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">ar</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ty2</span> <span class="o">=</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">8</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty1</span> <span class="n">v1</span><span class="p">,</span> <span class="n">ty2</span> <span class="n">v2</span> <span class="o">=</span> <span class="mi">54</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">v3</span><span class="p">)[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">ar</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v4</span> <span class="o">=</span> <span class="mf">10.5</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v1</span> <span class="o">&lt;&lt;</span> <span class="n">v2</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">v3</span> <span class="o">&lt;&lt;</span> <span class="n">v4</span><span class="p">;</span> <span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ty2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints2</span><span class="p">(</span><span class="n">ty1</span> <span class="n">v1</span><span class="p">,</span> <span class="n">ty2</span> <span class="n">v2</span> <span class="o">=</span> <span class="mi">54</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">v3</span><span class="p">)[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">ar</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v4</span> <span class="o">=</span> <span class="mf">10.5</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v1</span> <span class="o">&lt;&lt;</span> <span class="n">v2</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">v3</span> <span class="o">&lt;&lt;</span> <span class="n">v4</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 隐式实例化正确：可以省略v2,v3,v4的实参</span>
    <span class="n">prints</span><span class="p">(</span><span class="s">"str"</span><span class="p">);</span>
    <span class="cm">/* 隐式实例化错误：v2形参的类型为无默认实参的模板形参
    v3形参的类型含有无默认实参的模板形参
    所以不能省略v2,v3的实参*/</span>
    <span class="n">prints2</span><span class="p">(</span><span class="s">"str"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 函数模板prints的没有默认实参的模板形参ty出现在了函数形参表中</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">8</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">v1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">val</span><span class="p">)</span> <span class="p">{}</span>
<span class="c1">// 函数模板prints2的没有默认实参的模板形参ty没有出现在函数形参表中</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">8</span><span class="p">&gt;</span>
<span class="n">ty</span> <span class="nf">prints2</span><span class="p">(</span><span class="kt">int</span> <span class="n">v1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">val</span><span class="p">)</span> <span class="p">{}</span>
<span class="c1">// 以下三个都正确</span>
<span class="n">prints</span><span class="p">(</span><span class="mf">6.5</span><span class="p">);</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">prints</span><span class="p">;</span>
<span class="kt">double</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr2</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">prints2</span><span class="p">;</span>
<span class="c1">// 错误:不能用模板实参推断</span>
<span class="n">prints2</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
</code></pre></div></div> <p>对于函数模板，<strong>模板实参推断可以与显式模板实参列表结合使用</strong>，也就是对于无法进行模板实参推断的模板参数进行显式指定，而对于其他的模板参数则进行实参推断：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="c1">// 函数模板，取最大值</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ResType</span><span class="p">,</span> <span class="k">class</span> <span class="nc">AType</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BType</span><span class="p">&gt;</span>
<span class="n">ResType</span> <span class="nf">Max</span><span class="p">(</span><span class="n">AType</span> <span class="n">a</span><span class="p">,</span> <span class="n">BType</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span><span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 模板实参推断与显式模板实参列表结合使用，ResType显式指定为int，其他模板参数进行实参推断</span>
    <span class="c1">// dou的值为87</span>
    <span class="kt">double</span> <span class="n">dou</span> <span class="o">=</span> <span class="n">Max</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mf">87.8</span><span class="p">);</span>
    <span class="c1">// 输出为87</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dou</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="1054-显式实例化"> <a href="#1054-显式实例化" class="anchor-heading" aria-labelledby="1054-显式实例化"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.54 显式实例化 </h3> <p>根据模板实例化的特性，当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。</p> <p>这样就会导致一个程序会有多个相同的实例，所以，此时我们需要进行显式实例化来消除这种情况。</p> <blockquote> <p>显式实例化只能出现在全局作用域和命名空间中，不能出现在其他的局部作用域内。 且显式实例化要在模板定义语句所在的作用域内，否则出错。</p> </blockquote> <p>显式实例化的形式有两种：</p> <ul> <li>显式实例化定义</li> <li>显式实例化声明</li> </ul> <p>显式实例化定义的形式为：</p> <blockquote> <p>template 模板的隐式实例化声明</p> </blockquote> <p>显式实例化声明的形式为：</p> <blockquote> <p>extern template 模板的隐式实例化声明</p> </blockquote> <p>模板的隐式实例化声明类似于隐式实例化，也就是该模板中的所有模板形参都含有模板实参的声明形式（所以如果有显式实参表，则其中不能含有任何模板形参）。 对于类模板来说，就是其类关键字加上使用显式实参表的形式；对于函数模板来说，是显式实参表或者实参推断的形式的函数声明形式(也就是含有返回类型和函数形参表的函数声明，其中所有模板形参的类型都换为该形参的实参)。</p> <blockquote> <p>如果原模版的某些模板形参含有默认实参，则显式实例化时的显式实参表可以忽略该参数的填写，其他地方要填写，且类型要和该默认实参一样。</p> </blockquote> <blockquote> <p><strong>注意</strong>：显式实例化的声明和定义中不能含有constexpr，inline等修饰符，也就是原模版有的这些修饰符不要出现在对应的显式实例化中。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;string&gt;
</span>
<span class="c1">// 函数模板prints</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ty2</span><span class="p">&gt;</span>
<span class="n">ty</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty2</span> <span class="n">v1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">multiple</span> <span class="o">=</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ty</span><span class="p">{};</span> <span class="p">}</span>
<span class="c1">// 函数模板prints2，含有constexpr</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n">ty</span> <span class="nf">prints2</span><span class="p">(</span><span class="n">ty</span> <span class="n">v1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ty</span><span class="p">{};</span> <span class="p">}</span>
<span class="c1">// 函数模板print3，含有inline，val含有默认实参</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">ty</span> <span class="nf">prints3</span><span class="p">(</span><span class="n">ty</span> <span class="n">v1</span><span class="p">[</span><span class="n">val</span><span class="p">])</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ty</span><span class="p">{};</span> <span class="p">}</span>
<span class="c1">// 类模板Cls，ty2含有默认实参</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ty2</span> <span class="o">=</span> <span class="kt">int</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{};</span>

<span class="c1">// 函数模板prints的显式实例化声明</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">int</span> <span class="n">prints</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="kt">double</span><span class="p">&gt;(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="c1">// 函数模板prints的显式实例化定义</span>
<span class="k">template</span> <span class="kt">int</span> <span class="n">prints</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="kt">double</span><span class="p">&gt;(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="c1">// 函数模板prints2的显式实例化声明</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">float</span> <span class="n">prints2</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">&gt;(</span><span class="kt">float</span><span class="p">);</span>
<span class="c1">// 函数模板prints2的显式实例化定义</span>
<span class="k">template</span> <span class="kt">float</span> <span class="n">prints2</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">&gt;(</span><span class="kt">float</span><span class="p">);</span>

<span class="c1">// 函数模板prints3的显式实例化声明</span>
<span class="c1">// 因为val含有默认实参，所以显式实参表省略了val，但其他地方还是要填该默认实参值</span>
<span class="k">extern</span> <span class="k">template</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prints3</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="p">&gt;(</span><span class="k">const</span> <span class="kt">char</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
<span class="c1">// 函数模板prints3的显式实例化定义</span>
<span class="c1">// 因为val含有默认实参，所以显式实参表省略了val，但其他地方还是要填该默认实参值</span>
<span class="k">template</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prints3</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="p">&gt;(</span><span class="k">const</span> <span class="kt">char</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>

<span class="c1">// 类模板Cls的显式实例化声明</span>
<span class="c1">// 因为ty2含有默认实参，所以显式实参表省略了val。</span>
<span class="k">extern</span> <span class="k">template</span> <span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">48</span><span class="p">&gt;;</span>
<span class="c1">// 类模板Cls的显式实例化定义</span>
<span class="c1">// 因为ty2含有默认实参，所以显式实参表省略了val。</span>
<span class="k">template</span> <span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">48</span><span class="p">&gt;;</span>
</code></pre></div></div> <p>显式实例化的声明和定义要与对应的模板的声明一致。 而且对于同一个模板实例来说，其显式实例化的声明和定义中的模板实参要一致(可以忽略顶层const；对于非类型形参的实参值是相同的或者能隐式转换成同一个值就行)。</p> <blockquote> <p>同一作用域中，显式实例化声明必须要在显式实例化定义前面，否则会出错。</p> </blockquote> <p>当编译器遇到显式实例化声明时，编译器不会在该处生成实例化代码，显式实例化声明只是承诺同作用域中有其对应的显式实例化定义。</p> <p>当编译器遇到显式实例化定义时，编译器就会在该处生成实例化代码。 和隐式实例化不同的是，==显式实例化定义会实例化该模板的所有成员，包括内联的成员函数==。因此，我们用来显式实例化类模板的实参必须能用于该模板的所有成员。</p> <blockquote> <p>对于一个给定的实例化版本，同作用域中可能有多个显式实例化声明，但有且只有一个对应的显式实例化定义。</p> </blockquote> <blockquote> <p>对于显式实例化定义来说，同作用域中如果在显式实例化定义语句之前已经存在对应声明的全部特例化时，则其所有相同声明的显式实例化定义就不会生效，所以此时可以有多个同声明部分的显式实例化定义。</p> </blockquote> <p>当我们==使用模板(隐式实例化)时，编译器会检查同作用域中是否有相同模板实参的显式实例化，如果有，则按照该显式实例化的实例来进行操作，而不是再创建一个新的实例==。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Application.cpp</span>
<span class="c1">// 这些模板类型必须在程序其他位置进行实例化</span>
<span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="p">&gt;;</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">sa1</span><span class="p">,</span> <span class="n">sa2</span><span class="p">;</span> <span class="c1">// 实例化会出现在其他位置</span>
<span class="c1">// Blob&lt;int&gt;及其接受initializer_list的构造函数在本文件中实例化</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">(</span><span class="n">al</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// 拷贝构造函数在本文件中实例化</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">compare</span> <span class="p">(</span><span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// 实例化出现在其他位置</span>

<span class="c1">// templateBuild.h</span>
<span class="c1">// 实例化文件必须为每个在其他文件中的显式类型或者函数实例化的声明\</span>
<span class="err">提供一个对应的显式实例化定义。</span>
<span class="k">template</span> <span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">template</span> <span class="k">class</span> <span class="nc">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="p">&gt;;</span> <span class="c1">// 实例化类模板的所有成员</span>
</code></pre></div></div> <h2 id="106-模板特例化"> <a href="#106-模板特例化" class="anchor-heading" aria-labelledby="106-模板特例化"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.6 模板特例化 </h2> <p>对于大多数模板来说，通过实例化生成的实例是足够的，但是对于某些特殊的模板实参时，生成的实例可能是不合适的，所以我们有时想编写一些特殊的版本实例来进行一些操作，此时，我们就可以用模板特例化。</p> <p>模板特例化是模板的一种特殊性质，我们可以使用模板特例化来生成一些特殊的模板实例，模板特例化有以下两种形式：</p> <ul> <li>全部特例化</li> <li>部分特例化(偏例化)</li> </ul> <p>模板特例化都是建立在原始模板的基础上的，所以模板特例化只能用于可见的模板中。</p> <p>关于模板特例化语句的出现位置，有以下规定：</p> <ul> <li>对于全部特例化来说，全部特例化语句只能出现在全局作用域和命名空间中，不能出现在其他的局部作用域内。</li> <li>对于部分特例化来说，部分特例化语句还可以出现在类类型和类模板的类体中。</li> <li>与原始模板声明或定义语句的位置关系： <ul> <li>和显式实例化一样，除了成员模板，其他模板的特例化的声明语句要与模板定义语句所在的作用域相同，否则出错。</li> <li>而对于成员模板来说： <ol> <li>成员模板的全部特例化的声明语句要与其类模板所在的作用域相同，如果该类模板也是成员模板，则在该类模板的类模板，一直到包含其所有类模板的非类模板的作用域，否则出错。</li> <li>成员模板的部分特例化的出现位置只要从模板定义语句所在的位置到包含其所有类模板的非类模板的作用域内的任意位置就行，否则出错。</li> </ol> </li> </ul> </li> </ul> <blockquote> <p>模板特例化也可以有声明语句，只要写成特例化定义形式对应的声明语句形式就行。</p> </blockquote> <h3 id="1061-全部特例化"> <a href="#1061-全部特例化" class="anchor-heading" aria-labelledby="1061-全部特例化"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.61 全部特例化 </h3> <p>常见的模板特例化就是全部特例化(template specialization)，全部特例化是指我们可以编写一个特殊版本的实例来对特定的模板实参进行一些操作。</p> <p>要注意全部特例化的本质是一个模板实例，而非模板。</p> <p>全部特例化有两种定义形式：</p> <ol> <li> <blockquote> <p>template &lt;&gt; 函数或者类的实例化语句</p> </blockquote> </li> <li> <blockquote> <p>template &lt;&gt; 类模板成员的实例化语句</p> </blockquote> </li> </ol> <p>第1种形式适用于各种模板，而第2种形式只适用于类模板的静态成员、类类型成员和成员模板。</p> <p>第1种形式中：</p> <ul> <li>函数或者类的实例化语句是指原始模板中对应的函数或类的实例化语句，其中所有的模板形参都被替换为实参，这些实参也需遵循模板实参的规则。 语句中为所有模板形参都提供实参的方式必须要与隐式实例化方式类似，用显式模板实参表或者模板实参推断来提供(和显式模板实参表或者模板实参推断的用法一样，满足省略实参的条件时也可以不提供实参)。</li> </ul> <p>第2种形式中：</p> <ul> <li>第2种形式是只特例化特定成员而不是特例化整个模板。 类模板成员的实例化语句是指该模板的某个成员的实例化语句，就和类类型成员在类外定义一样，我们要在该实例化语句的成员名之前加上该类模板名、尖括号<code class="language-plaintext highlighter-rouge">&lt;&gt;</code>包围的模板实参表和作用域运算符<code class="language-plaintext highlighter-rouge">::</code>来表示我们是在定义类模板的该特殊实例的成员。 <blockquote> <p>要注意这种形式中，该成员实例化语句中的声明部分(如果是成员模板就是模板声明部分)要与模板中该成员的声明部分一样，否则出错。</p> </blockquote> </li> </ul> <blockquote> <p>全部特例化也就是代替编译器手动生成一个特殊的实例，和隐式实例化一样，类模板的成员只有在其使用时才被实例化。</p> </blockquote> <p>当我们==定义或声明一个全部特例化时，编译器会检查是否已存在相同声明的实例的定义，如果已存在，则出错；否则就生成该特殊实例==，该特殊实例的生成规则为：</p> <ul> <li>对于第1种形式，该特殊实例是按全部特例化中的实例化语句来生成的。</li> <li>对于第2种形式，除了全部特例化所指定的特殊成员，该特殊实例的其他成员是按原始模板的定义语句来生成的；对于该全部特例化语句所指定的成员，则使用该语句中的实例化语句来生成该成员。</li> </ul> <blockquote> <p>所以，我们如果要使用模板的全部特例化时，必须要在全部特例化定义语句之后才行，否则会导致编译出错。</p> </blockquote> <blockquote> <p>一个模板可以有多个不同实例的全部特例化。因此，我们不能定义或声明已有实例的全部特例化实例版本。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">v1</span><span class="p">,</span> <span class="n">ty2</span> <span class="n">v2</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">v2</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 函数模板prints的全部特例化</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="kt">double</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">multiple</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">*</span> <span class="n">multiple</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 调用的是普通实例版本\</span>
<span class="err">输出</span><span class="n">str</span> <span class="mi">15</span>
<span class="nf">prints</span><span class="p">(</span><span class="s">"str"</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
<span class="c1">// 调用的是特殊实例版本\</span>
<span class="err">输出</span><span class="mf">497.2</span>
<span class="n">prints</span><span class="p">(</span><span class="mf">45.2</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{</span> <span class="k">static</span> <span class="n">ty</span> <span class="n">ob</span><span class="p">;</span> <span class="p">};</span>
<span class="c1">// 类模板Cls的第1种全部特例化形式</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">string</span> <span class="n">ob</span> <span class="o">=</span> <span class="s">"str"</span><span class="p">;</span>  <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ob</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1">// 类模板Cls的第2种全部特例化形式</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span> <span class="kt">double</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">ob</span> <span class="o">=</span> <span class="mf">125.48</span><span class="p">;</span>
<span class="c1">// 调用的是普通实例版本</span>
<span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">;</span>
<span class="c1">// 调用的是第1种特殊实例版本</span>
<span class="n">Cls</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">obj2</span><span class="p">;</span>
<span class="c1">// 调用的是第2种特殊实例版本</span>
<span class="n">Cls</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">obj3</span><span class="p">;</span>
<span class="c1">// 错误：普通实例版本没有prints成员</span>
<span class="n">obj</span><span class="p">.</span><span class="n">prints</span><span class="p">();</span>
<span class="c1">// 正确：输出str</span>
<span class="n">obj2</span><span class="p">.</span><span class="n">prints</span><span class="p">();</span>
<span class="c1">// 正确：输出125.48</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj3</span><span class="p">.</span><span class="n">ob</span><span class="p">;</span>
</code></pre></div></div> <h3 id="1062-部分特例化"> <a href="#1062-部分特例化" class="anchor-heading" aria-labelledby="1062-部分特例化"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.62 部分特例化 </h3> <p>部分特例化(partial specialization)也叫做偏例化，它只适用于类模板。</p> <blockquote> <p>同一个类模板可以有多个不同的部分特例化。</p> </blockquote> <p>部分特例化是另一种特例化方法，我们可以在特例化时只指定一部分模板形参的实参，或者只指定模板类型形参的一部分而非直接提供一个具体的实参(比如指定成其类型的引用、指针或者常量类型等等，比如<code class="language-plaintext highlighter-rouge">T*</code>、<code class="language-plaintext highlighter-rouge">&amp;&amp;T</code>、<code class="language-plaintext highlighter-rouge">T[]</code>、<code class="language-plaintext highlighter-rouge">T(&amp;)[]</code>这样)，或者是类型模板参数包的扩展模式包含其他关键字。</p> <blockquote> <p>只有模板类型形参才可以指定一部分(当然也可以全部指定，也就是提供具体的实参)，指定其他非参数包类型的模板形参时必须要提供具体的实参。</p> </blockquote> <blockquote> <p>也只有类型模板参数包的扩展模式才能包含其他关键字，其他的模板参数包的扩展模式只能含有该参数包名，不能有其他的。</p> </blockquote> <p>部分特例化时，至少要指定一个形参或者类型模板参数包的非只含有包名的扩展，但也不能将模板形参全都指定具体的实参，否则出错。</p> <blockquote> <p>对于没有默认实参的未命名模板形参，则必须要在模板实参表中对该形参指定具体实参，否则部分特例化定义时无法在实参表表示该形参。</p> </blockquote> <p>部分特例化的定义形式为：</p> <blockquote> <p>template 模板参数列表 模板名 <显式模板实参表> 类体;</显式模板实参表></p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;array&gt;
</span>
<span class="c1">// 原始类模板Base</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">&gt;</span> <span class="k">typename</span> <span class="nc">Cls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Base</span><span class="p">;</span>

<span class="c1">// 类模板Base的第一种部分特例化</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// 类模板Base的第二种部分特例化</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="n">S</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[</span><span class="n">S</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div> <blockquote> <p>部分特例化中的模板参数列表的类型、顺序以及参数名可以与原始模板不一样，也可以有默认实参，如上面类模板<code class="language-plaintext highlighter-rouge">Base</code>的第二种部分特例化。</p> </blockquote> <blockquote> <p>部分特例化中的模板参数列表中不能含有默认实参，否则会报错</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;array&gt;
</span>
<span class="c1">// 原始类模板Base</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Base</span><span class="p">;</span>

<span class="c1">// 错误，模板参数列表的N不能含有默认实参</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">6</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// 正确，类模板Base的部分特例化</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Base</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div> <p>部分特例化中的显式模板实参表中，必须要按原始模板的形参声明顺序，列出原始模板的所有模板参数(对于有默认实参的形参，可以省略其实参)，列出规则为：</p> <ul> <li>对于未指定、只指定部分和扩展的模板形参，则在显式实参表中直接写出该模板形参的名字、指定的部分以及该扩展。</li> <li>对于已指定具体实参的模板形参，则在表中写上该实参。</li> </ul> <blockquote> <p>对于模板参数包来说，在显式模板实参表中如果不指定具体实参给该参数包，则必须要用其扩展形式，因为参数包只有扩展后才能用。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;functional&gt;
</span><span class="cm">/**
 * @brief 用于同调用形式不同实现的函数的比较声明，类似std::function
 * 
 * @tparam CallableType 
 */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CallableType</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">FunctionDiff</span><span class="p">;</span>

<span class="c1">// 包含模板参数包扩展的部分特例化</span>
<span class="cm">/**
 * @brief 抽象基类，用于同调用形式不同实现的函数的比较，使用std::function实现
 * 
 * @tparam ResultType 调用形式中的返回类型
 * @tparam ArgsTypes 调用形式中的各形参
 */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ResultType</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">ArgsTypes</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">FunctionDiff</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">(</span><span class="n">ArgsTypes</span><span class="p">...)</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">(</span><span class="n">ArgsTypes</span> <span class="p">...)</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">FunctionDiff</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>因为部分特例化就是原始模板的一个重载模板，所以当要生成一个实例时，如果该实例中的每个模板实参与该<strong>部分特例化中的显式模板实参表</strong>所表示的实参一模一样时(对于类型实参来说，就是要能转换成对应的实参，且转换所需的内容更少，还要该类型实参的主要特性与实例实参相同)，则编译器会优先调用该部分特例化来生成该实例，否则就调用原始模板。</p> <blockquote> <p>对于常量、引用和指针类型等特性，主要特性就是指其常量、引用和指针，对于显式实参表中没有显式标注常量、引用或者指针等特性的类型实参，其主要特性就不是该特性。</p> <p>指向常量对象的非常量指针或引用，其主要特性是指针或者引用，不是常量。 而对于指向非常量或常量对象的常量指针，其主要特性都是常量，而不是指针类型。</p> </blockquote> <blockquote> <p>如果使用模板时已经存在了相同声明的实例，则编译器是不会调用对应的部分特例化来生成实例的。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{</span> <span class="n">ty</span> <span class="n">ob</span><span class="p">;</span> <span class="p">};</span>
<span class="c1">// 类模板Cls的部分特例化</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="n">ty</span><span class="o">*</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">string</span> <span class="n">ob</span> <span class="o">=</span> <span class="s">"str"</span><span class="p">;</span> <span class="kt">void</span> <span class="n">prints</span> <span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ob</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1">// 调用普通模板来生成实例</span>
<span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">;</span>
<span class="c1">// 模板实参匹配，所以调用部分特例化模板来生成实例</span>
<span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">obj2</span><span class="p">;</span>
<span class="c1">// 错误：普通模板的实例中没有prints成员</span>
<span class="n">obj</span><span class="p">.</span><span class="n">prints</span><span class="p">();</span>
<span class="c1">// 正确：输出str</span>
<span class="n">obj2</span><span class="p">.</span><span class="n">prints</span><span class="p">();</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"original</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1">// 该部分特例化中的显式实参表的第一个类型实参的主要特性为常量类型</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">ty</span><span class="p">,</span> <span class="n">ty2</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"partial spec</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1">// 该部分特例化中的显式实参表的第一个类型实参的主要特性为指针类型</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="n">ty</span><span class="o">*</span><span class="p">,</span> <span class="n">ty2</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"partial spec2</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1">// 该部分特例化中的显式实参表的第一个类型实参的主要特性为引用类型</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="n">ty</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ty2</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"partial spec3</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1">// 该部分特例化中的显式实参表的第一个类型实参的主要特性为引用类型</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">ty</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ty2</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"partial spec4</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 第一个实参的主要特性为普通对象，所以调用原始模板\</span>
    <span class="err">输出</span><span class="n">original</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">();</span>
    <span class="c1">// 第一个实参的主要特性为常量，第一个偏例化的主要特性与其相同，所以调用该模板\</span>
    <span class="err">输出</span><span class="n">partial</span> <span class="n">spec</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">();</span>
    <span class="c1">// 第一个实参的主要特性为指针，第二个偏例化的主要特性与其相同，所以调用该模板\</span>
    <span class="err">输出</span><span class="n">partial</span> <span class="n">spec2</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">();</span>
    <span class="c1">// 第一个实参的主要特性为常量，第一个偏例化的主要特性与其相同，所以调用该模板\</span>
    <span class="err">输出</span><span class="n">partial</span> <span class="n">spec</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">*</span><span class="k">const</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">();</span>
    <span class="c1">// 第一个实参的主要特性为引用，第三偏例化能转换成该实参，且主要特性与其相同，所以调用该模板\</span>
    <span class="err">输出</span><span class="n">partial</span> <span class="n">spec3</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">();</span>
    <span class="c1">// 第一个实参的主要特性为引用，第三，第四偏例化能转换成该实参，且主要特性与其相同，但第四偏例化转换所需的内容更少，所以调用该模板\</span>
    <span class="err">输出</span><span class="n">partial</span> <span class="n">spec4</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="107-类模板再探"> <a href="#107-类模板再探" class="anchor-heading" aria-labelledby="107-类模板再探"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.7 类模板再探 </h2> <p>类模板是可以生成类实例的一种模板。 所以类模板中的类的定义可以包含各种类类型所能拥有的属性，比如有数据、函数以及类类型成员，可以有友元和基类等。</p> <blockquote> <p>所以类模板中不能有任何模板的实例化和全部特例化语句。</p> </blockquote> <p>类模板不是类，它只是一个生成类的蓝图，所以任何需要访问类模板成员的操作都需要通过该模板的实例或者实例的对象来进行。</p> <p>一个类模板的每个实例都形成一个独立的类型。该类型与其他生成的实例的类型都没有关联，也不会对任何其他实例的类型的成员有任何特殊的访问权限。</p> <p>类模板中类的定义与类类型一样，除了接下来所介绍的特性外，其他的都遵循类类型的各种规则。</p> <h3 id="1071-类模板别名"> <a href="#1071-类模板别名" class="anchor-heading" aria-labelledby="1071-类模板别名"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.71 类模板别名 </h3> <p>我们可以定义类型别名，因为类模板的实例也是一个类型，所以我们也可以定义类模板实例的别名。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">OtCls</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">t</span><span class="p">&gt;</span> <span class="k">typename</span> <span class="nc">temp</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{};</span>
<span class="c1">// typedef定义类型别名</span>
<span class="k">typedef</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">OtCls</span><span class="o">&gt;</span> <span class="n">Newcls</span><span class="p">;</span>
<span class="c1">// using定义类型别名</span>
<span class="k">using</span> <span class="n">Newcls2</span> <span class="o">=</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="n">OtCls</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div> <p>c++11标准中，我们还可以用<code class="language-plaintext highlighter-rouge">using</code>关键字来定义类模板别名(不能用<code class="language-plaintext highlighter-rouge">typedef</code>)。</p> <p>使用关键字<code class="language-plaintext highlighter-rouge">using</code>定义类模板别名的语句形式为</p> <blockquote> <p>template 模板形参表 using 类模板别名 = 类型说明符(可含有类型修饰符);</p> </blockquote> <p>定义类模板别名有些类似于类模板的定义：</p> <ul> <li>类模板别名定义时的模板形参表和普通模板定义时的模板形参表一样，可以有各种模板形参，可以有默认实参等。</li> <li>等号<code class="language-plaintext highlighter-rouge">=</code>右边可以含有类型修饰符，作用于类型说明符。</li> <li>类型说明符可以是普通的类，也可以是类模板的实例。 如果是类模板的实例，则该实例中的实参可以是该别名定义中的模板形参名或者模板形参的特性。 此时该实例对应的实参是由该using语句定义的类模板别名的实例所决定的。</li> </ul> <p>使用关键字<code class="language-plaintext highlighter-rouge">using</code>定义的类模板别名是一个含有给定模板形参表的类模板，该类模板所产生的实例也就是语句中等号<code class="language-plaintext highlighter-rouge">=</code>右边所对应的类。</p> <blockquote> <p>因为类模板别名也是模板，所以遵循模板的特性，其语句不能在函数或函数模板内，但可以在类或类模板内。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">OtCls</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">t</span><span class="p">&gt;</span> <span class="k">typename</span> <span class="nc">temp</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{};</span>
<span class="c1">// 模板形参表为&lt;int, typename&gt;的类模板别名Newcls</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span> <span class="k">using</span> <span class="n">Newcls</span> <span class="o">=</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">ty</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">OtCls</span><span class="o">&gt;*</span><span class="p">;</span>
<span class="c1">// 模板形参表为&lt;typename&gt;的类模板别名Newcls2</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span> <span class="k">using</span> <span class="n">Newcls2</span> <span class="o">=</span> <span class="k">const</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="n">OtCls</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// 等价于\</span>
<span class="n">Cls</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">OtCls</span><span class="o">&gt;*</span> <span class="n">n_obj</span><span class="p">;</span>
<span class="n">Newcls</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">n_obj</span><span class="p">;</span>
<span class="c1">// 等价于\</span>
<span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="n">OtCls</span><span class="o">&gt;*</span> <span class="n">n_obj2</span><span class="p">;</span>
<span class="n">Newcls</span><span class="o">&lt;</span><span class="mi">48</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">n_obj2</span><span class="p">;</span>
<span class="c1">// 等价于\</span>
<span class="k">const</span> <span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="n">OtCls</span><span class="o">&gt;</span> <span class="n">n2_obj</span><span class="p">;</span>
<span class="n">Newcls2</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">n2_obj</span><span class="p">;</span>
<span class="c1">// 等价于\</span>
<span class="k">const</span> <span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="n">OtCls</span><span class="o">&gt;</span> <span class="n">n2_obj2</span><span class="p">;</span>
<span class="n">Newcls2</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">n2_obj2</span><span class="p">;</span>
</code></pre></div></div> <h3 id="1072-类模板的特性"> <a href="#1072-类模板的特性" class="anchor-heading" aria-labelledby="1072-类模板的特性"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.72 类模板的特性 </h3> <p>类模板既有模板的特性，也有类的特性。</p> <p>因为类模板是一个模板，当模板成员或者友元需要使用该模板类型时(比如定义构造函数等)，除了一个例外，我们必须要像类模板的隐式实例化一样提供模板实参表来使用，该实参表的实参要与模板形参一一对应(对于有默认实参的形参，可以省略其实参)。</p> <p>该模板实参表中可以包含以下任意一种(由于未命名形参没有名字，所以其只能用第1种方式)：</p> <ol> <li>可以是任何实参，也就是具体的对象、类型或者模板(对应非类型、类型、模板类形参和模板参数包)： 此时该位置的模板类型对应的模板形参的实参就是所给的实参。</li> <li>可以是含有模板形参名的非声明或定义的表达式(比如类型形参的引用，非类型形参与其他表达式的运算等等)或者模板参数包的扩展： 此时该位置的模板类型对应的模板形参的实参还是由该模板的实例所决定。</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span> <span class="o">=</span> <span class="kt">int</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="n">ty</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">ty</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> 
    <span class="p">{</span>
        <span class="c1">// 模板实参表包含实参和模板形参</span>
        <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">;</span> 
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">mem</span> <span class="o">+</span> <span class="n">obj</span><span class="p">.</span><span class="n">ins</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">prints2</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 模板实参表包含模板形参和实参</span>
        <span class="n">Cls</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">ty</span><span class="o">*</span><span class="p">,</span> <span class="mi">25</span><span class="o">&gt;</span> <span class="n">obj2</span><span class="p">;</span>
        <span class="n">obj2</span><span class="p">.</span><span class="n">mem</span> <span class="o">=</span> <span class="s">"this is string"</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj2</span><span class="p">.</span><span class="n">mem</span> <span class="o">&lt;&lt;</span> <span class="n">obj2</span><span class="p">.</span><span class="n">ins</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ob</span><span class="p">;</span>
    <span class="c1">// 输出115</span>
    <span class="n">ob</span><span class="p">.</span><span class="n">prints</span><span class="p">();</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ob2</span><span class="p">;</span>
    <span class="c1">// 输出this is string 25</span>
    <span class="n">ob2</span><span class="p">.</span><span class="n">prints2</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>该例外就是</strong>： 当我们在模板的作用域内使用该模板类型时，可以不用提供模板实参表，此时编译器会自动帮我们加上模板实参表，每个实参都为对应的形参名(无名的形参就填一个无名标记)。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="k">typename</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="n">ty</span> <span class="n">mem</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ins</span><span class="p">;</span>
    <span class="c1">// 等价于\</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="n">ty</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">unnamed</span><span class="o">&gt;&gt;</span> <span class="n">prints</span><span class="p">();</span>
    <span class="n">Cls</span> <span class="n">prints</span><span class="p">();</span>
    <span class="c1">// 等价于\</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="n">ty</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">unnamed</span><span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ty</span> <span class="n">mem</span><span class="p">)</span><span class="o">:</span> <span class="n">mem</span><span class="p">(</span><span class="n">mem</span><span class="p">),</span> <span class="n">ins</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">Cls</span><span class="p">(</span><span class="n">ty</span> <span class="n">mem</span><span class="p">)</span><span class="o">:</span> <span class="n">mem</span><span class="p">(</span><span class="n">mem</span><span class="p">),</span> <span class="n">ins</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div></div> <p>类模板和类类型一样，其成员和类类型的成员一样，既可以在模板内定义，也可以在模板外定义。</p> <p>和类类型一样，因为类模板的类体也是一个作用域：</p> <ul> <li>所以在模板内我们可以直接访问可访问的成员而不需要用模板类型及其对象来访问。</li> <li>当我们在类模板外定义其成员时，我们并不在模板的作用域中，直到成员名遇到类名时才表示进入模板的作用域。</li> </ul> <h3 id="1073-类模板成员的类外定义"> <a href="#1073-类模板成员的类外定义" class="anchor-heading" aria-labelledby="1073-类模板成员的类外定义"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.73 类模板成员的类外定义 </h3> <p>类模板的成员可以在类外定义，不过因为是模板的成员，所以类外定义的形式与类类型的不一样。</p> <p>因为是类模板的成员，类模板的每个实例都有其自己版本的成员。因此，类模板的成员具有和所在类模板相同声明的模板形参表。</p> <p>类成员的类外定义的形式为：</p> <blockquote> <p>template 模板形参表 成员的定义语句(其中包含模板类型)</p> </blockquote> <p>定义在类模板之外的成员必须以关键字<code class="language-plaintext highlighter-rouge">template</code>开始，后接类模板形参表，该形参表中的形参名可以与其模板的形参名不一样。 但是该形参表必须要与类模板的形参表的数量，类型和顺序一致(可以忽略顶层const)，而且该形参表中每个形参都必须要有形参名，且都不能有默认实参。</p> <p>与往常一样，当我们在类模板外定义一个成员时，也必须说明该成员属于哪个模板类型。因此需要在类外定义语句的成员名之前加上模板类型和作用域运算符<code class="language-plaintext highlighter-rouge">::</code>。 因为类模板外定义不在模板的作用域中，所以使用该模板类型时必须要提供模板实参表，且该模板实参表的实参要与该成员的模板形参表中的形参一模一样(不能是具体的实参或者形参的特性)。</p> <blockquote> <p>使用了模板参数的模板成员在类外定义时可以直接在模板形参表之后使用该模板参数的标识符。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="kt">int</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="c1">// 静态数据成员类内声明，使用了模板参数</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">ty</span> <span class="n">mem</span><span class="p">;</span>
    <span class="c1">// 静态数据成员类内声明</span>
    <span class="k">static</span> <span class="kt">double</span> <span class="n">dou</span><span class="p">;</span>
    <span class="c1">// 非静态函数成员类内声明</span>
    <span class="kt">void</span> <span class="n">empty</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
    <span class="c1">// 非静态常量函数成员类内声明，使用了模板参数</span>
    <span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="n">ty</span> <span class="n">val1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val2</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// 静态constexpr函数成员类内声明，使用了模板参数</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">ty</span> <span class="n">prints</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// 类模板静态数据成员的类外定义</span>
<span class="c1">// 可以直接在模板形参表之后使用模板参数的标识符。</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="k">class</span> <span class="nc">t2</span><span class="p">&gt;</span>
<span class="k">const</span> <span class="n">t</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t2</span><span class="o">&gt;::</span><span class="n">mem</span> <span class="o">=</span> <span class="n">t</span><span class="p">{};</span>
<span class="c1">// 类模板静态数据成员的类外定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">t2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">t22</span><span class="p">&gt;</span>
<span class="kt">double</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">t2</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">t22</span><span class="o">&gt;::</span><span class="n">dou</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="c1">// 类模板非静态函数成员的类外定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="k">class</span> <span class="nc">t2</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t2</span><span class="o">&gt;::</span><span class="n">empty</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="c1">// 类模板非静态常量函数成员的类外定义</span>
<span class="c1">// 可以直接在模板形参表之后使用模板参数的标识符。</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="k">class</span> <span class="nc">t2</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t2</span><span class="o">&gt;::</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"external add</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 类模板静态constexpr函数成员的类外定义</span>
<span class="c1">// 可以直接在模板形参表之后使用模板参数的标识符。</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="k">class</span> <span class="nc">t2</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n">t</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t2</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"external print</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="k">return</span> <span class="n">t</span><span class="p">{};</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">105</span><span class="o">&gt;</span> <span class="n">ob</span><span class="p">;</span>
    <span class="c1">// 输出external add</span>
    <span class="n">ob</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">"string"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// 输出external print</span>
    <span class="n">ob</span><span class="p">.</span><span class="n">prints</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="1074-成员模板"> <a href="#1074-成员模板" class="anchor-heading" aria-labelledby="1074-成员模板"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.74 成员模板 </h3> <p>一个类，无论是类类型还是类模板，都可以包含本身是模板的成员。这种成员被称为成员模板(member template)。</p> <p>根据模板的类型，成员模板也分为两种：</p> <ul> <li>成员函数模板</li> <li>成员类模板</li> </ul> <blockquote> <p>成员函数模板的函数不能是虚函数，但可以是静态、常量等函数。</p> </blockquote> <h4 id="10741-成员模板的定义"> <a href="#10741-成员模板的定义" class="anchor-heading" aria-labelledby="10741-成员模板的定义"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.741 成员模板的定义 </h4> <p>根据成员模板在类类型和类模板的区别，成员模板的定义分为两种：</p> <ul> <li>类类型的成员模板定义</li> <li>类模板的成员模板定义</li> </ul> <p>不管是哪一种成员模板，其定义与其对应的成员定义一样，既可以在类内定义，也可以在类外定义，也遵循成员定义的各种规则。</p> <h5 id="107411-类类型的成员模板定义"> <a href="#107411-类类型的成员模板定义" class="anchor-heading" aria-labelledby="107411-类类型的成员模板定义"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.7411 类类型的成员模板定义 </h5> <p>对于在类类型中的成员模板，其定义与类类型的成员定义一样。</p> <p>以下是类类型中的成员模板的类内定义：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"str"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="c1">// 类类型中的成员函数模板prints的类内定义</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">cfy</span><span class="p">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">cfy</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// 类类型中的成员类模板NestCls的类内定义</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ccval</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">NestCls</span>
    <span class="p">{</span> 
        <span class="n">ccy</span> <span class="n">mem</span><span class="p">;</span>
        <span class="k">static</span> <span class="kt">void</span> <span class="n">Nprints</span><span class="p">()</span>
        <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ccval</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <p>和类类型的类外成员定义一样，需要用作用域运算符表明定义的是类的成员，且还必须提供该成员模板自己的模板形参表(该模板形参表与类模板普通成员的类外定义中的模板形参表性质一样，有不能有默认实参等性质)。</p> <p>以下是类类型中的成员模板的类外定义：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"str"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="c1">// 类类型中的成员函数模板prints的类内声明</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">cfy</span><span class="p">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">cfy</span> <span class="n">obj</span><span class="p">);</span>

    <span class="c1">// 类类型中的成员类模板NestCls的类内声明</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ccval</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">NestCls</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 类类型中的成员函数模板prints的类外定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">cfy</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Cls</span><span class="o">::</span><span class="n">prints</span><span class="p">(</span><span class="n">cfy</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 类类型中的成员类模板NestCls的类外定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ccval</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="o">::</span><span class="n">NestCls</span>
<span class="p">{</span> 
    <span class="n">ccy</span> <span class="n">mem</span><span class="p">;</span>
    <span class="c1">// 类类型中的成员类模板NestCls的函数成员Nprints的类内声明</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">Nprints</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// 类类型中的成员类模板NestCls的函数成员Nprints的类外定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ccval</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Cls</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">ccy</span><span class="p">,</span> <span class="n">ccval</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">()</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ccval</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <h5 id="107412-类模板的成员模板定义"> <a href="#107412-类模板的成员模板定义" class="anchor-heading" aria-labelledby="107412-类模板的成员模板定义"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.7412 类模板的成员模板定义 </h5> <p>成员模板也是模板，定义形式和其对应类型的模板定义形式一样，类模板的成员模板和其所在的类模板之前各有自己的独立的模板形参。</p> <blockquote> <p>成员模板的模板形参名不能与所在类模板的模板形参名相同，否则出错。</p> </blockquote> <p>以下是类模板中的成员模板的类内定义：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="n">ty</span> <span class="n">mem</span><span class="p">;</span>
    <span class="n">ty2</span> <span class="n">mem2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="c1">// 成员函数模板prints的类内定义</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">cfy</span><span class="p">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">cfy</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// 成员类模板NestCls的类内定义</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ccval</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">NestCls</span>
    <span class="p">{</span> 
        <span class="n">ccy</span> <span class="n">mem</span><span class="p">;</span>
        <span class="k">static</span> <span class="kt">void</span> <span class="n">Nprints</span><span class="p">()</span>
        <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ccval</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <p>因为成员模板也是模板，所以对于类模板的成员模板来说，该成员模板在类外定义时，既要提供所在类模板相同声明的模板形参表，也要提供该成员模板自己的模板形参表(该模板形参表与类模板普通成员的类外定义中的模板形参表性质一样，有不能有默认实参等性质)。</p> <p>以下是类模板中的成员模板的类外定义：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="n">ty</span> <span class="n">mem</span><span class="p">;</span>
    <span class="n">ty2</span> <span class="n">mem2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="c1">// 成员函数模板prints的类内声明</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">cfy</span><span class="p">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">cfy</span> <span class="n">obj</span><span class="p">);</span>

    <span class="c1">// 成员类模板NestCls的类内声明</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ccval</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">NestCls</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 成员函数模板prints的类外定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">cfy</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">ty</span><span class="p">,</span> <span class="n">ty2</span><span class="p">,</span> <span class="n">val</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">(</span><span class="n">cfy</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 成员类模板NestCls的类外定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ccval</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="n">ty</span><span class="p">,</span> <span class="n">ty2</span><span class="p">,</span> <span class="n">val</span><span class="o">&gt;::</span><span class="n">NestCls</span>
<span class="p">{</span>
    <span class="n">ccy</span> <span class="n">mem</span><span class="p">;</span>
    <span class="c1">// 成员类模板NestCls的函数成员Nprints的类内声明</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">Nprints</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// 成员类模板NestCls的函数成员Nprints的类外定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ty2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ccval</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">ty</span><span class="p">,</span> <span class="n">ty2</span><span class="p">,</span> <span class="n">val</span><span class="o">&gt;::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">ccy</span><span class="p">,</span> <span class="n">ccval</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ccval</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <h4 id="10742-成员模板的实例化"> <a href="#10742-成员模板的实例化" class="anchor-heading" aria-labelledby="10742-成员模板的实例化"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.742 成员模板的实例化 </h4> <p>成员模板的实例化和普通模板的实例化一样，既可以隐式实例化，也可以显式实例化，同时也遵循模板显式实例化的各种规则。</p> <blockquote> <p>根据显式实例化的规则，显式实例化语句不能出现在类体中。</p> </blockquote> <p>对于类模板的成员模板来说，因为成员模板是类模板的成员，所以在实例化时必须还要提供该成员模板所在类模板的模板实参。</p> <p>以下为成员模板的隐式实例化：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 类类型Cls的成员函数模板prints的隐式实例化\</span>
    <span class="err">为模板实参推断</span>
    <span class="n">Cls</span><span class="o">::</span><span class="n">prints</span><span class="p">(</span><span class="s">"str"</span><span class="p">);</span>
    <span class="c1">// 类模板Cls的成员函数模板prints的隐式实例化\</span>
    <span class="err">为模板实参推断</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">(</span><span class="s">"str"</span><span class="p">);</span>

    <span class="c1">// 类类型Cls的成员类模板NestCls的隐式实例化\</span>
    <span class="err">为使用显式模板实参表</span>
    <span class="n">Cls</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">();</span>
    <span class="c1">// 类模板Cls的成员类模板NestCls的隐式实例化\</span>
    <span class="err">为使用显式模板实参表</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>以下为成员模板的显式实例化：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 类类型Cls的成员函数模板prints的显式实例化声明</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">void</span> <span class="n">Cls</span><span class="o">::</span><span class="n">prints</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
<span class="c1">// 类类型Cls的成员函数模板prints的显式实例化定义</span>
<span class="k">template</span> <span class="kt">void</span> <span class="n">Cls</span><span class="o">::</span><span class="n">prints</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
<span class="c1">// 类模板Cls的成员函数模板prints的显式实例化声明</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">void</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="mi">8</span><span class="p">&gt;</span><span class="o">::</span><span class="n">prints</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
<span class="c1">// 类模板Cls的成员函数模板prints的显式实例化定义</span>
<span class="k">template</span> <span class="kt">void</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="mi">8</span><span class="p">&gt;</span><span class="o">::</span><span class="n">prints</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>

<span class="c1">// 类类型Cls的成员类模板NestCls的显式实例化声明</span>
<span class="k">extern</span> <span class="k">template</span> <span class="k">struct</span> <span class="nc">Cls</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">10</span><span class="p">&gt;;</span>
<span class="c1">// 类类型Cls的成员类模板NestCls的显式实例化定义</span>
<span class="k">template</span> <span class="k">struct</span> <span class="nc">Cls</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">10</span><span class="p">&gt;;</span>
<span class="c1">// 类模板Cls的成员类模板NestCls的显式实例化声明</span>
<span class="k">extern</span> <span class="k">template</span> <span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="mi">8</span><span class="p">&gt;</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// 类模板Cls的成员类模板NestCls的显式实例化定义</span>
<span class="k">template</span> <span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="mi">8</span><span class="p">&gt;</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div> <h4 id="10743-成员模板的特例化"> <a href="#10743-成员模板的特例化" class="anchor-heading" aria-labelledby="10743-成员模板的特例化"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.743 成员模板的特例化 </h4> <p>成员模板的特例化和普通模板的特例化一样，既可以全部特例化，也可以部分特例化，同时也遵循模板特例化的各种规则。</p> <blockquote> <p>根据模板特例化的规则，全部特例化语句不能出现在类体中，而部分特例化可以出现在类体中。</p> </blockquote> <p>以下是类类型中的成员模板的特例化定义：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="c1">// 类类型Cls的成员函数模板prints的定义</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">cfy</span><span class="p">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">cfy</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// 类类型Cls的成员类模板NestCls的定义</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ccval</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">NestCls</span>
    <span class="p">{</span>
        <span class="n">ccy</span> <span class="n">mem</span><span class="p">;</span>
        <span class="k">static</span> <span class="kt">void</span> <span class="n">Nprints</span><span class="p">()</span>
        <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ccval</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// 类类型Cls的成员类模板NestCls的部分特例化的类内定义</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">NestCls</span><span class="o">&lt;</span><span class="n">ccy</span><span class="o">*</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="kt">void</span> <span class="n">Nprints</span><span class="p">()</span>
        <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"internal partial spec</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">};</span>
<span class="c1">// 类类型Cls的成员函数模板prints的全部特例化定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Cls</span><span class="o">::</span><span class="n">prints</span><span class="p">(</span><span class="kt">int</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="s">" spec</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 类类型Cls的成员类模板NestCls的第1种形式的全部特例化的定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">Nprints</span><span class="p">()</span>
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"spec No.1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 类类型Cls的成员类模板NestCls的第2种形式的全部特例化的定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Cls</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">()</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"spec No.2</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 类类型Cls的成员类模板NestCls的部分特例化的类外定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ccval</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">ccy</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ccval</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">Nprints</span><span class="p">()</span>
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"external partial spec</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 调用成员函数模板prints的普通实例\</span>
    <span class="err">输出</span><span class="mf">3.5</span>
    <span class="n">Cls</span><span class="o">::</span><span class="n">prints</span><span class="p">(</span><span class="mf">3.5</span><span class="p">);</span>

    <span class="c1">// 调用成员函数模板prints的特例化实例\</span>
    <span class="err">输出</span><span class="mi">3</span> <span class="n">spec</span>
    <span class="n">Cls</span><span class="o">::</span><span class="n">prints</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="c1">// 调用成员类模板NestCls的普通实例\</span>
    <span class="err">输出</span><span class="mi">20</span>
    <span class="n">Cls</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">20</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">();</span>

    <span class="c1">// 调用成员类模板NestCls的第1种形式的全部特例化实例\</span>
    <span class="err">输出</span><span class="n">spec</span> <span class="n">No</span><span class="mf">.1</span>
    <span class="n">Cls</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">();</span>

    <span class="c1">// 调用成员类模板NestCls的第2种形式的全部特例化实例\</span>
    <span class="err">输出</span><span class="n">spec</span> <span class="n">No</span><span class="mf">.2</span>
    <span class="n">Cls</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">();</span>

    <span class="c1">// 调用成员类模板NestCls的类内定义的部分特例化生成的实例\</span>
    <span class="err">输出</span><span class="n">internal</span> <span class="n">partial</span> <span class="n">spec</span>
    <span class="n">Cls</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">();</span>

    <span class="c1">// 调用成员类模板NestCls的类外定义的部分特例化生成的实例\</span>
    <span class="err">输出</span><span class="n">external</span> <span class="n">partial</span> <span class="n">spec</span>
    <span class="n">Cls</span><span class="o">::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>对于类模板的成员模板来说，因为成员模板是类模板的成员，所以在类外特例化时必须还要提供该成员模板所在类模板的模板实参。</p> <p>因为类模板也是模板，所以在声明或定义该类模板的成员模板的全部特例化语句时，该类模板也必须全部特例化，且其要用全部特例化的第2种形式，否则出错。</p> <p>以下是类模板中的成员模板的特例化定义：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="c1">// 类模板Cls的成员函数模板prints的定义</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">cfy</span><span class="p">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">cfy</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// 类模板Cls的成员类模板NestCls的定义</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ccval</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">NestCls</span>
    <span class="p">{</span>
        <span class="n">ccy</span> <span class="n">mem</span><span class="p">;</span>
        <span class="k">static</span> <span class="kt">void</span> <span class="n">Nprints</span><span class="p">()</span>
        <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ccval</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
    
    <span class="c1">// 类模板Cls的成员类模板NestCls的部分特例化的类内定义</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">NestCls</span><span class="o">&lt;</span><span class="n">ccy</span><span class="o">*</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="kt">void</span> <span class="n">Nprints</span><span class="p">()</span>
        <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"internal partial spec</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">};</span>
<span class="c1">// 类模板Cls的成员函数模板prints的全部特例化定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">(</span><span class="kt">int</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="s">" spec2</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 类模板Cls的成员类模板NestCls的第1种形式的全部特例化的定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">Nprints</span><span class="p">()</span>
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"spec No.1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 类模板Cls的成员类模板NestCls的第2种形式的全部特例化的定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">()</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"spec No.2</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 类模板Cls的成员类模板NestCls的部分特例化的类外定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ccy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ccval</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="o">&lt;</span><span class="n">ty</span><span class="p">,</span> <span class="n">val</span><span class="o">&gt;::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">ccy</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ccval</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">Nprints</span><span class="p">()</span>
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"external partial spec</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 调用成员函数模板prints的普通实例\</span>
    <span class="err">输出</span><span class="mf">3.5</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">(</span><span class="mf">3.5</span><span class="p">);</span>

    <span class="c1">// 调用成员函数模板prints的特例化实例\</span>
    <span class="err">输出</span><span class="mi">3</span> <span class="n">spec</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="c1">// 调用成员类模板NestCls的普通实例\</span>
    <span class="err">输出</span><span class="mi">20</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">20</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">();</span>

    <span class="c1">// 调用成员类模板NestCls的第1种形式的全部特例化实例\</span>
    <span class="err">输出</span><span class="n">spec</span> <span class="n">No</span><span class="mf">.1</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">();</span>

    <span class="c1">// 调用成员类模板NestCls的第2种形式的全部特例化实例\</span>
    <span class="err">输出</span><span class="n">spec</span> <span class="n">No</span><span class="mf">.2</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">();</span>

    <span class="c1">// 调用成员类模板NestCls的类内定义的部分特例化生成的实例\</span>
    <span class="err">输出</span><span class="n">internal</span> <span class="n">partial</span> <span class="n">spec</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">();</span>

    <span class="c1">// 调用成员类模板NestCls的类外定义的部分特例化生成的实例\</span>
    <span class="err">输出</span><span class="n">external</span> <span class="n">partial</span> <span class="n">spec</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">NestCls</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;::</span><span class="n">Nprints</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="1075-类模板与友元"> <a href="#1075-类模板与友元" class="anchor-heading" aria-labelledby="1075-类模板与友元"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.75 类模板与友元 </h3> <p>之前我们在介绍类类型时谈到过友元，友元不仅可以是函数或者类，还可以是模板。</p> <p>类模板可以有任何类类型所具有的属性，所以类模板也可以拥有友元。</p> <h4 id="10751-模板实例友元"> <a href="#10751-模板实例友元" class="anchor-heading" aria-labelledby="10751-模板实例友元"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.751 模板实例友元 </h4> <p>对于各种模板实例友元来说，和普通友元一样，遵循各种友元声明的规则：</p> <ul> <li>函数模板实例友元的声明规则和友元函数相同，所以函数模板实例友元可以是在定义类的作用域中不存在的实体。</li> <li>类模板实例友元的声明规则和友元类相同，所以类模板实例友元必须是定义类所能访问到的。</li> </ul> <p>对于类模板中的普通友元(包括内置类型和类类型友元)和模板实例友元来说，该类模板的所有实例都将视它们为友元。</p> <blockquote> <p>我们也可以将类模板的模板类型形参以及模板类形参的实例声明为友元，其访问权限和类模板中的普通友元一样。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 类类型Fcls的声明</span>
<span class="k">struct</span> <span class="nc">Fcls</span><span class="p">;</span>

<span class="c1">// 类模板Cls的定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="c1">// 函数prints为类Cls的友元</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">();</span>
    <span class="c1">// 类型形参ty为类Cls的友元</span>
    <span class="k">friend</span> <span class="n">ty</span><span class="p">;</span>
    <span class="c1">// 类类型Fcls为类Cls的友元</span>
    <span class="k">friend</span> <span class="n">Fcls</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"strCls"</span><span class="p">;</span>
    <span class="n">ty</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">ty</span><span class="p">();</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">cprint</span><span class="p">()</span> <span class="p">{</span> <span class="n">ty</span><span class="o">::</span><span class="n">fprints</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 函数prints的定义</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">()</span> 
<span class="p">{</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">35</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">;</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">ins</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 类类型Fcls的定义</span>
<span class="k">struct</span> <span class="nc">Fcls</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">fprints</span><span class="p">()</span> <span class="p">{</span> <span class="n">Cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">;</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">ins</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 输出strCls 35</span>
    <span class="n">prints</span><span class="p">();</span>
    <span class="c1">// 输出strCls 5</span>
    <span class="n">Fcls</span><span class="o">::</span><span class="n">fprints</span><span class="p">();</span>
    <span class="c1">// 输出strCls 5</span>
    <span class="n">Cls</span><span class="o">&lt;</span><span class="n">Fcls</span><span class="p">,</span> <span class="mi">74</span><span class="o">&gt;::</span><span class="n">cprint</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="10752-模板友元"> <a href="#10752-模板友元" class="anchor-heading" aria-labelledby="10752-模板友元"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.752 模板友元 </h4> <p>和模板实例友元一样，模板友元也遵循各种友元声明的规则：</p> <ul> <li>函数模板友元的声明规则和友元函数相同，所以函数模板友元可以是在定义类的作用域中不存在的实体。</li> <li>类模板友元的声明规则和友元类相同，所以类模板友元必须是定义类所能访问到的。</li> </ul> <p>模板友元的声明语句和普通模板的声明语句类似，为：</p> <blockquote> <p>template 模板参数列表 friend 函数或类的声明语句</p> </blockquote> <p>我们还可以声明类模板的函数成员、类类型成员和成员模板为友元，该友元的声明和它们在类模板的类外声明类似，规则也一样，需要写上所在类模板的形参表、关键字<code class="language-plaintext highlighter-rouge">friend</code>和类模板类型以及作用域运算符<code class="language-plaintext highlighter-rouge">::</code>。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 类模板Fcls的定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Fcls</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">fprints</span><span class="p">();</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">cty</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Nest</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="c1">// 函数模板prints为类Cls的友元</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span> <span class="k">friend</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">ty</span> <span class="o">=</span> <span class="n">val</span><span class="p">);</span>
    <span class="c1">// 类模板Fcls为类Cls的友元</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span> <span class="k">friend</span> <span class="k">struct</span> <span class="nc">Fcls</span><span class="p">;</span>
    <span class="c1">// 类模板Fcls的成员函数fprints为类Cls的友元</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span> <span class="k">friend</span> <span class="kt">void</span> <span class="n">Fcls</span><span class="o">&lt;</span><span class="n">ty</span><span class="p">,</span> <span class="n">val</span><span class="o">&gt;::</span><span class="n">fprints</span><span class="p">();</span>
    <span class="c1">// 类模板Fcls的成员类模板Nest为类Cls的友元</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">cty</span><span class="p">&gt;</span> <span class="k">friend</span> <span class="k">struct</span> <span class="nc">Fcls</span><span class="o">&lt;</span><span class="n">ty</span><span class="p">,</span> <span class="n">val</span><span class="o">&gt;::</span><span class="n">Nest</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">76</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"strCls"</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 函数模板prints的定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">v1</span><span class="p">)</span> <span class="p">{</span> <span class="n">Cls</span> <span class="n">obj</span><span class="p">;</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">v1</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 类模板Fcls的成员函数fprints的类外定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span> 
<span class="kt">void</span> <span class="n">Fcls</span><span class="o">&lt;</span><span class="n">ty</span><span class="p">,</span> <span class="n">val</span><span class="o">&gt;::</span><span class="n">fprints</span><span class="p">()</span> <span class="p">{</span> <span class="n">Cls</span> <span class="n">obj</span><span class="p">;</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">ins</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 类模板Fcls的成员类模板Nest的类外定义</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">cty</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Fcls</span><span class="o">&lt;</span><span class="n">ty</span><span class="p">,</span> <span class="n">val</span><span class="o">&gt;::</span><span class="n">Nest</span>
<span class="p">{</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">fnprints</span><span class="p">()</span> <span class="p">{</span> <span class="n">Cls</span> <span class="n">obj</span><span class="p">;</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">ins</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>模板友元的访问权限为：</p> <ul> <li>对于类类型的模板友元来说，该模板友元的所有实例都是该类类型的友元。</li> <li>对于类模板的模板友元来说，该类模板的所有实例都将视其模板友元的任意实例为友元。</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 输出strCls 6</span>
    <span class="n">prints</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="c1">// 输出76</span>
    <span class="n">Fcls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">39</span><span class="o">&gt;::</span><span class="n">fprints</span><span class="p">();</span>
    <span class="c1">// 输出76 strCls</span>
    <span class="n">Fcls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">9</span><span class="o">&gt;::</span><span class="n">Nest</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">fnprints</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="108-模板重载"> <a href="#108-模板重载" class="anchor-heading" aria-labelledby="108-模板重载"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 10.8 模板重载 </h2> <p>函数模板可以被另一个相同名字的模板或者一个普通非模板同名函数重载。只要它们之间的模板形参表或者函数形参表不一致就行。</p> <p>不过类模板不支持重载，所以类名相同但模板形参表不同的模板会导致重复定义。</p> <blockquote> <p>类模板的部分特例化虽然是模板，但这不是重载，部分特例化与重载有很大区别，部分特例化不支持随意拓展或者改变原始的模板形参表。</p> </blockquote> <p>含有函数模板的函数匹配和普通函数的匹配规则类似，只有某些不同，以下是含有函数模板的函数匹配流程：</p> <ul> <li>对于一个函数调用，其候选函数不仅仅是在调用点可访问的普通同名函数，还包括所有的可行的函数模板实例。 可行的函数模板实例是指： 编译器根据实参类型，推断所有在调用点可访问的同名模板所对应的函数实例。并在其中排除掉所有的不可行函数实例，最后留下的都是可行的函数实例，也就是可行的函数模板实例。 <blockquote> <p>编译器只是推断实参所对应的实例，而不是真正的生成实例。</p> </blockquote> </li> <li>与往常一样，编译器会排除所有不可行的普通同名函数，然后对所有可行函数(包括普通函数和模板所推断的函数)按形参类型进行优先级排序。</li> <li>与往常一样，如果有且只有一个最佳函数，则调用该函数；但如果有多个匹配度同样好的函数，那么当这些同样好的函数中有且只有一个非模板函数，则调用该函数；否则，此调用无匹配或者有歧义。</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 对于调用prints(&amp;ins)，该模板对应的函数实例声明为：\</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="k">const</span> <span class="n">ty</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Temp func No.1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 对于调用prints(&amp;ins)，该模板对应的函数实例声明为：\</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Temp func No.2</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 普通函数</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Func No.1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
    <span class="c1">// 最佳函数的声明为\</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>\
    <span class="err">所以就调用</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">ty</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span><span class="err">模板</span>\
    <span class="err">输出</span><span class="n">Temp</span> <span class="n">func</span> <span class="n">No</span><span class="mf">.2</span>
    <span class="n">prints</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ins</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 对于调用prints(&amp;ins)，该模板对应的函数实例声明为：\</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="k">const</span> <span class="n">ty</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Temp func No.1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 对于调用prints(&amp;ins)，该模板对应的函数实例声明为：\</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Temp func No.2</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 普通函数</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Func No.1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
    <span class="c1">// 最佳函数的声明为\</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>\
    <span class="err">有两个函数满足该声明，其中一个是普通函数，所以调用普通函数的版本</span>\
    <span class="err">输出</span><span class="n">Func</span> <span class="n">No</span><span class="mf">.1</span>
    <span class="n">prints</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ins</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>模板匹配时如果出现歧义，但又需要调用函数模板生成的实例，则可以在调用时显式指定一个空的模板列表，来表示调用函数模板的实例。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="c1">// 取最大值</span>
<span class="kt">int</span> <span class="nf">Max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"this is notemplate function"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 取两个相同类型对象的最大值</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">Max</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"this is template function"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 最佳匹配为int(int, int)，但非模板函数优先级更高，所以调用非模板函数</span>
    <span class="c1">// 输出this is notemplate function</span>
    <span class="kt">double</span> <span class="n">dou</span> <span class="o">=</span> <span class="n">Max</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">87</span><span class="p">);</span>
    <span class="c1">// 最佳匹配为int(int, int)，但是由于显式指定了一个空的模板列表</span>
    <span class="c1">// 因此只匹配模板函数实例</span>
    <span class="c1">// 输出this is template function</span>
    <span class="n">dou</span> <span class="o">=</span> <span class="n">Max</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">87</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>对于含有模板参数包的函数模板来说，如果某些重载函数中含有函数参数包，不管是显式提供实参表还是进行模板实参推断，对于所有的可行模板实例来说，没有函数参数包的模板实例优先级最高，其次是含有其他非函数参数包的形参最多的模板实例，以此类推，只含有函数参数包的模板实例优先级最低。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"common</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span><span class="nc">tys</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">obj</span><span class="p">,</span> <span class="n">tys</span><span class="p">...</span> <span class="n">objs</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"omission</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ty2</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span><span class="nc">tys</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">obj</span><span class="p">,</span> <span class="n">ty2</span> <span class="n">obj2</span><span class="p">,</span> <span class="n">tys</span><span class="p">...</span> <span class="n">objs</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"omission2</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ty2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ty3</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span><span class="nc">tys</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span> <span class="n">obj</span><span class="p">,</span> <span class="n">ty2</span> <span class="n">obj2</span><span class="p">,</span> <span class="n">ty3</span> <span class="n">obj3</span><span class="p">,</span> <span class="n">tys</span><span class="p">...</span> <span class="n">objs</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"omission3</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 都输出common</span>
    <span class="n">prints</span><span class="p">(</span><span class="mi">45</span><span class="p">);</span>
    <span class="n">prints</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">31.1</span><span class="p">);</span>
    <span class="c1">// 都输出omission2</span>
    <span class="n">prints</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="s">"str"</span><span class="p">);</span>
    <span class="n">prints</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.15</span><span class="p">);</span>
    <span class="c1">// 都输出omission3</span>
    <span class="n">prints</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="s">"str"</span><span class="p">,</span> <span class="mf">23.4</span><span class="p">);</span>
    <span class="n">prints</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"str"</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mf">23.4</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> </div> </div> </main> <hr> <footer> <!-- # Footer content # appears at the bottom of every page's main content --> <p class="text-small text-grey-dk-100 mb-0"> Copyright &copy; 2020-2024 bobokick. Distributed by an <a href="https://github.com/bobokick/Cpp_Guide_detailed/blob/master/LICENSE">Apache License 2.0.</a> </p> <div class="d-flex mt-2"> <p class="text-small text-grey-dk-000 mb-0"> <a href="https://github.com/bobokick/Cpp_Guide_detailed/tree/master/docs/my_collections/_guide_files/chap10/第10章_模板.md" id="edit-this-page">Edit this page on GitHub.</a> </p> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js"></script> <script> var config = {} ; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid')); </script> </body> </html>
