{"0": {
    "doc": "About",
    "title": "About",
    "content": "This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at jekyllrb.com . You can find the source code for Minima at GitHub: jekyll / minima . You can find the source code for Jekyll at GitHub: jekyll / jekyll . ",
    "url": "/Cpp_Guide_detailed/about.html",
    
    "relUrl": "/about.html"
  },"1": {
    "doc": "第一章 c++入门介绍",
    "title": "第一章 c++入门介绍",
    "content": "第1章先介绍了基本的编译流程，然后详细介绍预处理阶段的各种预处理指令。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/index.html",
    
    "relUrl": "/guide_files/chap1/index.html"
  },"2": {
    "doc": "预处理指令概念详解",
    "title": "1.1 预处理器介绍",
    "content": "C预处理器是多种计算机编程语言（如C、Objective-C、C++和各种Fortran语言）的宏预处理器。预处理器提供头文件、宏扩展、条件编译和行控制等操作。 . 预处理器指令的语言与C语言的语法关系不大，因此有时用于处理其他类型的文本文件。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#11-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#11-预处理器介绍"
  },"3": {
    "doc": "预处理指令概念详解",
    "title": "1.11 预处理器历史",
    "content": "预处理器于1973年左右，在Alan Snyder的敦促下引入到C语言中，也是为了认识到BCPL和PL/I中可用的文件包含机制的有用性。它的原始版本仅提供文件包含和简单的字符串替换，也就是使用#include和#define来进行。不久之后，它首先由Mike Lesk扩展，然后由John Reiser扩展，以将宏与参数和条件编译合并。 . C预处理器是贝尔实验室悠久的宏语言传统的一部分，该传统由Douglas Eastwood和Douglas McIlroy于1959年创立。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#111-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%8E%86%E5%8F%B2",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#111-预处理器历史"
  },"4": {
    "doc": "预处理指令概念详解",
    "title": "1.12 从代码编辑到程序运行中的过程",
    "content": "c++和c语言一样，从源代码编写到程序运行时，分为四大阶段： . | 预处理阶段 | 编译阶段 | 汇编阶段 | 链接阶段 | . 执行这四个阶段的程序(预处理器、编译器、汇编器、链接器)一起构成了编译系统。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#112-%E4%BB%8E%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E8%BF%87%E7%A8%8B",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#112-从代码编辑到程序运行中的过程"
  },"5": {
    "doc": "预处理指令概念详解",
    "title": "1.121 预处理阶段",
    "content": "预处理阶段期间，预处理器会根据源文件(.cpp/.c)里的预处理指令，修改源文件(.cpp/.c)中的一些代码，修改完后的所有代码保存在一个预处理文本文件(.i)中。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1121-%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1121-预处理阶段"
  },"6": {
    "doc": "预处理指令概念详解",
    "title": "1.122 编译阶段",
    "content": "编译阶段期间，编译器会将预处理文本文件(.i)里的所有代码翻译成一种能被汇编语言程序所识别的代码，所有翻译后的代码保存在汇编文本文件(.s)中。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1122-%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1122-编译阶段"
  },"7": {
    "doc": "预处理指令概念详解",
    "title": "1.123 汇编阶段",
    "content": "汇编阶段期间，汇编器将汇编文本文件(.s)翻译成机器代码，也叫做机器语言指令(也就是由二进制值组成的代码，计算器能够识别的代码)，并将这些机器语言指令打包成一种叫做可重定位目标程序(relocate object program)的格式，并将结果保存在一个目标文件(.obj/.o)中。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1123-%E6%B1%87%E7%BC%96%E9%98%B6%E6%AE%B5",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1123-汇编阶段"
  },"8": {
    "doc": "预处理指令概念详解",
    "title": "1.124 链接阶段",
    "content": "通常我们所用的程序并不单单是由一个源文件的代码转换而来。 绝大多数都是由多个源文件的代码组合而来。所以就有了链接阶段。 链接阶段期间，链接器将会把所有程序代码转换而成的目标文件(.obj/.o)和可能要用到静态库文件的某些函数的部分(.lib/.a)(一些由常用代码的目标文件打包而成的二进制文件)链接到一起(如果要用到动态库文件，则会对这些用到的代码位置做上标记，而不会直接合在一起)，生成一个操作系统能够运行的程序文件，也叫做可执行目标文件(.exe/.out)。 . 虽然编程时可以不需要预处理阶段的指令就能够生成出可执行程序文件了。但实际开发中，常常需要在编译阶段前对源文件进行一些简单的处理，比如替换一些代码，删除一些代码等操作。 . 例如，我们希望自己的程序在Windows和Linux下都能够运行，那么就要在Windows下使用VS编译一遍，然后在Linux下使用GCC编译一遍。但是现在有个问题，程序中要实现的某个功能在VS和GCC下使用的函数不同(假设VS下使用a()，GCC下使用b())，怎么办呢？ 这就需要在编译之前先对源文件进行处理：如果检测到是VS，就保留a()删除b()；如果检测到是GCC，就保留b()删除a()。 . c提供了一些预处理功能，也就叫预处理指令。能够让我们在预处理阶段对代码进行一些处理工作，c++也继承了这些功能。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1124-%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1124-链接阶段"
  },"9": {
    "doc": "预处理指令概念详解",
    "title": "1.13 预处理阶段",
    "content": "预处理过程由C标准中规定的前四个（共八个）翻译阶段所定义: . | 三元组替换(Trigraph replacement)：预处理器将所有三元组序列替换为它们所表示的字符。此阶段将会在C23标准中被删除。 | 行拼接(Line splicing)：结尾带有\\字符的原始的源码行将被拼接成一起，形成逻辑行。 | 符号化(Tokenization)：预处理器将上一步的结果分解为预处理符号和空格。并将所有注释都替换为空格。 | 宏扩展和预处理指令处理(Macro expansion and directive handling)：执行预处理指令行(#line)，文件包含(#include)和条件编译(#if, #else, …)。预处理器同时也会进行宏扩展，并处理_Pragma运算符(从1999年的C标准版本起)。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#113-%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#113-预处理阶段"
  },"10": {
    "doc": "预处理指令概念详解",
    "title": "1.2 预处理语法介绍",
    "content": "在介绍预处理功能之前，我们需要了解一些概念。 c++语言中的代码文本，都是由两大部分组成： . | 词法元素 | 空白符 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12-%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12-预处理语法介绍"
  },"11": {
    "doc": "预处理指令概念详解",
    "title": "1.21 词法元素",
    "content": "词法元素(token)是c++程序中的==基本意义单元==，所有能被预处理器和编译器==识别==的==可见符号==都是词法元素，比如变量名，数据类型，各种语言的关键字等。 . 词法元素是由一个或多个空白符分隔来区分的。 当两个词法元素之间没有空白符时，预处理器和编译器会认为这是一个词法元素。 . 词法元素是指有其==自身意义==的==可见==符号单元，所以空白符不是词法元素，字符、字符串常量、字符串字面值和注释内的所有文本都不是词法元素。 . 词法元素分为以下几种： . | 标识符(Identifiers) . | 关键字(Keywords) | . | 字面值常量(Literals) | 标点符号(Punctuators) . | 运算符符号(Operators) | . | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#121-%E8%AF%8D%E6%B3%95%E5%85%83%E7%B4%A0",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#121-词法元素"
  },"12": {
    "doc": "预处理指令概念详解",
    "title": "1.211 标识符",
    "content": "标识符就是用于表示各种对象，实体，操作等事物的==字符序列==(sequence of characters)。 . 标识符可以用于表示以下这几种事物： . | 对象或变量的名称 | 类型、结构体、联合类和枚举类的名称以及它们成员的名称 | 函数名称以及其参数的名称 | 类型别名 | 标签名称 | 宏名称以及其参数的名称 | . 同一作用域下的某些事物的名称必须有所区别： . | 各种类型的变量名要和函数名有所区别 | 各种类型的变量名之间要有所区别 | 各种类型名之间要有所区别 | . 标识符只能由==字母、数字、下划线_和美元符号$组成==，其中必须以字母、下划线或者美元符号开头。标识符的长度没有限制，但是对大小写字母敏感。 . 同时C++语言也保留了一些名字供语言本身使用，这些名字也叫做关键字，关键字不能被当做名称来使用。 . 关键字 . 关键字也就是在c++中被预先定义好了的一些标识符，这些关键字用在c++中各种操作中，如class, if, else等都属于关键字。 以下是c++的关键字： . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1211-%E6%A0%87%E8%AF%86%E7%AC%A6",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1211-标识符"
  },"13": {
    "doc": "预处理指令概念详解",
    "title": "1.212 字面值常量",
    "content": "字面值常量是一种可以直接表示值的词法元素，字面值常量的类型分为以下几种，之后我们会详细介绍字面值常量。 . | 整型字面值 | 浮点型字面值 | 字符字面值 | 字符串字面值 | 布尔字面值 | 指针字面值 | 自定义字面值 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1212-%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1212-字面值常量"
  },"14": {
    "doc": "预处理指令概念详解",
    "title": "1.213 标点符号",
    "content": "标点符号也是C++中的一种词法元素。之后会详细介绍标点符号。 C++中的标点符号分为两种： . | 运算符符号 | 其他符号 | . 对于非运算符符号来说，它们具有语法意义和语义含义，但它们本身不会指定一个产生数值的操作。 而运算符符号是一种有作用对象的特殊符号。运算符符号会根据其作用对象的值来产生一个新的值。 . 以下为c++的标点符号： . | ! % ^ &amp; * ( ) - + = { } | ~ [ ] \\ ; ‘ : “ &lt; &gt; ? , . / # | . 标点符号 []、 ( ) 和 {} 必须成对出现 . 要想某个标点符号不产生其特殊的意义，而只是单纯的当一个符号来使用时(也就是当成一个字符)，则需要在其符号之前紧跟一个转义字符\\来使其变成普通的字符，形式为： \\符号 . 如： \\{ \\\" . 转义字符\\本身也可以用这种方式来使用自己的普通字符版本 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1213-%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1213-标点符号"
  },"15": {
    "doc": "预处理指令概念详解",
    "title": "1.22 空白符",
    "content": "空白符一般是指在c++代码编辑中不可见的符号，如空格，换行等。 . 空白符会影响代码中的语句分割，从而影响预处理器分析语法，以下是空白符的分类： . | 空格符(Blanks) | 制表符(Tabs) . | 水平或者垂直制表符(Horizontal or vertical tabs) | . | 换行符(New lines) | 换页符(Form feeds) | 注释(Comments) . | 单行注释 | 多行注释 | . | . 各种空白符在字符串常量、字符串字面值中没有特殊含义。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#122-%E7%A9%BA%E7%99%BD%E7%AC%A6",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#122-空白符"
  },"16": {
    "doc": "预处理指令概念详解",
    "title": "1.221 空格符",
    "content": "空格符就是用键盘space键打出来的符号。 在没有明确说明的情况下，各种语句，表达式的词法元素之前、之间和之后可以有一个或多个空格符。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1221-%E7%A9%BA%E6%A0%BC%E7%AC%A6",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1221-空格符"
  },"17": {
    "doc": "预处理指令概念详解",
    "title": "1.222 制表符",
    "content": "制表符就是用键盘tab键打出来的符号。 在大多数代码编辑器的编辑中，一个制表符是由多个空格符代替的。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1222-%E5%88%B6%E8%A1%A8%E7%AC%A6",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1222-制表符"
  },"18": {
    "doc": "预处理指令概念详解",
    "title": "1.223 换行符",
    "content": "换行符就是用键盘enter键打出来的符号。 在大多数代码编辑器的编辑中，换行符之后也就是另起一行了。 . 在一般的表达式和语句中，换行符对其没有影响，不会产生切割作用(也就是将其分为两个语句或表达式)。 但在以下情形中，换行符会产生切割作用: . | 字符串中 | 单行注释中 | 宏定义中 | . 要使换行符不产生切割作用，则要在该换行符之前紧跟一个转义字符\\来使其变成一个普通的字符 . cout &lt;&lt; \"Im a good student.\"; // 错误：字符串被切割，出错 cout &lt;&lt; \"Im a good\\ student.\"; // 正确：没有被切割，还是一个字符串 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1223-%E6%8D%A2%E8%A1%8C%E7%AC%A6",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1223-换行符"
  },"19": {
    "doc": "预处理指令概念详解",
    "title": "1.224 换页符",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1224-%E6%8D%A2%E9%A1%B5%E7%AC%A6",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1224-换页符"
  },"20": {
    "doc": "预处理指令概念详解",
    "title": "1.225 注释",
    "content": "注释是对于程序员非常有用的文本，通常用于批注代码以供将来参 考。 预处理器会将注释视为多个空格符。 . 以下是注释的分类： . | 单行注释 | 多行注释 | . 注释字符 (/* 、 */ 和 //) 在字符串常量、字符串字面值或注释中没有特殊含义。 多行注释不能嵌套。 . 单行注释 . 单行注释是由//(两个斜杠，中间不能有空白符)开头的，后面跟任何字符序列的序列。一个单行注释以一个有切割作用的换行符作为结束。 . 单行注释内的文本可以是任何字符(除了有切割作用的换行符)，所以可以嵌套。 . // 这是一个单行注释，由换行符结束 // 这是一个单行注释，\\ 无切割作用的换行符\\ 不会结束一个单行注释。 . 多行注释 . 多行注释是由/*(斜杠、星号，中间不能有空白符)开头的，后面跟任何字符序列的序列。多行注释以*/(星号、斜杠，中间不能有空白符)作为结束。 . 多行注释内的文本可以是任何字符(除了*/)，所以可以跨越多行，但不能嵌套。 . // 下面是一个多行注释，由*/结束 /* 这是一个多行注释 */ // 错误，多行注释不能嵌套 /* 这是一个多行注释 /*嵌套注释*/ */ . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1225-%E6%B3%A8%E9%87%8A",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1225-注释"
  },"21": {
    "doc": "预处理指令概念详解",
    "title": "1.23 预处理指令",
    "content": "c提供了一些预处理功能，也就叫预处理指令。能够让我们在预处理阶段对代码进行一些处理工作，c++也继承了这些功能。 . | 宏定义 | 条件编译 | 阻止编译 | 包含编译 | 调试操作 | 杂注操作 | . 预处理指令不是表达式，不是语句，但是所有预处理指令在使用时必须要在一行的开头。 . 所有预处理指令都可以在任何地方使用(函数内，类内，控制语句块内，命名空间内)。但预处理指令没有局部全局作用域之分。 . 如无明确说明，预处理指令的作用范围默认为从使用位置后到包含该指令的文件末尾。 . 预处理指令都是以#开头的。符号#和指令的标识符之间可以有一个或多个空白符。 . 所有预处理指令和单行注释一样，以有切割作用的换行符作为结束 . 所有预处理指令内部不能包含有任何其他的预处理指令(包括自身类型的预处理指令)。 也就是预处理指令不能嵌套。 . 最简单的预处理指令为空指令(Null)，使用形式为： . # . 它只有一个#，后面不能有任何符号，它没有作用 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#123-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#123-预处理指令"
  },"22": {
    "doc": "预处理指令概念详解",
    "title": "1.231 宏",
    "content": "宏(Macros)，也叫做预处理变量，类似于内联函数。宏是用宏指令定义的标识符或参数化的标识符与词法元素串的关联。 . 宏的作用就是把其定义位置后的代码中的所有与该宏名相同的标识符(不管在什么位置)替换为其关联的词法元素串，这也称之为宏展开。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1231-%E5%AE%8F",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1231-宏"
  },"23": {
    "doc": "预处理指令概念详解",
    "title": "1.2311 宏的定义",
    "content": "宏根据定义分为两种: . | 对象类宏: 对象类宏不包含任何参数， 定义形式为#define 宏名 (可选 词法元素串)。 | 函数类宏: 对象类宏会包含参数（虽然可能为空）， 定义形式为#define 宏名(可选 (形参名1, 形参名2)) (可选 词法元素串)。 | . 要注意函数类宏的参数表要紧跟宏名，之间不能含有空白符，否则就会被当成对象类宏而出现定义问题。 . 带参数的宏定义形式中的，参数表内只需要填形参名，不同形参名之间必须要用逗号,分隔。 . 参数表内不需要填也不必填其类型，参数表内不能有默认实参。 . 每个参数名可以在词法元素串中可以出现0次到多次，并且名称可以按任意顺序出现。 . 带参数的宏定义形式中的，参数表内还可以用省略符形参。 . 和普通情况一样，省略符形参只能放在参数表最后一个位置，省略符形参与其他形参可以用逗号,分隔，也可以不用，效果一样。 . 宏名必须为标识符，且尽量使用大写的字母来命名。 形参名也必须为标识符。 . 如果一个宏在定义时没有词法元素串，则该宏的作用是将该文件中所有与其相同的标识符删除。 . 可以定义多个相同宏名的宏，但是宏不能重载，后面定义的宏会覆盖前面定义的同名宏，且预处理器会警告。(不带参数的宏和带参数的宏都适用)。 . // 定义了一个宏APPLE #define APPLE 8 /* 等价于 int var1 = 8;*/ int var1 = APPLE; // 定义了一个宏FUNC #define FUNC(x,y) x + y; /* 等价于 double dou = 3.5 + 8.48;*/ double dou = FUNC(3.5,8.48) int ins = 66; cout &lt;&lt; ins; // 正确：ins为int的变量，输出66. #define ins cout &lt;&lt; ins; // 错误：ins已被删除，不存在名为ins的变量 . 词法元素串 . 词法元素串是指由一个或多个词法元素(如关键字、变量、表达式或语句)组合而成的序列。 . 每个词法元素之间也必须有一个或多个空白符分隔，在词法元素串内的空白符和在最后一个词法元素之后的空白符不会被视为词法元素串的一部分。 . 无特殊说明时，词法元素串中的词法元素可以是任何词法元素。 . 词法元素串与宏名之间必须有一个或多个空白符分隔。 . 宏生效于定义时，宏的替换范围为所在文件内。是将其定义位置后的代码中的所有与该宏名相同的标识符(不管在什么位置)替换为其关联的词法元素串。 . 宏的词法元素串可以包含宏名，也就是可以包含其他宏的名称。该宏生效时会按照宏展开顺序原则依次进行宏展开。 . // 定义TYPE宏为int类型 #define TYPE int // VAR_DEF宏嵌套TYPE宏用于变量定义 #define VAR_DEF TYPE ins = 5; /* 宏展开顺序为: 1. 先展开VAR_DEF宏，为: TYPE ins = 5; 2. 再展开TYPE宏, 为: int ins = 5; */ VAR_DEF std::cout &lt;&lt; ins; // 输出5 . 宏名和形参名可以是任意的标识符，包括c++的关键字。 . // 更改int关键字的含义，将其当做long long类型使用。 #define int long long std::cout &lt;&lt; sizeof(int); // int现在为8字节的long long，所以输出8 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12311-%E5%AE%8F%E7%9A%84%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12311-宏的定义"
  },"24": {
    "doc": "预处理指令概念详解",
    "title": "1.2312 宏调用",
    "content": "要注意，宏不是对象不是实体，宏只是预处理器在预处理阶段进行的批量替换，也就叫做宏展开。 . 宏调用(macro invocation)时，要将宏看作为该宏关联的词法元素串代码。每使用一次宏名，==就是在使用的位置上写一遍该宏关联的词法元素串代码==。 . // 使用宏DEF_INT时\\ 等价于int ins = 15; #define DEF_INT int ins = 15; DEF_INT cout &lt;&lt; ins; // 输出15 . 对于使用带参数的宏时，要类似于函数调用的形式： . 宏名(实参1, 实参2) . // 定义参数宏FUNC #define FUNC(x,y) x + y; int ins = 66; double dou = 15.14; // 等价于\\ cout &lt;&lt; ins + dou;\\ 输出为81.14。 cout &lt;&lt; FUNC(ins,dou) . 宏调用中的实参标识符可以是空(也就是不填任何符号)，也可以是任何词法元素(比如说对象，其他的宏，甚至可以是该宏本身，所以宏可以嵌套使用)，该词法元素还可以是不存在于当前文件中的。 . 要注意非字符串的实参标识符中不能直接含有逗号,，必须要用( ) ‘ “几个标点符号将逗号,包围起来。 另外如果非字符串的实参标识符内要用( ) “ ‘这几个标点符号，则必须成对出现。 . 不同实参之间必须要用逗号,分隔。 每个实参之前或之后的空白符不会被当作实参标识符的一部分，会被忽略。 非可变参数宏的实参数目必须与该宏的形参数目一致。 . // 定义一个加法功能的宏 #define ADD(a,b) a + b // 宏调用合法，但由于不能只用\\ 逗号符(,)，所以出错。 cout &lt;&lt; ADD(ADD(25,25),ADD(,)); // 正确：输出为70 cout &lt;&lt; ADD(ADD(20,25),ADD(15,10)); // 定义一个无功能的宏 #define NO_USE(a,b) a;b; // 宏调用合法，不出错 NO_USE(\"a_noUse\", #b_noUse) // 宏调用合法，不出错 NO_USE(,) // 宏调用不合法，实参数目不匹配，有3个 NO_USE(,18,15) // 宏调用不合法，语法错误 NO_USE(a_n(oUse,1815) // 宏调用合法，不出错 NO_USE(a_n(o,Us)e,b_n'o,Us'e) . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12312-%E5%AE%8F%E8%B0%83%E7%94%A8",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12312-宏调用"
  },"25": {
    "doc": "预处理指令概念详解",
    "title": "1.2313 宏展开流程",
    "content": "在C99标准中，规定了符合标准的C预处理器的宏展开(Macro replacement)流程(c99_6.10.3)，该流程基本如下： . | 对于源码来说，预处理器以从左到右，从上到下的顺序，逐个扫描每个词法元素，并进行以下操作: . | 对于每个#define/#undef行，将对应的宏的标识符从已定义宏集合def_m加入/移除，并将函数类宏从已定义函数类宏集合def_fm加入/移除。 | 对于其他的行，确认该词法元素（非字符/字符串字面值）是否为宏并决定后续相应的宏替换。当词法元素为集合def_m中时，它都会被替换为对应的词法元素串，该串可以为空。对于声明为函数类宏的宏名标识符，仅当紧跟其后的符号为宏调用实参表的左括号时，才会对该宏名标识符进行替换(以与其匹配的右括号为终止，忽略中间所匹配的括号对)。此时还会进行宏调用合法检测，如果调用语法不合法，则会报错。 | . | 检测到宏后，进行此宏的宏替换。宏替换流程如下: . | 参数替换(argument substitution): 对于函数类宏来说，预处理器找到该宏对应的词法元素串，从左到右，逐个对词法串中存在的所有形参（包括__VA_ARGS__），用对应的实参进行替换，并对替换后的参数（除了被字符串化运算符(#)以及词法元素粘贴运算符(##)所运算的以外）进行宏展开操作，直至所有参数已经完成宏展开操作。 | 宏运算符处理(# and ## preprocessing): 然后，预处理器找到该宏对应的词法元素串（对于函数类宏来说就是上一步处理完毕的词法串），从左到右，对该词法元素串存在的字符串化运算符(#)以及词法元素粘贴运算符(##)，进行相应的预处理（也就是相关的词法元素都被替换为对应的运算形式）。 | 重扫替换(rescanning and further replacement): 在已替换宏集合rep_m中加入该宏，标记是否已被替换(replaced macro tracking)，防止递归替换同一个宏。 接着，预处理器根据上一步处理完毕的词法串，从左到右，对该词法元素串中的每个词法元素进行扫描，并进行以下操作，直至所有词法元素都已进行了该操作。最后，在源码该宏处的位置，用操作完毕后的词法元素串替换该宏的标识符，此时宏替换流程完毕，并清空集合rep_m: . | 检测该词法元素是否为宏: 如果是，则进行下一步；否则该词法元素操作结束，进行下一个词法元素的操作。 | 检测宏是否已被替换: 在已替换宏集合rep_m中搜索是否存在该词法元素对应的宏：如果存在，则该宏不进行任何替换(painted blue)；否则对该宏进行宏展开操作，完毕后该词法元素操作结束，进行下一个词法元素的操作。 | . | . | . 要注意宏展开后的词法元素串不会被作为预处理指令(就算形式一样)，因此无法用宏来动态生成预处理指令。 . #include &lt;iostream&gt; // 定义了一个普通宏 #define NUMBER_MACRO_M1 66 // 定义了一个字符串化参数宏，参数不进行宏展开 #define STRINGIZE(x) #x // 定义了一个字符串化参数宏，参数进行宏展开 #define STRINGIZE_VALUE_OF(x) STRINGIZE(x) // 定义了一个词法元素粘贴参数宏，参数不进行宏展开 #define CONT(a, b) a ## b // 定义了一个词法元素粘贴参数宏，参数进行宏展开 #define CONT_VALUE_OF(a, b) CONT(a,b) // 定义了一个加法参数宏，参数进行宏展开 #define ADD(a, b) a + b // 定义了一个普通宏，该宏包含另一个宏 #define IDENTIFIER_MACRO_M1 NUMBER_MACRO_ // 定义了一个普通宏，该宏包含另一个宏 #define IDENTIFIER_MACRO_M2 M1 // 定义了一个普通宏 #define IDENTIFIER_MACRO_M1IDENTIFIER_MACRO_M2 -1 // 定义了一个普通宏 #define NUMBER_MACRO_ 8 // 定义了一个普通宏 #define M1 7 // 定义了一个比较参数宏，参数进行宏展开 #define _MAX(x, y) (((x) &gt; (y)) ? (x) : (y)) // 定义了一个普通宏，该宏包含另一个宏 #define MAX1 _MAX(1, // 定义了一个普通宏，该宏包含另一个宏 #define MAX2 _MAX(2,0)) // 定义了一个普通宏，该宏包含另一个宏 #define MAX21 _MAX(2,0) // 定义了一个普通宏，该宏包含另一个宏 #define RIGHT _MAX(1,_MAX(2,0)) // 定义了一个普通宏，该宏包含另一个宏 #define WRONG MAX1 MAX2 // 定义了一个普通宏，该宏包含另一个宏 #define WRONG2 MAX1 MAX21) // 定义了一个普通宏，该宏包含另一个宏，参数不进行宏展开 #define CON_MACRO NUMBER_MACRO_ ## M1 int main() { /** * 以下为展开演变: * $ 20 + 25 * * 输出为: * 45 */ std::cout &lt;&lt; ADD(20,25) &lt;&lt; std::endl; /** * 以下为展开演变: * $ (NUMBER_MACRO_ ## M1) * $ NUMBER_MACRO_M1 * $ 66 * * 输出为: * 66 */ std::cout &lt;&lt; CON_MACRO &lt;&lt; std::endl; /** * 以下为展开演变: * $ #(ADD(20,25)) * $ \"ADD(20,25)\" * * 输出为: * ADD(20,25) */ std::cout &lt;&lt; STRINGIZE(ADD(20,25)) &lt;&lt; std::endl; /** * 以下为展开演变: * $ STRINGIZE(ADD(20,25)) * $ STRINGIZE(20 + 25) * $ #(20 + 25) * $ \"20 + 25\" * * 输出为: * 20 + 25 */ std::cout &lt;&lt; STRINGIZE_VALUE_OF(ADD(20,25)) &lt;&lt; std::endl; /** * 以下为展开演变: * $ CONT(NUMBER_MACRO_, M1) + 25 * $ (NUMBER_MACRO_ ## M1) + 25 * $ NUMBER_MACRO_M1 + 25 * $ 66 + 25 * * 输出为: * 91 */ std::cout &lt;&lt; ADD(CONT(NUMBER_MACRO_, M1), 25) &lt;&lt; std::endl; /** * 以下为展开演变: * $ CONT_VALUE_OF(NUMBER_MACRO_, M1) + 25 * $ CONT(NUMBER_MACRO_,M1) + 25 * $ CONT(8,7) + 25 * $ (8 ## 7) + 25 * $ 87 + 25 * * 输出为: * 112 */ std::cout &lt;&lt; ADD(CONT_VALUE_OF(NUMBER_MACRO_, M1), 25) &lt;&lt; std::endl; /** * 以下为展开演变: * $ CONT(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2) + 25 * $ (IDENTIFIER_MACRO_M1 ## IDENTIFIER_MACRO_M2) + 25 * $ IDENTIFIER_MACRO_M1IDENTIFIER_MACRO_M2 + 25 * $ -1 + 25 * * 输出为: * 24 */ std::cout &lt;&lt; ADD(CONT(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2), 25) &lt;&lt; std::endl; /** * 以下为展开演变: * $ CONT_VALUE_OF(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2) + 25 * $ CONT(IDENTIFIER_MACRO_M1,IDENTIFIER_MACRO_M2) + 25 * $ CONT(NUMBER_MACRO_,M1) + 25 * $ (NUMBER_MACRO_ ## M1) + 25 * $ NUMBER_MACRO_M1 + 25 * $ 66 + 25 * * 输出为: * 112 */ std::cout &lt;&lt; ADD(CONT_VALUE_OF(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2), 25) &lt;&lt; std::endl; /** * 以下为展开演变: * $ #(CONT(NUMBER_MACRO_, M1)) * $ \"CONT(NUMBER_MACRO_, M1)\" * * 输出为: * CONT(NUMBER_MACRO_, M1) */ std::cout &lt;&lt; STRINGIZE(CONT(NUMBER_MACRO_, M1)) &lt;&lt; std::endl; /** * 以下为展开演变: * $ #(CONT_VALUE_OF(NUMBER_MACRO_, M1)) * $ \"CONT_VALUE_OF(NUMBER_MACRO_, M1)\" * * 输出为: * CONT_VALUE_OF(NUMBER_MACRO_, M1) */ std::cout &lt;&lt; STRINGIZE(CONT_VALUE_OF(NUMBER_MACRO_, M1)) &lt;&lt; std::endl; /** * 以下为展开演变: * $ #(CONT(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2)) * $ \"CONT(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2)\" * * 输出为: * CONT(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2) */ std::cout &lt;&lt; STRINGIZE(CONT(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2)) &lt;&lt; std::endl; /** * 以下为展开演变: * $ #(CONT_VALUE_OF(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2)) * $ \"CONT_VALUE_OF(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2)\" * * 输出为: * CONT_VALUE_OF(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2) */ std::cout &lt;&lt; STRINGIZE(CONT_VALUE_OF(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2)) &lt;&lt; std::endl; /** * 以下为展开演变: * $ STRINGIZE(CONT(NUMBER_MACRO_, M1)) * $ STRINGIZE((NUMBER_MACRO_ ## M1)) * $ STRINGIZE(NUMBER_MACRO_M1) * $ STRINGIZE(66) * $ #(66) * $ \"66\" * * 输出为: * 66 */ std::cout &lt;&lt; STRINGIZE_VALUE_OF(CONT(NUMBER_MACRO_, M1)) &lt;&lt; std::endl; /** * 以下为展开演变: * $ STRINGIZE(CONT_VALUE_OF(NUMBER_MACRO_, M1)) * $ STRINGIZE(CONT(NUMBER_MACRO_, M1)) * $ STRINGIZE(CONT(8, 7)) * $ STRINGIZE((8 ## 7)) * $ STRINGIZE(87) * $ #(87) * $ \"87\" * * 输出为: * 87 */ std::cout &lt;&lt; STRINGIZE_VALUE_OF(CONT_VALUE_OF(NUMBER_MACRO_, M1)) &lt;&lt; std::endl; /** * 以下为展开演变: * $ STRINGIZE(CONT(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2)) * $ STRINGIZE((IDENTIFIER_MACRO_M1 ## IDENTIFIER_MACRO_M2)) * $ STRINGIZE(IDENTIFIER_MACRO_M1IDENTIFIER_MACRO_M2) * $ STRINGIZE(-1) * $ #(-1) * $ \"-1\" * * 输出为: * -1 */ std::cout &lt;&lt; STRINGIZE_VALUE_OF(CONT(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2)) &lt;&lt; std::endl; /** * 以下为展开演变: * $ STRINGIZE(CONT_VALUE_OF(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2)) * $ STRINGIZE(CONT(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2)) * $ STRINGIZE(CONT(NUMBER_MACRO_, M1)) * $ STRINGIZE(CONT(8, 7)) * $ STRINGIZE((8 ## 7)) * $ STRINGIZE(87) * $ #(87) * $ \"87\" * * 输出为: * 87 */ std::cout &lt;&lt; STRINGIZE_VALUE_OF(CONT_VALUE_OF(IDENTIFIER_MACRO_M1, IDENTIFIER_MACRO_M2)) &lt;&lt; std::endl; /** * 以下为展开演变: * $ ADD(20,25) + ADD(15,10) * $ 20 + 25 + ADD(15,10) * $ 20 + 25 + 15 + 10 * * 输出为: * 70 */ std::cout &lt;&lt; ADD(ADD(20,25),ADD(15,10)) &lt;&lt; std::endl; /** * 以下为展开演变: * $ _MAX(1,_MAX(2,0)) * $ (((1) &gt; (_MAX(2,0))) ? (1) : (_MAX(2,0))) * $ (((1) &gt; ((((2) &gt; (0)) ? (2) : (0)))) ? (1) : (_MAX(2,0))) * $ (((1) &gt; ((((2) &gt; (0)) ? (2) : (0)))) ? (1) : ((((2) &gt; (0)) ? (2) : (0)))) * * 输出为: * 2 */ std::cout &lt;&lt; RIGHT &lt;&lt; std::endl; /** * 以下为展开演变: * $ MAX1 MAX21) * $ _MAX(1, MAX21) * $ (((1) &gt; (MAX21)) ? (1) : (MAX21)) * $ (((1) &gt; (_MAX(2,0))) ? (1) : (_MAX(2,0))) * $ (((1) &gt; ((((2) &gt; (0)) ? (2) : (0)))) ? (1) : (_MAX(2,0))) * $ (((1) &gt; ((((2) &gt; (0)) ? (2) : (0)))) ? (1) : ((((2) &gt; (0)) ? (2) : (0)))) * * 输出为: * 2 */ std::cout &lt;&lt; WRONG2 &lt;&lt; std::endl; /** * 以下为展开演变: * $ MAX1 MAX2 * $ _MAX(1, MAX2 * $ error occurred! * * 编译错误：因为按照展开顺序原则，MAX1先被展开，展开后为_MAX参数宏，当想展开_MAX参数宏时因为格式不正确导致出错。 */ std::cout &lt;&lt; WRONG &lt;&lt; std::endl; return 0; } . 根据宏展开流程可以看出，预处理器进行宏展开的操作只有当某词法元素串当前为宏时才进行展开，而对于要靠另一些宏展开后才会变成宏的词法元素串来说，预处理器并不会自动识别。需要利用宏展开流程特性，让该词法元素串变成宏后再次进行宏展开： . // 用于使x进行一次宏展开 #define EXPAND_1(x) x // 空宏 #define M_EMPTY // 括号宏 #define M_PARANTHESIS() () // 包装了括号宏的宏，需要宏展开2次才会变为() #define M_WRAP_PARANTHESIS M_PARANTHESIS M_EMPTY () // 定义int_var变量 #define DEF_INT_VAR() int int_var = 34; #define M_WRAP_DEF_INT_VAR() DEF_INT_VAR M_EMPTY () #define M_WRAP2_DEF_INT_VAR M_WRAP_DEF_INT_VAR M_EMPTY () /** * 以下为展开演变: * $ DEF_INT_VAR () */ DEF_INT_VAR M_EMPTY () /** * 以下为展开演变: * $ DEF_INT_VAR M_EMPTY () * $ DEF_INT_VAR () * $ int int_var = 34; */ EXPAND_1(DEF_INT_VAR M_EMPTY ()) /** * 以下为展开演变: * $ DEF_INT_VAR M_EMPTY M_WRAP_PARANTHESIS * $ DEF_INT_VAR M_WRAP_PARANTHESIS * $ DEF_INT_VAR M_PARANTHESIS M_EMPTY () * $ DEF_INT_VAR M_PARANTHESIS () * $ DEF_INT_VAR () */ EXPAND_1(DEF_INT_VAR M_EMPTY M_WRAP_PARANTHESIS) /** * 以下为展开演变: * $ EXPAND_1(DEF_INT_VAR M_EMPTY M_WRAP_PARANTHESIS) * $ DEF_INT_VAR M_EMPTY M_WRAP_PARANTHESIS * $ DEF_INT_VAR M_WRAP_PARANTHESIS * $ DEF_INT_VAR M_PARANTHESIS M_EMPTY () * $ DEF_INT_VAR M_PARANTHESIS () * $ DEF_INT_VAR () * $ int int_var = 34; */ EXPAND_1(EXPAND_1(DEF_INT_VAR M_EMPTY M_WRAP_PARANTHESIS)) // 最终展开为 // DEF_INT_VAR () M_WRAP_DEF_INT_VAR() // 最终展开为 // int int_var = 34; EXPAND_1(M_WRAP_DEF_INT_VAR()) // 最终展开为 // M_WRAP_DEF_INT_VAR () M_WRAP2_DEF_INT_VAR // 最终展开为 // DEF_INT_VAR () EXPAND_1(M_WRAP2_DEF_INT_VAR) // 最终展开为 // int int_var = 34; EXPAND_1(EXPAND_1(M_WRAP2_DEF_INT_VAR)) . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12313-%E5%AE%8F%E5%B1%95%E5%BC%80%E6%B5%81%E7%A8%8B",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12313-宏展开流程"
  },"26": {
    "doc": "预处理指令概念详解",
    "title": "1.2314 可变参数宏的使用",
    "content": "当调用一个含有省略符形参的宏时，也就是调用了一个可变参数宏，当调用可变参数宏时，实参的数目必须要大于等于减去了省略符形参的形参数目。多余的实参都传递给了省略符形参。 . 有一个系统定义的宏，名为__VA_ARGS__。这个宏只能用于含有省略符形参的宏定义的词法元素串中(用于其他类型的宏和其他位置时会出错)。 使用该宏的位置会被替换成传给省略符形参的所有实参标识符(包括这些实参之间的逗号)，所以可以用该宏来定义可变参数宏。 . 有一些编译器会规定必须至少将一个参数传递给省略符形参，以确保宏不会解析为带有尾随逗号的表达式。如果没有参数传递给省略号，该编译则会出错。 . 有一些编译器提供了一个扩展(如gcc编译器提供编译参数std=gnucxxx)，允许##出现在逗号之后和__VA_ARGS__之前。在这种情况下，##在变量参数存在时不执行任何操作，但在变量参数不存在时删除逗号：这使得定义像fprintf (stderr， format， ##__VA_ARGS__)等宏成为可能。但这也可以使用宏__VA_OPT__以c++标准方式实现(c++20以后)。 . // variadic_macros.cpp #include &lt;stdio.h&gt; #define EMPTY #define CHECK1(x, ...) if (!(x)) { printf(__VA_ARGS__); } #define CHECK2(x, ...) if ((x)) { printf(__VA_ARGS__); } #define CHECK3(...) { printf(__VA_ARGS__); } #define MACRO(s, ...) printf(s, __VA_ARGS__) int main() { // 输出here are some varargs1(1) CHECK1(0, \"here %s %s %s\", \"are\", \"some\", \"varargs1(1)\\n\"); CHECK1(1, \"here %s %s %s\", \"are\", \"some\", \"varargs1(2)\\n\"); // won't print CHECK2(0, \"here %s %s %s\", \"are\", \"some\", \"varargs2(3)\\n\"); // won't print // 输出here are some varargs2(4) CHECK2(1, \"here %s %s %s\", \"are\", \"some\", \"varargs2(4)\\n\"); // always invokes printf in the macro // 输出here are some varargs3(5) CHECK3(\"here %s %s %s\", \"are\", \"some\", \"varargs3(5)\\n\"); // 输出hello, world MACRO(\"hello, world\\n\"); // 错误：输出error MACRO(\"error\\n\", EMPTY); // would cause error C2059, except VC++ // suppresses the trailing comma } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12314-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12314-可变参数宏的使用"
  },"27": {
    "doc": "预处理指令概念详解",
    "title": "1.2315 #undef指令",
    "content": "#undef指令移除(也就是取消定义)本文件内在该指令之前存在的，宏名为给定标识符的所有宏。 使用形式为： . #undef 标识符 . #undef指令只对是宏的标识符起作用，如果给定的标识符不是宏或者根本不存在该标识符的词法元素，那么该指令不起作用(也就是无影响) . 如果给定标识符的宏有多个，则移除对应的所有宏 . int ins = 66; cout &lt;&lt; ins; // 正确：ins为int的变量，输出66。 #define ins cout &lt;&lt; ins; // 错误：ins已被删除，不存在名为ins的变量。 #undef ins cout &lt;&lt; ins; // 正确：宏ins已被移除，所以ins又恢复为int的变量，输出66。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12315-undef%E6%8C%87%E4%BB%A4",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12315-undef指令"
  },"28": {
    "doc": "预处理指令概念详解",
    "title": "1.2316 宏相关的运算符",
    "content": "对于宏，我们有两种运算符来处理其关联的词法元素串，使其满足我们的一些要求： . | 字符串化运算符(Stringizing operator) | 词法元素粘贴运算符(Token-pasting operator) | . 这两种运算符只用于宏定义，不能用于其他操作 . 字符串化运算符(#) . 字符串化运算符只能用于带参数的宏。是将宏参数转换为字符串字面值的运算符。 . 字符串化运算符只有一个运算对象，且该运算对象在其右侧，该运算对象只能是宏定义中词法元素串内的形参标识符 . 字符串化运算符返回一个运算对象对应的实参标识符的字符串字面值版本 . 字符串化运算符只作用于宏定义中词法元素串内的形参标识符，使用形式为： . #形参标识符 . #和形参标识符之间不能有空白符 . 字符串化运算符和普通参数宏调用过程差不多。 在宏调用过程时，对于非#开头的形参标识符，预处理器将该形参标识符替换成实参表里对应的标识符；对于#开头的形参标识符，预处理器会用对应实参标识符的字符串字面值版本来进行替换。最后再进行宏展开。 . 如果需要字符串化的实参标识符所包含的字符在转化时需要转义序列(例如，引号\"或反斜杠\\字符)，则预处理器会自动插入必要的转义反斜杠。 . #include &lt;stdio.h&gt; // 定义输出功能的宏 #define stringer(x) printf_s( #x \"\\n\" ) int main() { // 等价于printf_s( \"In quotes in the printf function call\" \"\\n\" ); // 输出为In quotes in the printf function call stringer( In quotes in the printf function call ); // 等价于printf_s( \"\\\"In quotes when printed to the screen\\\"\" \"\\n\" ); // 输出为\"In quotes when printed to the screen\" stringer(\"In quotes when printed to the screen\"); // 等价于printf_s( \"\\\"This: \\\\\\\" prints an escaped double quote\\\"\" \"\\n\" ); // 输出为\"This: \\\" prints an escaped double quote\" stringer( \"This: \\\" prints an escaped double quote\" ); return 0; } . 词法元素粘贴运算符(##) . 词法元素粘贴运算符，有时称为合并运算符或组合运算符。该运算符可用于两种形式的宏。 . 词法元素粘贴运算符的作用就是连接两个词法元素，使其成为一个词法元素。 . 词法元素粘贴运算符有两个运算对象，分别在在其左右侧，该运算对象可以是宏定义中词法元素串内的任何词法元素(包括形参标识符) . 词法元素粘贴运算符返回一个其两个运算对象合并后的词法元素。该词法元素的前缀为运算符左侧运算对象，后缀为运算符右侧运算对象。 . 词法元素粘贴运算符的使用形式为： . 词法元素1 ## 词法元素2 . 词法元素粘贴运算符与其运算对象之间可以有多个空白符 . 当词法元素粘贴运算符的某运算对象为形参标识符时，宏调用时和其他参数宏调用类似，不同之处就是把对应实参标识符和另一个运算对象组合成了一个新的词法元素。 . 合并后的词法元素如果不满足成为标识符的条件，则不能作为标识符使用(可以作为字符串字面值使用)。 . // 定义了DEF_INT宏\\ 等价于int int_num = 15; #define DEF_INT int int ## _num = 15; DEF_INT cout &lt;&lt; _num; // 错误：未定义_num cout &lt;&lt; int_num; // 正确：输出15 // 错误定义，因为int?不是标识符，不能用于定义变量 #define DEF_INT int int? ## _num = 15; . // 等价于int No_id = id; #define DEF_INT(id) int No_ ## id = id; DEF_INT(26) cout &lt;&lt; No_id; // 错误：未定义No_id\\ id是形参名，要写成具体的实参名，比如No_26。 cout &lt;&lt; No_26; // 正确：输出26 . // 换句话说，扩展hash_hash会产生一个新的符号，由两个相邻的#符号组成，但此新词法元素不是##运算符。 #define hash_hash # ## # #define mkstr(a) # a #define in_between(a) mkstr(a) #define join(c, d) in_between(c hash_hash d) // 等价于 // char p[] = \"x ## y\"; /* 宏展开的演变为: join(x, y) in_between(x hash_hash y) in_between(x ## y) mkstr(x ## y) \"x ## y\" */ char p[] = join(x, y); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12316-%E5%AE%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12316-宏相关的运算符"
  },"29": {
    "doc": "预处理指令概念详解",
    "title": "1.232 条件编译",
    "content": "条件编译类的预处理指令是用来控制源文件部分的编译。 条件编译类的预处理指令有六个，分别为： . | #if | #elif | #else | #endif | #ifdef | #ifndef | . 这几个指令的作用和条件控制语句类似，用法也是类似 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1232-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1232-条件编译"
  },"30": {
    "doc": "预处理指令概念详解",
    "title": "#if #elif #else #endif的介绍",
    "content": "和条件控制语句类似，#if和#elif后面也是跟着判断条件的。 . 和条件控制语句不一样的是这两个指令的条件判断不需要括号，且判断条件必须为常量表达式。 而且除此之外，这两个指令还有一种条件判断形式。 使用形式为： . #if 常量表达式/defined (宏名)/宏名 各种代码 (可选 #elif 常量表达式/defined (宏名)/宏名 各种代码) (可选 #else 常量表达式/defined (宏名)/宏名 各种代码) #endif . 第二种条件判断形式中，宏名必须为标识符。宏名可以加括号或者不加 . 这两种判断条件都可以用宏，只要其宏满足对应的条件就行。 . 和条件控制语句一样，一组匹配的条件编译指令，有且只有一个#if，在最前面；有且只有一个#endif，在最后面；中间可以有多个#elif；可以有一个#else，且必须是#endif的上一个指令。 如果存在不匹配的条件编译指令，则会出错。 . 和条件控制语句一样，#if，#ifdef，#ifndef，#elif和#else指令的作用范围为从使用位置后到遇到的第一个与其匹配的其他条件编译指令为止。 . 和条件控制语句一样，每个#else、#elif或#endif指令与上一个离其最近的#if或#ifdef或#ifndef指令匹配。 . 和条件控制语句一样，条件编译指令可以嵌套，注意匹配规则就行 . 第一种形式中，如果给定的常量表达式所转换的布尔值为false，则预处理器就会忽略掉对应指令作用范围内的所有代码；如果为true就会忽略与其匹配的其他条件编译指令作用范围内的所有代码。 . 第二种形式中，如果对应指令之前存在给定的宏名的宏，那么就视为true，否则为false。之后的操作和第一种形式的一样。 . // 一组匹配的条件编译指令，\\ 该条件编译指令表示只编译\\ cout &lt;&lt; \"elif 2\\n\";\\ 最后程序输出elif 2。 #define DEF_ELIF3 const int elif1_val = 0; const int elif2_val = 0; #if defined (DEF_IF) cout &lt;&lt; \"if\\n\"; #elif elif1_val cout &lt;&lt; \"elif 1\\n\"; #elif elif2_val cout &lt;&lt; \"elif 2\\n\"; #elif defined DEF_ELIF3 cout &lt;&lt; \"elif 2\\n\"; #else cout &lt;&lt; \"else\\n\"; #endif . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#if-elif-else-endif%E7%9A%84%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#if-elif-else-endif的介绍"
  },"31": {
    "doc": "预处理指令概念详解",
    "title": "#ifdef #ifndef 的介绍",
    "content": "#ifdef和#ifndef的作用效果与 . #if defined (宏名)/宏名 #if !defined (宏名)/宏名 . 一样。 . 使用形式为 . #ifdef 宏名 #ifndef 宏名 . 其他特性和属性和#if一样，可以参考上面#if的介绍。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#ifdef-ifndef-%E7%9A%84%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#ifdef-ifndef-的介绍"
  },"32": {
    "doc": "预处理指令概念详解",
    "title": "1.233 阻止编译",
    "content": "阻止编译是指#error指令，该指令会在编译时发出用户指定的错误消息，然后终止编译。 . 使用形式为： . #error 词法元素串 . #error指令发出的错误消息也就是使用时的所写的词法元素串。 . #if !defined(__cplusplus) #error C++ compiler required. #endif . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1233-%E9%98%BB%E6%AD%A2%E7%BC%96%E8%AF%91",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1233-阻止编译"
  },"33": {
    "doc": "预处理指令概念详解",
    "title": "1.234 文件包含指令",
    "content": "文件包含类预处理指令是将其他文件包含到所使用该指令的文件中。 . 其中C标准中的包含指令为#include指令。 部分编译器(如msvc)增加了一些指令，增加的指令如下： . | #import指令 | #using指令 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1234-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%8C%87%E4%BB%A4",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1234-文件包含指令"
  },"34": {
    "doc": "预处理指令概念详解",
    "title": "1.2341 #include指令",
    "content": "#include指令是通知预处理器将指定文件的内容包含在指令出现的位置的指令。 . 每次使用#include指令时，预处理器会自动展开包含文件的代码到该使用位置。 . #include指令的使用形式有两种： . #include \"指定路径\" #include &lt;指定路径&gt; . 指定路径可以是一个文件名，也可以是文件的相对或绝对路径。指定路径的语法取决于编译程序的操作系统。 . 包含文件内可以包含宏和其他代码，但是要注意对象和类型重复定义的问题 . 父文件是#include指令所给的文件。 #include指令可以嵌套，可以出现在由#include指令的包含文件内 . #include指令两种使用形式的差别主要在于预处理器搜索文件路径的顺序。 . | 语法形式 | 搜索操作 | . | 带引号的形式 | 预处理器按以下顺序搜索包含文件： 1. 指定的路径所在的目录中 2. 当前文件之前的已展开的包含文件的目录中，以其打开的相反顺序排列搜索。从父包含文件的目录中开始进行，然后继续向上到任何祖父包含文件的目录。 3. 沿着每个编译器选项中指定的路径/I 。 4. 沿环境变量指定的路径。 | . | 尖括号的形式 | 预处理器按以下顺序搜索包含文件: 1. 沿着每个编译器选项中指定的路径/I 。 2. 沿环境变量指定的路径。 | . 只要找到具有给定名称的文件，预处理器就会停止搜索。如果指定路径是以双引号(““)括起来的绝对路径，则预处理器只搜索该指定路径并忽略搜索规则。 . #include通常使用头文件保护宏或#pragma once来防止头文件双重包含。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12341-include%E6%8C%87%E4%BB%A4",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12341-include指令"
  },"35": {
    "doc": "预处理指令概念详解",
    "title": "1.2342 #import指令(编译器扩展 msvc)",
    "content": "#import指令是c++特有的指令，是用于合并类型库的信息，该类型库的内容将会被转换成c++类，大多数用于描述COM的接口。 . 使用形式也是两种： . #import \"文件名\" [文件属性] #import &lt;文件名&gt; [文件属性] . 文件名可以是以下类型之一： . | 包含该类型库的文件的名称，如.olb、.tlb或.dll文件。 每个文件名之前可以使用关键字file: | 类型库中控件的progid。在64位操作系统上使用32位交叉编译器时，编译器只能读取32位注册表配置单元。您可能需要使用本机64位编译器才能生成和注册64位类型库。 每个控件的progid之前可以使用关键字progid: | 类型库的库ID。如果未指定version或lcid，则应用于的规则progid:也应用于libid:。 每个库ID之前可以使用关键字libid: | 可执行 (.exe) 文件。 | 库(.dll)文件包含类型库资源(如.ocx) | 包含类型库的复合文档。 | 可由 LoadTypeLib API 理解的任何其他文件格式。 | . #import \"progid:my.prog.id.1.5\" . #import \"..\\drawctl\\drawctl.tlb\" no_namespace raw_interfaces_only . 文件属性可以是一个或多个#import特性，用空格或逗号分隔每个特性。 . #import \"..\\drawctl\\drawctl.tlb\" no_namespace, raw_interfaces_only #import \"..\\drawctl\\drawctl.tlb\" no_namespace raw_interfaces_only . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12342-import%E6%8C%87%E4%BB%A4%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95-msvc",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12342-import指令编译器扩展-msvc"
  },"36": {
    "doc": "预处理指令概念详解",
    "title": "1.2343 #using指令(编译器扩展 msvc)",
    "content": "#using指令是将元数据导入使用公共语言运行编译的程序中。 . 使用形式： . #using 文件 [as_friend] . 文件要是.dll、.exe、.netmodule或.obj后缀的文件。 as_friend是指定该文件中的所有类型为可访问的。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12343-using%E6%8C%87%E4%BB%A4%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95-msvc",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12343-using指令编译器扩展-msvc"
  },"37": {
    "doc": "预处理指令概念详解",
    "title": "1.235 调试操作",
    "content": "有一些系统预先定义的宏和某些预处理指令可以帮助我们进行一些调试工作。 . 调试是在编译链接完成后的一种检查工作，是在程序运行时所进行的。 . 一种基本调试思想是：程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。 . 这种方法通常会用到以下这几种预处理宏和一个预处理指令： . | assert | __func__ | __FILE__ | __LINE__ | __TIME__ | __DATE__ | #line | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1235-%E8%B0%83%E8%AF%95%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1235-调试操作"
  },"38": {
    "doc": "预处理指令概念详解",
    "title": "1.2351 assert宏",
    "content": "assert宏定义在cassert头文件中。 assert宏需要传递一个表达式作为它的条件，使用形式为: . assert(表达式); . 如果表达式为假(即0)，assert输出信息并终止程序的执行。如果表达式为真(即非0)，assert什么也不做。 . assert宏常用于检查“不能发生”的条件。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时，程序可以包含一条如下所示的语句 . assert(word.size() &gt; threshold); . 默认状态下assert宏一直处于生效状态，但是我们可以进行设置来使assert宏不生效(也就是无论其表达式为什么，都不执行操作)。 . assert的生效状态依赖于一个标识符为NDEBUG的宏的状态。如果在定义assert宏之前存在NDEBUG宏，则assert不生效，什么也不做。 . // 错误操作，NDEBUG\\ 要在定义assert宏之前存在才行 #include &lt;cassert&gt; #define NDEBUG int main() { assert(0); return 0; } // 仍然终止程序的运行 . // 正确操作，NDEBUG\\ 在定义assert宏之前已经存在 #define NDEBUG #include &lt;cassert&gt; int main() { assert(0); return 0; } // assert宏什么也不做 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12351-assert%E5%AE%8F",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12351-assert宏"
  },"39": {
    "doc": "预处理指令概念详解",
    "title": "1.2352 输出错误信息的宏",
    "content": "有时我们希望在程序出错后能够输出一些有用的错误信息，方便我们去修改调试程序，所以我们需要一些宏来输出一些有用的错误信息，以下是一些用于输出有关错误信息的宏： . | __func__ | __FILE__ | __TIME__ | __DATE__ | __LINE__ | . __func__宏 . __func__宏主要用于输出当前调用点所在的函数的名称标识符，预处理器为每个函数都定义了一个__func__宏，该宏的词法元素串为一个静态字符串字面值(static const char)。 . 不能在函数外使用__func__，__func__输出的是离其调用点最里层的函数名。 . __FILE__宏 . __FILE__宏主要用于输出当前调用点所在的绝对路径文件名称(包含后缀)，该宏的词法元素串为一个静态字符串字面值(static const char)。 . __TIME__宏 . __TIME__宏主要用于输出当前调用点所在文件最后一次预处理完成的时间，该时间是hh:mm:ss格式。该宏的词法元素串为一个静态字符串字面值(static const char)。 . __DATE__宏 . __DATE__宏主要用于输出当前调用点所在文件最后一次编译完成的日期，该日期是Mmm dd yyyy格式。该宏的词法元素串为一个静态字符串字面值(static const char)。 . __LINE__宏 . __LINE__宏主要用于输出当前调用点所在的行号，该日期是Mmm dd yyyy格式。该宏的词法元素串为一个整数。 . #include &lt;iostream&gt; using namespace std; /* 输出为 the current function name is main the current filename is e:\\test.cpp the current time of compiling is 13:56:04 May 18 2021 the current line is 13 */ int main() { cout &lt;&lt; \"the current function name is\\n\" &lt;&lt; __func__; cout &lt;&lt; \"\\nthe current filename is\\n\" &lt;&lt; __FILE__; cout &lt;&lt; \"\\nthe current time of compiling is\\n\" &lt;&lt; __TIME__ &lt;&lt; \"\\n\" &lt;&lt; __DATE__; cout &lt;&lt; \"\\nthe current line is\\n\" &lt;&lt; __LINE__; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12352-%E8%BE%93%E5%87%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AE%8F",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12352-输出错误信息的宏"
  },"40": {
    "doc": "预处理指令概念详解",
    "title": "1.2353 #line指令",
    "content": "#line指令是作用于__LINE__和__FILE__这两个宏的预处理指令，该指令能修改这两个宏所存的信息。 . #line指令将其调用位置的下一行行号修改为指定的行号，之后的行号根据该修改的行号逐个增加。 . #line指令将当前的文件名修改为指定的文件名。 . #line指令的使用形式为： . #line 行号 (可选 文件名) . 行号可以是任何整数字面值，也可以是宏，只要该宏展开后是整数字面值就行。 . 文件名可以任意的字符串字面值，如果省略文件名，则前一个指定的文件名保持不变 . #line指令可以多次使用，后使用的#line指令覆盖前面的#line指令。 . #include &lt;iostream&gt; using namespace std; /* 输出为： the current filename is e:\\test.cpp the current line is 11 the current filename is e:\\test.cpp the current line is 55 the current filename is open.cpp the current line is 13 the current filename is open.cpp the current line is 31 */ int main() { cout &lt;&lt; \"\\nthe current filename is \" &lt;&lt; __FILE__; cout &lt;&lt; \"\\nthe current line is \" &lt;&lt; __LINE__; #line 50 ; ; ; ; cout &lt;&lt; \"\\nthe current filename is \" &lt;&lt; __FILE__; cout &lt;&lt; \"\\nthe current line is \" &lt;&lt; __LINE__; #line 10 \"open.cpp\" ; ; cout &lt;&lt; \"\\nthe current filename is \" &lt;&lt; __FILE__; cout &lt;&lt; \"\\nthe current line is \" &lt;&lt; __LINE__; #line 30 cout &lt;&lt; \"\\nthe current filename is \" &lt;&lt; __FILE__; cout &lt;&lt; \"\\nthe current line is \" &lt;&lt; __LINE__; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12353-line%E6%8C%87%E4%BB%A4",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#12353-line指令"
  },"41": {
    "doc": "预处理指令概念详解",
    "title": "1.236 杂注操作(编译器扩展 msvc)",
    "content": "杂注指令是用来指定计算机特定或操作系统特定的编译器功能的指令。 C和C++支持某些对其主机或操作系统的独特功能。例如，某些程序必须对内存中的数据位置进行精确控制，或控制某些函数接收参数的方式。杂注指令为每个编译器提供了一种提供计算机和操作系统特定功能的方法，同时保持与c和c++语言的总体兼容性。 . 杂注指令一般有两种形式： . #pragma 词法元素串 _Pragma (字符串字面值) . c++预处理器识别以下的pragma指令： . // 这些指令等价于在控制台上输入以下指令\\ cl /Zp8 some_file.cpp // some_file.cpp - packing is 8 // ... #pragma pack(push, 1) - packing is now 1 // ... #pragma pack(pop) - packing is 8 again // ... ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1236-%E6%9D%82%E6%B3%A8%E6%93%8D%E4%BD%9C%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95-msvc",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html#1236-杂注操作编译器扩展-msvc"
  },"42": {
    "doc": "预处理指令概念详解",
    "title": "预处理指令概念详解",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html",
    
    "relUrl": "/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html"
  },"43": {
    "doc": "第十章 模板",
    "title": "第十章 模板",
    "content": "第10章先介绍了模板的概念与通用用法，然后详细介绍了模板的实例化、特例化，最后再次对类和函数模板进行深入介绍。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/index.html",
    
    "relUrl": "/guide_files/chap10/index.html"
  },"44": {
    "doc": "模板概念详解",
    "title": "10.1 模板概念",
    "content": "模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。 模板本身不是类或函数，相反，可以将模板看作为编译器生成类或函数编写的一份说明。 . 编译器根据模板创建类或函数的过程称为实例化(instantiation),当使用模板时，需要指出编译器应把类或函数实例化成何种类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#101-%E6%A8%A1%E6%9D%BF%E6%A6%82%E5%BF%B5",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#101-模板概念"
  },"45": {
    "doc": "模板概念详解",
    "title": "10.2 模板分类",
    "content": "根据模板类型，C++的模板可以分为两种： . | 函数模板 | 类模板 | . 模板的声明和定义和普通的函数和类的声明和定义类似，要在其声明或定义之前加上关键字template和模板参数列表。 . 模板的声明和定义都不能在函数或函数模板内，但可以在类或类模板内。 . // 函数模板prints的声明 template&lt;int* ptr, class ty&gt; inline ty prints(int val = ptr); // 函数模板prints的定义 template&lt;int* ptr, class ty&gt; inline ty prints(int val) { cout &lt;&lt; val &lt;&lt; \"\\n\"; return ty(); } // 类模板Cls的声明 template&lt;typename ty, int int_par&gt; struct Cls; // 类模板Cls的定义 template&lt;typename ty, int int_par&gt; struct Cls { ty data_mem; void prints() { cout &lt;&lt; data_mem &lt;&lt; \" \" &lt;&lt; int_par &lt;&lt; \"\\n\"; } }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#102-%E6%A8%A1%E6%9D%BF%E5%88%86%E7%B1%BB",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#102-模板分类"
  },"46": {
    "doc": "模板概念详解",
    "title": "10.3 模板的声明与定义",
    "content": "模板也有声明和定义两种形式，形式为： . 模板的声明: . template 模板参数列表 函数或类的声明语句 . 模板的定义: . template 模板参数列表 函数或类的定义语句 . 模板参数列表(template parameter list)类似于函数形参表，是一个由逗号,分隔的一个或多个模板形参(template parameter)的列表，该列表用&lt;&gt;包围起来，且该形参表不能为空，必须至少有一个形参。 . 对于函数模板来说函数模板的类型限定符和存储说明符(如constexpr、inline和static等)是放在模板参数列表后，函数声明或定义语句前的。 . 和函数一样，模板的声明要与其定义严格一致，具体来说: . | 对于函数模板来说： 模板形参表要一致(也就是形参表中的形参数量，顺序和类型(可以忽略顶层const)都要相同)，函数首部也要一致(包括函数声明或定义前的类型限定符也要一致)。 | 对于类模板来说： 模板形参表要一致，类名也要相同。 | . 否则就变成了其他的模板声明，无意义了。 . 函数模板支持重载，只要该模板的模板形参表或者函数形参表不一致就行。 类模板不支持重载，所以类名相同但模板形参表不同的模板会导致重复定义；而且同作用域下的类模板名也不能与其他的类类型同名。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#103-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#103-模板的声明与定义"
  },"47": {
    "doc": "模板概念详解",
    "title": "10.4 模板参数",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#104-%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#104-模板参数"
  },"48": {
    "doc": "模板概念详解",
    "title": "10.41 模板形参",
    "content": "模板参数遵循普通的作用域规则，一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。 与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。 . 同一个模板形参表中，各个模板形参的名字不能相同。 函数模板中的函数形参和局部变量名或者类模板的成员名也不能与所属的模板形参表中的形参名相同。 . 和函数形参一样： . | 模板形参可以存在于模板定义中任何需要使用该形参的位置。 . #include &lt;vector&gt; // 函数模板 template&lt;typename T, uint64_t N&gt; T sumForList(const T (&amp;list)[N]) { // 使用了模板形参中的类型形参T作为类型 T sum = 0; // 使用了模板形参中的非类型形参N作为变量 for (uint64_t i = 0; i &lt; N; ++i) sum += list[i]; return sum; } // 类模板 template&lt;typename T, uint64_t N, template&lt;class Type&gt; typename Cls&gt; class Matrix { // 使用了模板形参中的模板类形参Cls、类型形参T和非类型形参N作为类型 Cls&lt;T&gt; list[N]; public: // 使用了模板形参中的模板类形参Cls、类型形参T和非类型形参N作为函数形参类型 explicit Matrix(const Cls&lt;T&gt; (&amp;matrix)[N]) { for (uint64_t i = 0; i &lt; N; ++i) list[i] = matrix[i]; } // 使用了模板形参中的模板类形参Cls、类型形参T作为初始化值类型 Matrix(): list({Cls&lt;T&gt;{}}) {} void print() { printMatrix(list); } // 使用了模板形参中的模板类形参Cls、类型形参T作为函数形参类型 static void printMatrix(const Cls&lt;T&gt; (&amp;matrix)[N]) { // 使用了模板形参中的模板类形参Cls、类型形参T作为变量类型 for (const Cls&lt;T&gt;&amp; list: matrix) { uint64_t len = list.size(); std::cout &lt;&lt; \"[\"; if (len &gt; 0) std::cout &lt;&lt; list[0]; for (uint64_t i = 1; i &lt; len; ++i) std::cout &lt;&lt; \", \" &lt;&lt; list[i]; std::cout &lt;&lt; \"]\" &lt;&lt; std::endl; } } }; int main() { int64_t arrs[] = {5,8,9,6,-11,0,6,3,25,-48}; // 输出3 std::cout &lt;&lt; sumForList(arrs) &lt;&lt; std::endl; std::vector&lt;int32_t&gt; matrix[] = {{2,5,0,-48},{-89,0,33,28},{-78,93,0,12}}; Matrix&lt;int32_t, 3, std::vector&gt; obj(matrix); /* 输出 [2, 5, 0, -48] [-89, 0, 33, 28] [-78, 93, 0, 12] */ obj.print(); return 0; } . | 模板声明中的模板形参名不必与定义中相同，甚至还可以省略。 | 如果我们不需要用某个模板形参，我们就可以在模板定义中省略该形参的名字。 | . 模板形参和函数形参不同，模板形参根据其类型不同，可以分为两种： . | 类型形参 | 非类型形参 | 模板类形参 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1041-%E6%A8%A1%E6%9D%BF%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1041-模板形参"
  },"49": {
    "doc": "模板概念详解",
    "title": "10.411 类型形参",
    "content": "类型形参在模板形参的声明形式为： . typename/class 类型形参名 . 关键字typename和class的含义相同，可以互换使用。 . 类型形参也就是表示类型的形参，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。 所以类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。 . 对于类型形参的实参来说，可以是任意可用的类型说明符(包括内置类型或者模板的实例)，类型说明符可以包括类型修饰符，但是不能有存储说明符和类型限定符等符号。 . // 含有两个类型形参的函数模板prints template&lt;typename ty, class ty2&gt; void prints(ty val, ty2 val2) { } . 类型形参的实参还可以结合一些符号形成一些特殊的形式（因为函数的首部可以看作为某种函数指针类型）： . /** * @brief 用于同调用形式不同实现的函数的比较声明，类似std::function * * @tparam CallableType */ template &lt;typename CallableType&gt; class FunctionDiff {}; // 定义正确，可以使用括号结合多个类型。 // 该形式源于functional头文件function的定义。 FunctionDiff&lt;int(int, int)&gt; g_obj; . #include &lt;iostream&gt; #include &lt;functional&gt; // 普通函数，首部为void () void prints() { std::cout &lt;&lt; \"normal callable\" &lt;&lt; std::endl; } // 函数指针，首部为void () auto g_func_ptr = prints; // 重载可调用运算符的对象，首部为void () class Function { public: int operator()() { std::cout &lt;&lt; \"override opearator call\" &lt;&lt; std::endl; return 0; } }; // lambda对象，首部为void () auto g_func = [] () -&gt; auto { std::cout &lt;&lt; \"lambda\" &lt;&lt; std::endl; return 3.6; }; // function对象，首部为void () std::function&lt;void ()&gt; g_ffunc = prints; /** * @brief 接收任何空形参表的可调用对象。 * @note 要注意Signature不能是非空形参表的可调用对象或者非可调用对象 * @tparam Signature * @param func */ template&lt;typename Signature&gt; void runVoidFunction(Signature func) // func的类型不能加任何的修饰词，限定词 { func(); } int main() { Function op_func; runVoidFunction(prints); runVoidFunction(g_func_ptr); runVoidFunction(op_func); runVoidFunction(g_func); runVoidFunction(g_ffunc); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10411-%E7%B1%BB%E5%9E%8B%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10411-类型形参"
  },"50": {
    "doc": "模板概念详解",
    "title": "10.412 非类型形参",
    "content": "非类型形参在模板形参的声明形式为： . 类型说明符(可含类型修饰符) 非类型形参名 . 非类型形参和函数形参一样，表示一个对象而非一个类型。 不过非类型形参中的类型说明符有很大的限制，c++11中非类型形参的类型不能用auto来自动推断，且只能是以下的类型： . | 整数类型 | 枚举类型 | 指针或左值引用类型 | . 对于非类型形参的实参来说，该实参必须是常量表达式，必须要在编译时就能获得。 . // 含有一个类型形参，一个非类型形参的函数模板prints template&lt;typename ty, int tval = 8&gt; void prints(ty val, int val2 = tval) { } . 根据形参的类型，非类型形参的实参还有以下的限制条件： . | 对于整数类型和枚举类型的非类型形参的实参来说： 该实参只能是整数类型的常量表达式(可以不是对应类型的)。 | 对于指针或左值引用类型的非类型形参的实参来说： 其必须要是能链接到的（也就是必须是外部或者内部链接，且不能是局部变量）对象。 这也就是指在静态存储区或者堆区的非局部变量对象(也就是不能是临时变量、局部变量以及类类型数据成员等子对象)，且其类型基本上要精确匹配，除了允许从非底层const向底层const的类型转换，其他的转换一律不行。 | . #include &lt;iostream&gt; #include &lt;string&gt; // 含有字符串常量指针的非类型模板参数 template &lt;const char* str&gt; std::string Add(const char* string) { return std::string(str)+string; } // 内部链接（其他文件不能访问该对象）的静态区的全局对象 static const char g_str[] = \"string\"; // 外部链接（其他文件能访问该对象）的静态区的全局对象（不加extern默认就是外部链接） extern const char g_str2[] = \"-string-\"; // 外部链接（其他文件能访问该对象）的堆区的全局对象（不加extern默认就是外部链接） const char g_str3[] = {*(new char('d')), *(new char('s'))}; int main() { // 不能被链接（也就是不能被其他文件或者本文件的其他函数类所访问的）的静态区的局部对象 static const char str[] = \"ringle\"; // 不能被链接（也就是不能被其他文件或者本文件的其他函数类所访问的）的栈区的局部对象 const char str2[] = \"local\"; // 不能被链接（也就是不能被其他文件或者本文件的其他函数类所访问的）的堆区的的局部对象 const char str3[] = {*(new char('n')), *(new char('e'))}; // 正确，g_str为内部链接的静态区的全局对象 std::cout &lt;&lt; Add&lt;g_str&gt;(\" great\") &lt;&lt; std::endl; // 正确，g_str2为外部链接的静态区的全局对象 std::cout &lt;&lt; Add&lt;g_str2&gt;(\" great\") &lt;&lt; std::endl; // 正确，g_str3为外部链接的堆区的全局对象 std::cout &lt;&lt; Add&lt;g_str3&gt;(\" great\") &lt;&lt; std::endl; // 错误，str为不能被链接的静态区的局部对象 std::cout &lt;&lt; Add&lt;str&gt;(\" great\") &lt;&lt; std::endl; // 错误，str2为不能被链接的静态区的栈区对象 std::cout &lt;&lt; Add&lt;str2&gt;(\" great\") &lt;&lt; std::endl; // 错误，str3为不能被链接的静态区的堆区对象 std::cout &lt;&lt; Add&lt;str3&gt;(\" great\") &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10412-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10412-非类型形参"
  },"51": {
    "doc": "模板概念详解",
    "title": "10.413 模板类形参",
    "content": "对于模板形参来说，还有一种特殊的形参，也就叫做模板类形参。 我们可以将一个类模板当做某个模板形参来使用，此时我们只需要在模板形参表写上关键字template、对应类模板的模板形参表和关键字typename或class就行。 . 模板类形参在模板形参的声明形式为： . template 类模板的模板形参表 typename/class 模板类形参名 . 关键字typename和class的含义相同，可以互换使用。 . 类模板的模板形参表中的模板形参可以有形参名和默认实参，如果填入了默认实参，则使用该模板类形参时会以此时的默认实参为主。 . 对于模板类形参的实参来说，该实参必须是与对应的模板类形参的模板形参表一致的类模板。 . // 模板prints含有一个模板类形参，且该模板类形参的模板形参表中含有默认实参 template&lt;template&lt;class = string, int = 3&gt; typename cls&gt; void prints() { cls&lt;&gt; ob; cout &lt;&lt; ob.str &lt;&lt; \" \" &lt;&lt; ob.ins; } // 类模板Cls template&lt;class ty, int val = 18&gt; struct Cls { ty str = \"str\"; int ins = val; }; // 正确：默认实参以prints的为主，因此输出str 3 prints&lt;Cls&gt;(); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10413-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10413-模板类形参"
  },"52": {
    "doc": "模板概念详解",
    "title": "10.414 可变数目形参",
    "content": "可变数目形参就是指一个可以接受零个或多个对应类型实参的特殊形参，可变数目形参也叫做参数包(parameter packet)。 . C++中存在两种参数包： . | 模板参数包(template parameter packet)： 是在模板形参表中的声明的参数包。 | 函数参数包(function parameter packet)： 是在模板中的函数形参表(包括函数模板中的函数形参表和类模板中声明或定义的函数以及成员函数模板中的函数形参表)中声明的参数包。 函数参数包不是之前所说的省略符形参，函数参数包是基于模板参数包所形成的特殊形参。 | . 所有参数包都不能有默认实参。 . 不管是哪一种参数包，含有参数包的形参表都还可以含有其他的非参数包形参，但是每个形参表最多只能含有一个参数包，且必须要放在该形参表的末尾。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10414-%E5%8F%AF%E5%8F%98%E6%95%B0%E7%9B%AE%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10414-可变数目形参"
  },"53": {
    "doc": "模板概念详解",
    "title": "10.4141 模板参数包",
    "content": "含有模板参数包的模板叫做可变参数模板(variadic template)。 . 根据模板形参的类型，模板参数包一共有三种： . | 类型参数包 | 非类型参数包 | 模板类参数包 | . 模板参数包的声明形式与普通模板形参类似，任何普通模板形参声明表达式的关键字或者说明符(或修饰符)后，形参名前加上省略符...，就成了一个模板参数包的声明。 . 模板参数包的声明形式为： . 类型参数包的声明： . typename/class … 参数包名 . 非类型参数包的声明： . 类型说明符(可含类型修饰符) … 参数包名 . 模板类参数包的声明： . template 类模板的模板形参表 typename/class … 参数包名 . // 类模板Cls的模板形参表中含有1个类型参数包 template &lt;int val, typename ty, class ... tys&gt; struct Cls{}; // 类模板Cls2的模板形参表中含有1个非类型参数包 template &lt;typename ty, int ...vals&gt; struct Cls2{}; // 类模板Cls3的模板形参表中含有1个模板类参数包 template &lt;int val, template &lt;class ty&gt; class ...temps&gt; struct Cls3{}; . 对于模板参数包来说，我们可以将其对应类型的零个或多个实参传递给该参数包，每个实参以逗号,分隔。 . template &lt;int ...vals&gt; struct Cls {}; // 实例obj中的模板参数包vals中含有5个int模板形参 Cls&lt;15,8,123,25,8&gt; obj; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#104141-%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E5%8C%85",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#104141-模板参数包"
  },"54": {
    "doc": "模板概念详解",
    "title": "10.4142 函数参数包",
    "content": "函数参数包的介绍详见函数参数包 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#104142-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%8C%85",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#104142-函数参数包"
  },"55": {
    "doc": "模板概念详解",
    "title": "10.415 非参数包的模板形参使用",
    "content": "各种非参数包的模板形参可以根据自身的类型，用在模板各种能用该类型的地方。 比如类型形参可以用于各种需要类型的地方，比如当做函数返回类型、形参类型、变量类型等；非类型形参可以当作函数默认实参或者用于需要值的某些类型中等；模板类形参以此类推。 . 当我们将模板类型形参或者模板类形参实例当做类类型使用时，我们可以访问其成员，且编译器也不会在模板定义时去确定是否有该成员以及该成员的类型。 . 所以这样会出现一些问题： 之前我们介绍过我们可以用作用域运算符::来访问一个类类型的静态成员或者类类型成员。 但对于模板来说，编译器不会在模板定义时去检查含有模板参数的表达式。默认情况下，编译器会认为含有模板参数的表达式使用作用域运算符所访问的成员为静态成员（非类类型成员），所以为了能够访问类类型成员，我们就要显式指定访问的是类类型成员。 . 我们通过使用关键字typename来实现显式访问类类型成员，使用形式为： . typename 含有模板参数的表达式::类类型成员名 . typename要紧跟在该模板类型形参名或模板类形参实例后面，所以static等修饰限定符要放在typename之前。 . #include &lt;vector&gt; template&lt;typename ty&gt; void prints(ty obj) { // 错误：编译器认为cls_int为静态成员，所以出错。 ty::cls_int val2 = 35; // 正确：显式指定cls_int为类类型成员。 typename ty::cls_int val = 35; // 错误：编译器认为iterator为静态成员，所以出错。 std::vector&lt;ty&gt;::iterator iter; // 正确：显式指定iterator为类类型成员。 typename std::vector&lt;ty&gt;::iterator iter2; cout &lt;&lt; obj.ins + val; } struct Cls { typedef int cls_int; cls_int ins = 48; }; // 输出83 prints(Cls()); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10415-%E9%9D%9E%E5%8F%82%E6%95%B0%E5%8C%85%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%BD%A2%E5%8F%82%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10415-非参数包的模板形参使用"
  },"56": {
    "doc": "模板概念详解",
    "title": "10.416 参数包的使用",
    "content": "参数包并不是普通的形参，它是包含了多个同类型参数的形参。 . 对于参数包来说，只有两种用法： . | 包扩展 | 获取包大小 | . 参数包或者包扩展不能单独成为一个语句，也就是不能单独使用，必须要结合其他真正能用上的操作才行。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10416-%E5%8F%82%E6%95%B0%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10416-参数包的使用"
  },"57": {
    "doc": "模板概念详解",
    "title": "10.4161 包扩展",
    "content": "包扩展是使用参数包最基本的用法，我们只有扩展（expand）了某个参数包后，才能使用该参数包。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#104161-%E5%8C%85%E6%89%A9%E5%B1%95",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#104161-包扩展"
  },"58": {
    "doc": "模板概念详解",
    "title": "10.41611 包扩展的形式",
    "content": "包扩展的形式为： . 扩展模式… . 扩展模式（pattern）是指==包含有某参数包名==的一个非声明或定义的表达式(比如类型模板参数包的引用，非类型模板参数包与其他表达式的运算，函数参数包的调用等等)。扩展模式会对该参数包中的所有参数应用该表达式。 . 扩展模式后面必须要紧跟一个省略符...，省略符不能跟在非参数包名后面（圆括号除外）。 对于模板参数包来说，模式和省略符之间不能有空白符；而函数参数包则可以有。 . 省略符优先级比算术运算符等符号要高，所以包扩展时要注意优先级的问题。 . // 类型模板参数包tys的扩展 const tys&amp;... // 模板类模板参数包temps的扩展 temps&lt;int&gt;... // 非类型模板参数包vals的扩展 (vals + 20)... // 函数参数包objs的扩展 prints(objs)... 未命名的参数包无法扩展，因为无法指定未命名的对象。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1041611-%E5%8C%85%E6%89%A9%E5%B1%95%E7%9A%84%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1041611-包扩展的形式"
  },"59": {
    "doc": "模板概念详解",
    "title": "10.41612 包扩展的作用",
    "content": "包的扩展就是将该参数包在使用扩展的位置替换为一个包含该参数包所有参数的列表，该列表中的每个参数都应用了其扩展模式，该列表没有括号包围，且每个参数之间由逗号,分隔。 . // 类型模板参数包tys，等价于\\ const ty1&amp;, const ty2&amp;, const ty3&amp;, ··· const tys&amp;... // 模板类模板参数包temps，等价于\\ temp1&lt;int&gt;, temp2&lt;int&gt;, temp3&lt;int&gt;, ··· temps&lt;int&gt;... // 非类型模板参数包vals，等价于\\ ((val1 + 20), (val2 + 20), (val3 + 20), ···) (vals + 20)... // 非类型模板参数包vals，等价于\\ ((val1 + 15 + val1), (val2 + 15 + val2), (val3 + 15 + val3), ···) vals + 15 + vals... // 函数参数包objs，等价于\\ prints(obj1), prints(obj2), prints(obj3), ··· prints(objs)... 函数参数包 . 对于类型模板参数包和模板类模板参数包来说，它们的扩展还有另一种作用，就是可以声明函数参数包。 . 只有这种形式才能声明函数参数包。 . 函数参数包只能出现在模板的函数形参表中，不能出现在其他地方。函数参数包也遵循参数包的各种规则。 . 声明函数参数包的形式为： . 类型或模板类的模板参数包的扩展 函数参数包名 . 只有扩展模式为模板类模板参数包实例时，才能用模板类模板参数包来声明函数参数包。 . 函数参数包的类型为声明该参数包的模板参数包的扩展类型。 和模板参数包一样，函数参数包可以包含与其类型相同的零个或多个参数(如不需要该参数包参与模板实参推断，则参数还可以是能隐式转成该参数包类型的)。 . #include &lt;iostream&gt; #include &lt;vector&gt; // 输出函数模板 // 返回类型不为void的目的是使包扩展能当作实参 template &lt;class ty&gt; int prints(ty val) { std::cout &lt;&lt; val &lt;&lt; \" \"; return 0;} // 因为参数包或者包扩展不能单独成为一个语句，也就是不能单独使用，必须要结合其他真正能用上的操作。所以可以使用该函数来使其生效 void get_packet_work(...) {} // 该函数模板的函数形参表中含有函数参数包obj template &lt;typename ...tys&gt; void makes(const tys... objs) { // 等价于\\ std::vector&lt;int&gt; v1 = {obj1,obj2,obj3,···}; // 其中的形参类型都为常量类型。 std::vector&lt;int&gt; v1 = {objs...}; // 等价于\\ get_packet_work(prints(obj1), prints(obj2), prints(obj3), ···); get_packet_work(prints(objs)...); } int main() { // 因为根据函数栈的特性，参数从最后一个开始取， // 所以输出为48 23 478 15 makes(15, 478, 23, 48); return 0; } . 调用包含函数参数包的函数时(包括函数模板实例)，该函数参数包所接受的实参数量不能小于声明该参数包的模板参数包所含的参数数量(主要说的是非模板实参推断的实例化)，否则出错。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1041612-%E5%8C%85%E6%89%A9%E5%B1%95%E7%9A%84%E4%BD%9C%E7%94%A8",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1041612-包扩展的作用"
  },"60": {
    "doc": "模板概念详解",
    "title": "10.41613 包扩展适用范围",
    "content": "包扩展只适用于以下形式，其他形式的语法都会导致编译错误： . | 函数实参表中(Function argument lists) | 圆括号初始化表中(Parenthesized initializers) | 列表初始化表中(Brace-enclosed initializers) | 模板实参表中(Template argument lists) | 函数形参表中(Function parameter list) | 模板形参表中(Template parameter list) | 类继承表以及类类型数据成员初始化表中(Base specifiers and member initializer lists) | lambda函数捕获列表中(Lambda captures) | sizeof...运算符表达式中(The operator) | 动态异常throw表达式中(Dynamic exception specifications)(c++17之前) | alignas对齐声明中(Alignment specifier) | 属性列表中(Attribute list) | 折叠表达式中(Fold-expressions)(c++17开始) | using声明中(Using-declarations)(c++17开始) | 包索引(下标运算符内)中(Pack indexing)(c++26开始) | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1041613-%E5%8C%85%E6%89%A9%E5%B1%95%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1041613-包扩展适用范围"
  },"61": {
    "doc": "模板概念详解",
    "title": "10.4162 获取参数包的大小",
    "content": "当我们需要知道包中含有多少参数时，可以使用sizeof...运算符。 . sizeof和省略符...之间不能有空白符 . sizeof...运算符为一元运算符，运算对象在右侧括号内。 运算对象为左值。运算结果为右值。 . sizeof...运算符的使用形式为： . sizeof… (参数包名) . 该运算符的运算对象只能是参数包名，不能为其他的对象。 . sizeof...返回一个常量表达式，该表达式的值就是所给参数包当前所含的参数数量。 类似sizeof运算符，不会对其运算对象求值。 . template &lt;typename ...tys&gt; void prints(tys... obj) { cout &lt;&lt; sizeof...(obj); } int main() { // 输出5 prints(3.15, \"str\", 2, true, 's'); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#104162-%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E5%8C%85%E7%9A%84%E5%A4%A7%E5%B0%8F",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#104162-获取参数包的大小"
  },"62": {
    "doc": "模板概念详解",
    "title": "10.42 模板默认实参",
    "content": "和函数形参一样，非参数包的模板形参和函数模板中的非参数包的函数形参都可以有默认实参，它们的规则大部分与普通默认实参的规则一样(比如默认实参要放在形参表末尾等)，只有以下的区别： . | 对于非参数包模板形参的默认实参来说： 同一个模板中，==前面的模板形参可以作为后面模板形参的默认实参==。 一个模板的声明(包括模板友元的声明语句)和定义如果不在同一个文件中，则可以对同一个模板形参有不同的默认实参，但是该模板形参的默认实参只会按照该形参第一个出现的默认实参来决定。 如果在同一个文件中，则有以下特性： . | 对于函数模板来说，默认实参只能在该模板第一次出现的语句中(声明或定义语句都可以，也包括模板友元的声明语句)，其他语句出现的默认实参无效。 #include &lt;iostream&gt; // Prints第一次出现的语句，声明语句，T2带有默认实参 template&lt;typename T, typename T2 = T&gt; void Prints(const T&amp; obj); // Prints的定义语句 template&lt;typename T, typename T2&gt; void Prints(const T&amp; obj) { std::cout &lt;&lt; obj &lt;&lt; std::endl; } // Prints2第一次出现的语句，声明语句，没有默认实参 template&lt;typename T, typename T2&gt; void Prints2(const T&amp; obj); // Prints的定义语句，T1，T2带有默认实参，但因为函数模板的默认实参只能在该模板第一次出现的语句中，所以模板实参推断无效 template&lt;typename T = int32_t, typename T2 = int32_t&gt; void Prints2(const T&amp; obj) { std::cout &lt;&lt; obj &lt;&lt; std::endl; } int main() { // 调用正确，T被模板实参推断为int Prints(1548); // 调用错误，T2的默认实参无效，模板实参推断无效。 Prints2(1548, 887); return 0; } . | 对于类模板来说，默认实参可以出现在任意的声明或定义语句中（包括模板友元的声明语句），只要遵循默认实参放在形参表末尾且同一形参没有多个默认实参的规则就行。 // Cls声明语句，没有默认实参 template&lt;typename T, typename T2&gt; class Cls; // Cls定义语句，T2带有默认实参 template&lt;typename T, typename T2 = T&gt; class Cls{}; int main() { // 调用正确，T2被默认实参指定为int32_t Cls&lt;int32_t&gt; cls; } . | . | 对于函数模板中非参数包的函数形参的默认实参来说： 不能像普通函数一样可以用多个声明来添加默认实参。 默认实参只能在该模板第一次出现的语句中(声明或定义语句都可以，也包括模板友元的声明语句)，其他语句都不能出现默认实参。 和普通函数一样，函数的==局部变量，包括其他形参都不能作为该函数的默认实参==。 . // 函数模板prints的声明，三个模板形参都有了默认实参 template &lt;class = string, class = int, int = 5&gt; void prints(); // 函数模板prints的定义 template &lt;class ty1, class ty2, int val&gt; void prints() { ty1 str = \"str \"; ty2 ins = 58; cout &lt;&lt; str &lt;&lt; ins; } // 错误，同一个文件中同一个参数的默认实参只能出现一次。 template &lt;class, class, int = 55&gt; void prints(); // 输出str 58 prints(); // 函数模板，取最大值 // 因为AType在ResType之前，所以ResType的默认实参可以为AType template&lt;class AType, class BType, class ResType = AType&gt; ResType Max(AType a, BType b) { return a &gt; b ? a: b; } int main() { // ResType与AType类型相同，都为int // dou的值为87 double dou = Max(15,87.8); // 输出为87 std::cout &lt;&lt; dou &lt;&lt; std::endl; return 0; } . | . 注意： 对于模板实参全部有默认实参的类模板来说，使用该模板时仍需加上空的显式实参表，否则会编译出错。 . // 模板实参全部有默认实参的函数模板 // 使用时可以不用加空的显式实参表 template&lt;class T = int&gt; T prints() { return T{}; } // 模板实参全部有默认实参的函数模板 // 使用时必须要加空的显式实参表 template &lt;class T = int&gt; class Coke{}; int main() { // 编译错误 Coke obj; // 正确 Coke&lt;&gt; obj2; // 正确 prints(); // 正确 prints&lt;&gt;(); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1042-%E6%A8%A1%E6%9D%BF%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1042-模板默认实参"
  },"63": {
    "doc": "模板概念详解",
    "title": "10.5 模板实例化",
    "content": "模板的实例化(instantiate)也就是编译器根据模板形参表里的实参或者函数模板中的函数实参来推断出模板形参的类型或者值是什么，并使用这个版本。 当编译器实例化一个模板吋，它使用实际的模板实参代替对应的模板参数来创建出模板的新“实例”，这些通常被称为模板的实例(instantiation)。 . 模板的实例也可以说是根据模板实参，替换掉模板函数或者类里面的所有模板形参，所创建的一个具体的，有着固定内存大小的函数或者类。 . 要注意模板并不是函数或者类，模板只是一个所谓的蓝图，只有模板的实例才是函数或者类。 . 所以函数模板的实例可以被当做可调用对象；类模板的实例可以被当做类型说明符使用。 . 实例创建后会一直保存在同文件中，直到程序结束。 所以当一个模板的实例将要被创建时，编译器会检查同文件中该模板是否已经创建过相同的实例，如果是，则会直接调用之前创建的实例进行操作，否则就创建一个新的实例。 . 当编译器遇到一个模板的定义或声明时，它并不进行实例化，只有使用模板时，才有可能进行实例化。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#105-%E6%A8%A1%E6%9D%BF%E5%AE%9E%E4%BE%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#105-模板实例化"
  },"64": {
    "doc": "模板概念详解",
    "title": "10.51 模板编译流程",
    "content": "在介绍实例化的方式前，我们需要介绍一下模板编译的流程。 . 模板直到实例化吋才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误： . | 编译模板自身阶段： 在这个阶段，编译器只会对模板中的所有不依赖于模板参数的名字进行名字查找(不会进行类型检查)以及各种语法错误检查，例如忘记分号、变量名拼错等，但也就这么多了。 | 模板使用阶段： 在此阶段，编译器才会检查与模板参数有关的部分。通常会检查模板中的模板实参数目是否正确：对于函数模板，会检查函数形参的数量和类型是否匹配；对于类模板，则会检查模板实参的数量和类型是否匹配。但除此之外，编译器仍然没有很多可检查的。 | 模板实例化阶段： 编译器只有在这个阶段才能发现类型相关的错误，依赖于编译器如何管理实例化，这类错误可能在链接时才会报告。 在这一阶段，编译器会检查该模板内的模板调用和函数调用是否匹配。 对于含有包扩展参数的调用表达式，编译器会根据该包所含的实参数量，检查是否符合调用，如果该调用中又含有调用，则沿着调用链向里继续检查，直到所有调用都符合才行，否则编译出错。 | . template &lt;typename ...tys&gt; void prints(string str, tys... obj) { cout &lt;&lt; str &lt;&lt; \" \"; // 没有用，因为以下是编译阶段进行的检查。 if (sizeof...(obj) &gt; 0) // 该语句是该模板进行递归调用 // 如果该模板要实例化，则在实例化阶段，\\ 编译器会沿着调用链检查所有的调用是否匹配，\\ 其中当obj中的参数数量为0时，无法匹配到该函数模板，所以实例化会出错。 prints(obj...); } int main() { // 调用出错 prints(string(\"str\"), string(\"str2\"), string(\"str3\"), string(\"str4\")); return 0; } . void prints() {} template &lt;typename ...tys&gt; void prints(string str, tys... obj) { cout &lt;&lt; str &lt;&lt; \" \"; // 该语句是该模板进行递归调用 // 如果该模板要实例化，则在实例化阶段，\\ 编译器会沿着调用链检查所有的调用是否匹配，\\ 其中当obj中的参数数量为0时，会调用空形参表的重载函数，所以会成功实例化。 prints(obj...); } int main() { // 调用正确： // 输出str str2 str3 str4 prints(string(\"str\"), string(\"str2\"), string(\"str3\"), string(\"str4\")); return 0; } . 注意： 由于模板编译流程的特性，当某模板类的基类是类模板，且基类的类模板使用了模板参数时，如果该模板类直接使用基类的成员，则会报错说找不到该成员，解决方法就是显式使用该成员。 . // 类模板，充当基类 template&lt;typename T&gt; struct Base { int32_t intObj{55}; }; // 普通类继承模板基类，基类已实例化 struct GeneralCls: Base&lt;int&gt; { void test() { // 正确：模板基类没有使用模板参数 int32_t intt = intObj; std::cout &lt;&lt; intt &lt;&lt; std::endl; } }; // 类模板继承模板基类，基类已实例化 template&lt;typename T, int32_t N&gt; struct TemplateCls: Base&lt;int32_t&gt; { T set[N]; void test() { // 正确：模板基类没有使用模板参数 int32_t intt = intObj; std::cout &lt;&lt; intt &lt;&lt; std::endl; } }; // 类模板继承模板基类，基类未实例化 template&lt;typename T, int32_t N&gt; struct TemplateCls2: Base&lt;T&gt; { T set[N]; void test() { /* 错误： 模板基类Base使用了模板参数， 在模板TemplateCls2编译的第一阶段会忽略掉该基类Base的检查。 因此编译器在第一阶段对intObj进行名字查找时由于忽略了基类Base， 会出现找不到成员的错误。 解决方法就是显式指明intObj的来源，如 int32_t intt = this-&gt;intObj; int32_t intt = Base&lt;T&gt;::intObj; */ int32_t intt = intObj; std::cout &lt;&lt; intt &lt;&lt; std::endl; } }; . 注意: 对于模板函数来说，可以将其定义为constexpr函数，只要其满足constexpr函数的定义要求，就能用于需要常量表达式的场合，该模板的实例在编译期就能得出结果 . #include &lt;array&gt; // 两数相加，constexpr函数 // 可在编译时得出结果 template&lt;typename T&gt; constexpr T Add(T a, T b) { return a + b; } // 两数相加，非constexpr函数，不可在编译时得出结果 const std::size_t Add2(const std::size_t&amp; a, const std::size_t&amp; b) { return a + b; } int main() { std::size_t ins = 4; // 错误，ins不是常量表达式，不能用于非类型模板参数 std::array&lt;int, ins&gt; arr; // 错误，Add2函数不是常量表达式函数，不能用于非类型模板参数 std::array&lt;int, Add2(2lu,8lu)&gt; arr2; // 正确，Add函数是constexpr常量表达式模板函数，可以用于非类型模板参数 std::array&lt;int, Add(2lu,8lu)&gt; arr3; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1051-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1051-模板编译流程"
  },"65": {
    "doc": "模板概念详解",
    "title": "10.52 实例化分类",
    "content": "模板实例化的方法有以下几种： . | 隐式实例化 | 显式实例化 | . 注意： 不管隐式还是显式实例化，在模板实参列表中不能含有任何模板形参，否则就不能实例化了。 . // 类模板，充当基类 template&lt;typename T&gt; struct Base { T obj; }; // 类模板 template&lt;typename T&gt; struct TemplateCls { // 错误：Base已被隐式实例化，而Base里不存在fakeObj成员，因此会报错 int32_t int32Obj = Base&lt;int32_t&gt;::fakeObj; // 正确：Base已被隐式实例化，Base里存在类型相同的obj成员，编译通过 int32_t int32Obj = Base&lt;int32_t&gt;::obj; // 正确：Base未被实例化，Base里存在类型相同的obj成员，编译通过 int32_t int32Obj2 = Base&lt;T&gt;::fakeObj; }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1052-%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%88%86%E7%B1%BB",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1052-实例化分类"
  },"66": {
    "doc": "模板概念详解",
    "title": "10.53 隐式实例化",
    "content": "隐式实例化是指我们在使用模板时所自动进行的实例化。 . 隐式实例化的方法分为两种： . | 使用显式模板实参列表 | 模板实参推断 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1053-%E9%9A%90%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1053-隐式实例化"
  },"67": {
    "doc": "模板概念详解",
    "title": "10.531 显式模板实参列表",
    "content": "显式模板实参列表(explicit template argument)也叫做模板实参表，它显式给出模板的各个实参，编译器通过这些实参来实例化具体的函数或类（所以实参表中不能含有任何模板形参）。 . 使用模板实参表的形式为： . 模板名 . 模板实参表类似于函数实参表，是一个由逗号,分隔的多个模板实参的列表(可以为空)。 . 和函数实参表一样，模板实参表中的模板实参的数量，顺序和类型要一致。对于有默认实参的模板形参，我们也可以在实参表中省略其实参。 . 对于所有模板形参来说，实参赋值到形参时，会且仅会进行以下的隐式类型转换(不会进行其他的隐式类型转换)： . | 编译器会忽略顶层const。 | 对于非引用的函数形参来说，函数或者数组名会转换成对应的指针。 | . 所以非类型的模板形参的实参要与其形参类型一致才行。 . template &lt;class ty, int val&gt; struct Cls {}; // 错误：4.8为double，与int不一致 Cls&lt;int, 4.8&gt; obj; // 正确 Cls&lt;int, 4&gt; obj2; . 当我们使用了模板实参表后，编译器就会生成一个实例，该实例也就是一个具体的函数或类，我们就可以像使用普通的函数或类一样来使用该实例了。 . template &lt;typename ty, int val&gt; void prints(ty v1, int multiple = val) { cout &lt;&lt; v1 * multiple &lt;&lt; \"\\n\"; } template &lt;class ty, int val = 35&gt; struct Cls { ty str = \"str\"; int ins = val; }; // 使用函数模板实参表，\\ 输出64.8 prints&lt;double, 8&gt;(8.1); // 使用类模板实参表，\\ 输出35 str Cls&lt;string&gt; ob; cout &lt;&lt; ob.ins &lt;&lt; \" \" &lt;&lt; ob.str; . 对于==类模板的隐式实例化==来说，其成员并不是在生成实例后就全部实例化了。 默认情况下，==类模板的非数据成员只有在其被使用时才被实例化==。 这一特性使得即使某种类型不能符合模板操作的要求，我们仍然能用该类型来实例化类模板。 . #include &lt;string&gt; template &lt;typename ty&gt; struct Cls { ty ob_ = 15; void Prints() { std::cout &lt;&lt; ob_.str; } }; int main() { // 正确：虽然int类型没有str成员，但此时prints没有实例化。 Cls&lt;int&gt; obj; // 正确：输出15 std::cout &lt;&lt; obj.ob_; // 错误：非数据成员会在模板调用时就实例化 // ob_中，int不能转换为std::string。 Cls&lt;std::string&gt; obj2; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10531-%E6%98%BE%E5%BC%8F%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E5%88%97%E8%A1%A8",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10531-显式模板实参列表"
  },"68": {
    "doc": "模板概念详解",
    "title": "10.532 模板实参推断",
    "content": "编译器利用函数模板调用中的函数实参来确定其模板参数的过程被称为模板实参推断(template argument deduction)。 . 模板实参推断只用于函数模板，模板实参推断也就是指当我们调用一个函数模板时，编译器通常会用函数实参来为我们推断模板实参而不需要显式提供模板实参。 . 模板实参推断只能在以下这两种情况下使用： . | 类似函数调用形式来调用函数模板。 | 用函数模板来初始化或赋值函数指针。 | . 类似函数调用形式来调用函数模板的形式为： . 函数模板名(函数实参表) . 当我们用函数模板来初始化或赋值函数指针时，编译器自动使用指针的各个对应类型来推断模板的实参，此时也必须遵循函数指针的初始化或赋值规则(比如形参数量类型等都要一致)。 . 当我们使用了没有默认实参的模板类型形参或模板类形参作为函数形参的类型时，编译器推断的类型与使用auto说明符的推断类型一样(也支持引用折叠等操作)： . | 当函数实参的类型为以下这些时，编译器会自动对其进行类型转换(对于其他类型则不会进行类型转换)： . | 编译器会忽略顶层const。 | 对于非引用的函数形参来说，函数或者数组名会转换成对应的指针。 | . | 每个模板类型形参的类型以第一个使用该形参的函数形参的实参来决定，所以之后使用该形参的函数形参的实参必须要与第一个的一致，否则出错。 | . template &lt;typename ty&gt; void prints(ty v1) {} template &lt;typename ty&gt; void prints2(ty v1, ty v2) {} const int ins = 48; int ar[3] = {8,15,6}; int main() { // ty为int prints(ins); // ty为int* prints(ar); // 正确：两个实参的类型一致 prints2(3.45, 6.15); // 错误：第一个为double，第二个为int prints2(3.45, 6); // 正确 void (*ptr) (string) = prints; // 正确 void (*ptr2) (int, int) = prints2; // 错误：第一个为double，第二个为int void (*ptr3) (int, double) = prints2; } . template&lt;typename T, int N&gt; T sumForList(const T list[N]) { T sum = 0; for (int i = 0; i &lt; N; ++i) sum += list[i]; return sum; } template&lt;typename T, int N&gt; T sumForList2(const T (&amp;list)[N]) { T sum = 0; for (int i = 0; i &lt; N; ++i) sum += list[i]; return sum; } int main() { int64_t arrs[] = {5,8,9,6,-11,0,6,3,25,-48}; // 错误：数组名arrs被转换成对应的指针，因此无法自动推断非类型参数N的值 std::cout &lt;&lt; sumForList(arrs) &lt;&lt; std::endl; // 正确：list为arrs的引用，因此可以推断非类型参数N的值为10 std::cout &lt;&lt; sumForList2(arrs) &lt;&lt; std::endl; } . 对于满足以下任意一个条件的函数形参来说，其适用于正常的类型的转换： . | 其类型不含有模板类型形参以及模板类形参。 | 其类型含有有默认实参的模板形参。 | . 对于函数指针的初始化或赋值来说，如果两边都需要使用类型自动推断的操作时(也就是函数指针的类型为auto或decltype，且函数模板的某函数形参的类型使用了没有默认实参的模板类型形参或模板类形参时)则不能使用模板实参推断，只能使用模板实参表来隐式实例化。 . template &lt;typename ty&gt; void prints(ty v1, ty v2) {} // 以下两个都错误：不能使用模板实参推断，因为两边都需要使用类型自动推断 auto ptr = prints; decltype(prints) *ptr2 = prints; // 以下两个都正确：使用模板实参表，类型为\\ void (*) (int, int) auto ptr3 = prints&lt;int&gt;; decltype(prints&lt;int&gt;) *ptr4 = prints; . 对于模板实参推断，其还有以下的限制： . | 当使用函数调用形式的模板实参推断时，对于有默认实参的函数形参来说，满足以下任意一种情况时才能在隐式实例化时省略该实参，否则不能省略： . | 该函数形参类型不是模板形参。 | 该函数形参类型是有默认实参的模板形参。 | 该函数形参类型不含有模板形参。 | 该函数形参类型含有有默认实参的模板形参。 | . | 模板实参推断只能用于满足以下这个条件的函数模板，不满足的函数模板不能使用模板实参推断： . | 对于函数调用形式的模板实参推断： 函数模板中所有没有默认实参的模板形参都应该出现在==函数形参表的形参类型==中。 | 对于函数指针初始化或赋值的模板实参推断： 函数模板中所有没有默认实参的模板形参都应该出现在函数形参表的==形参类型或者返回类型==中。 | . | . int ar[8] = {3,8,6,3}; template &lt;class ty1, class ty2 = int, int val = 8&gt; void prints(ty1 v1, ty2 v2 = 54, int (&amp;v3)[val] = ar, double v4 = 10.5) { cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; *v3 &lt;&lt; v4; } template &lt;class ty1, class ty2, int val&gt; void prints2(ty1 v1, ty2 v2 = 54, int (&amp;v3)[val] = ar, double v4 = 10.5) { cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; *v3 &lt;&lt; v4; } int main() { // 隐式实例化正确：可以省略v2,v3,v4的实参 prints(\"str\"); /* 隐式实例化错误：v2形参的类型为无默认实参的模板形参 v3形参的类型含有无默认实参的模板形参 所以不能省略v2,v3的实参*/ prints2(\"str\"); } . // 函数模板prints的没有默认实参的模板形参ty出现在了函数形参表中 template &lt;typename ty, int val = 8&gt; void prints(ty v1, int v2 = val) {} // 函数模板prints2的没有默认实参的模板形参ty没有出现在函数形参表中 template &lt;typename ty, int val = 8&gt; ty prints2(int v1, int v2 = val) {} // 以下三个都正确 prints(6.5); void (*ptr) (double, int) = prints; double (*ptr2) (int, int) = prints2; // 错误:不能用模板实参推断 prints2(8); . 对于函数模板，模板实参推断可以与显式模板实参列表结合使用，也就是对于无法进行模板实参推断的模板参数进行显式指定，而对于其他的模板参数则进行实参推断： . #include &lt;iostream&gt; // 函数模板，取最大值 template&lt;typename ResType, class AType, class BType&gt; ResType Max(AType a, BType b) { return a &gt; b ? a: b; } int main() { // 模板实参推断与显式模板实参列表结合使用，ResType显式指定为int，其他模板参数进行实参推断 // dou的值为87 double dou = Max&lt;int&gt;(15,87.8); // 输出为87 std::cout &lt;&lt; dou &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10532-%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10532-模板实参推断"
  },"69": {
    "doc": "模板概念详解",
    "title": "10.54 显式实例化",
    "content": "根据模板实例化的特性，当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。 . 这样就会导致一个程序会有多个相同的实例，所以，此时我们需要进行显式实例化来消除这种情况。 . 显式实例化只能出现在全局作用域和命名空间中，不能出现在其他的局部作用域内。 且显式实例化要在模板定义语句所在的作用域内，否则出错。 . 显式实例化的形式有两种： . | 显式实例化定义 | 显式实例化声明 | . 显式实例化定义的形式为： . template 模板的隐式实例化声明 . 显式实例化声明的形式为： . extern template 模板的隐式实例化声明 . 模板的隐式实例化声明类似于隐式实例化，也就是该模板中的所有模板形参都含有模板实参的声明形式（所以如果有显式实参表，则其中不能含有任何模板形参）。 对于类模板来说，就是其类关键字加上使用显式实参表的形式；对于函数模板来说，是显式实参表或者实参推断的形式的函数声明形式(也就是含有返回类型和函数形参表的函数声明，其中所有模板形参的类型都换为该形参的实参)。 . 如果原模版的某些模板形参含有默认实参，则显式实例化时的显式实参表可以忽略该参数的填写，其他地方要填写，且类型要和该默认实参一样。 . 注意：显式实例化的声明和定义中不能含有constexpr，inline等修饰符，也就是原模版有的这些修饰符不要出现在对应的显式实例化中。 . #include &lt;string&gt; // 函数模板prints template &lt;typename ty, int val, class ty2&gt; ty prints(ty2 v1, int multiple = val) { return ty{}; } // 函数模板prints2，含有constexpr template &lt;typename ty&gt; constexpr ty prints2(ty v1) { return ty{}; } // 函数模板print3，含有inline，val含有默认实参 template &lt;typename ty, int val = 10&gt; inline ty prints3(ty v1[val]) { return ty{}; } // 类模板Cls，ty2含有默认实参 template &lt;typename ty, int val, class ty2 = int&gt; struct Cls {}; // 函数模板prints的显式实例化声明 extern template int prints&lt;int, 8, double&gt;(double, int); // 函数模板prints的显式实例化定义 template int prints&lt;int, 8, double&gt;(double, int); // 函数模板prints2的显式实例化声明 extern template float prints2&lt;float&gt;(float); // 函数模板prints2的显式实例化定义 template float prints2&lt;float&gt;(float); // 函数模板prints3的显式实例化声明 // 因为val含有默认实参，所以显式实参表省略了val，但其他地方还是要填该默认实参值 extern template const char prints3&lt;const char&gt;(const char[10]); // 函数模板prints3的显式实例化定义 // 因为val含有默认实参，所以显式实参表省略了val，但其他地方还是要填该默认实参值 template const char prints3&lt;const char&gt;(const char[10]); // 类模板Cls的显式实例化声明 // 因为ty2含有默认实参，所以显式实参表省略了val。 extern template struct Cls&lt;std::string, 48&gt;; // 类模板Cls的显式实例化定义 // 因为ty2含有默认实参，所以显式实参表省略了val。 template struct Cls&lt;std::string, 48&gt;; . 显式实例化的声明和定义要与对应的模板的声明一致。 而且对于同一个模板实例来说，其显式实例化的声明和定义中的模板实参要一致(可以忽略顶层const；对于非类型形参的实参值是相同的或者能隐式转换成同一个值就行)。 . 同一作用域中，显式实例化声明必须要在显式实例化定义前面，否则会出错。 . 当编译器遇到显式实例化声明时，编译器不会在该处生成实例化代码，显式实例化声明只是承诺同作用域中有其对应的显式实例化定义。 . 当编译器遇到显式实例化定义时，编译器就会在该处生成实例化代码。 和隐式实例化不同的是，==显式实例化定义会实例化该模板的所有成员，包括内联的成员函数==。因此，我们用来显式实例化类模板的实参必须能用于该模板的所有成员。 . 对于一个给定的实例化版本，同作用域中可能有多个显式实例化声明，但有且只有一个对应的显式实例化定义。 . 对于显式实例化定义来说，同作用域中如果在显式实例化定义语句之前已经存在对应声明的全部特例化时，则其所有相同声明的显式实例化定义就不会生效，所以此时可以有多个同声明部分的显式实例化定义。 . 当我们==使用模板(隐式实例化)时，编译器会检查同作用域中是否有相同模板实参的显式实例化，如果有，则按照该显式实例化的实例来进行操作，而不是再创建一个新的实例==。 . // Application.cpp // 这些模板类型必须在程序其他位置进行实例化 extern template class Blob&lt;string&gt;; extern template int compare(const int&amp;, const int&amp;); Blob&lt;string&gt; sa1, sa2; // 实例化会出现在其他位置 // Blob&lt;int&gt;及其接受initializer_list的构造函数在本文件中实例化 Blob&lt;int&gt; a1 = {0,1,2,3,4,5,6,7,8,9}; Blob&lt;int&gt; a2(al) ; // 拷贝构造函数在本文件中实例化 int i = compare (a1[0], a2[0] ) ; // 实例化出现在其他位置 // templateBuild.h // 实例化文件必须为每个在其他文件中的显式类型或者函数实例化的声明\\ 提供一个对应的显式实例化定义。 template int compare(const int&amp;, const int&amp;); template class Blob&lt;string&gt;; // 实例化类模板的所有成员 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1054-%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1054-显式实例化"
  },"70": {
    "doc": "模板概念详解",
    "title": "10.6 模板特例化",
    "content": "对于大多数模板来说，通过实例化生成的实例是足够的，但是对于某些特殊的模板实参时，生成的实例可能是不合适的，所以我们有时想编写一些特殊的版本实例来进行一些操作，此时，我们就可以用模板特例化。 . 模板特例化是模板的一种特殊性质，我们可以使用模板特例化来生成一些特殊的模板实例，模板特例化有以下两种形式： . | 全部特例化 | 部分特例化(偏例化) | . 模板特例化都是建立在原始模板的基础上的，所以模板特例化只能用于可见的模板中。 . 关于模板特例化语句的出现位置，有以下规定： . | 对于全部特例化来说，全部特例化语句只能出现在全局作用域和命名空间中，不能出现在其他的局部作用域内。 | 对于部分特例化来说，部分特例化语句还可以出现在类类型和类模板的类体中。 | 与原始模板声明或定义语句的位置关系： . | 和显式实例化一样，除了成员模板，其他模板的特例化的声明语句要与模板定义语句所在的作用域相同，否则出错。 | 而对于成员模板来说： . | 成员模板的全部特例化的声明语句要与其类模板所在的作用域相同，如果该类模板也是成员模板，则在该类模板的类模板，一直到包含其所有类模板的非类模板的作用域，否则出错。 | 成员模板的部分特例化的出现位置只要从模板定义语句所在的位置到包含其所有类模板的非类模板的作用域内的任意位置就行，否则出错。 | . | . | . 模板特例化也可以有声明语句，只要写成特例化定义形式对应的声明语句形式就行。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#106-%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#106-模板特例化"
  },"71": {
    "doc": "模板概念详解",
    "title": "10.61 全部特例化",
    "content": "常见的模板特例化就是全部特例化(template specialization)，全部特例化是指我们可以编写一个特殊版本的实例来对特定的模板实参进行一些操作。 . 要注意全部特例化的本质是一个模板实例，而非模板。 . 全部特例化有两种定义形式： . | template &lt;&gt; 函数或者类的实例化语句 . | template &lt;&gt; 类模板成员的实例化语句 . | . 第1种形式适用于各种模板，而第2种形式只适用于类模板的静态成员、类类型成员和成员模板。 . 第1种形式中： . | 函数或者类的实例化语句是指原始模板中对应的函数或类的实例化语句，其中所有的模板形参都被替换为实参，这些实参也需遵循模板实参的规则。 语句中为所有模板形参都提供实参的方式必须要与隐式实例化方式类似，用显式模板实参表或者模板实参推断来提供(和显式模板实参表或者模板实参推断的用法一样，满足省略实参的条件时也可以不提供实参)。 | . 第2种形式中： . | 第2种形式是只特例化特定成员而不是特例化整个模板。 类模板成员的实例化语句是指该模板的某个成员的实例化语句，就和类类型成员在类外定义一样，我们要在该实例化语句的成员名之前加上该类模板名、尖括号&lt;&gt;包围的模板实参表和作用域运算符::来表示我们是在定义类模板的该特殊实例的成员。 要注意这种形式中，该成员实例化语句中的声明部分(如果是成员模板就是模板声明部分)要与模板中该成员的声明部分一样，否则出错。 . | . 全部特例化也就是代替编译器手动生成一个特殊的实例，和隐式实例化一样，类模板的成员只有在其使用时才被实例化。 . 当我们==定义或声明一个全部特例化时，编译器会检查是否已存在相同声明的实例的定义，如果已存在，则出错；否则就生成该特殊实例==，该特殊实例的生成规则为： . | 对于第1种形式，该特殊实例是按全部特例化中的实例化语句来生成的。 | 对于第2种形式，除了全部特例化所指定的特殊成员，该特殊实例的其他成员是按原始模板的定义语句来生成的；对于该全部特例化语句所指定的成员，则使用该语句中的实例化语句来生成该成员。 | . 所以，我们如果要使用模板的全部特例化时，必须要在全部特例化定义语句之后才行，否则会导致编译出错。 . 一个模板可以有多个不同实例的全部特例化。因此，我们不能定义或声明已有实例的全部特例化实例版本。 . template &lt;class ty, typename ty2&gt; void prints(ty v1, ty2 v2) { cout &lt;&lt; v1 &lt;&lt; \" \" &lt;&lt; v2; } // 函数模板prints的全部特例化 template &lt;&gt; void prints(double num, int multiple) { cout &lt;&lt; num * multiple; } // 调用的是普通实例版本\\ 输出str 15 prints(\"str\", 15); // 调用的是特殊实例版本\\ 输出497.2 prints(45.2, 11); template &lt;class ty&gt; struct Cls { static ty ob; }; // 类模板Cls的第1种全部特例化形式 template &lt;&gt; struct Cls&lt;string&gt; { string ob = \"str\"; void prints() { cout &lt;&lt; ob; } }; // 类模板Cls的第2种全部特例化形式 template &lt;&gt; double Cls&lt;double&gt;::ob = 125.48; // 调用的是普通实例版本 Cls&lt;int&gt; obj; // 调用的是第1种特殊实例版本 Cls&lt;string&gt; obj2; // 调用的是第2种特殊实例版本 Cls&lt;double&gt; obj3; // 错误：普通实例版本没有prints成员 obj.prints(); // 正确：输出str obj2.prints(); // 正确：输出125.48 cout &lt;&lt; obj3.ob; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1061-%E5%85%A8%E9%83%A8%E7%89%B9%E4%BE%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1061-全部特例化"
  },"72": {
    "doc": "模板概念详解",
    "title": "10.62 部分特例化",
    "content": "部分特例化(partial specialization)也叫做偏例化，它只适用于类模板。 . 同一个类模板可以有多个不同的部分特例化。 . 部分特例化是另一种特例化方法，我们可以在特例化时只指定一部分模板形参的实参，或者只指定模板类型形参的一部分而非直接提供一个具体的实参(比如指定成其类型的引用、指针或者常量类型等等，比如T*、&amp;&amp;T、T[]、T(&amp;)[]这样)，或者是类型模板参数包的扩展模式包含其他关键字。 . 只有模板类型形参才可以指定一部分(当然也可以全部指定，也就是提供具体的实参)，指定其他非参数包类型的模板形参时必须要提供具体的实参。 . 也只有类型模板参数包的扩展模式才能包含其他关键字，其他的模板参数包的扩展模式只能含有该参数包名，不能有其他的。 . 部分特例化时，至少要指定一个形参或者类型模板参数包的非只含有包名的扩展，但也不能将模板形参全都指定具体的实参，否则出错。 . 对于没有默认实参的未命名模板形参，则必须要在模板实参表中对该形参指定具体实参，否则部分特例化定义时无法在实参表表示该形参。 . 部分特例化的定义形式为： . template 模板参数列表 模板名 类体; . #include &lt;array&gt; // 原始类模板Base template&lt;typename T, template&lt;class, std::size_t&gt; typename Cls, int N&gt; struct Base; // 类模板Base的第一种部分特例化 template&lt;typename T&gt; struct Base&lt;T, std::array, 6&gt;; // 类模板Base的第二种部分特例化 template&lt;unsigned S, typename T&gt; struct Base&lt;T[S], std::array, 6&gt;; . 部分特例化中的模板参数列表的类型、顺序以及参数名可以与原始模板不一样，也可以有默认实参，如上面类模板Base的第二种部分特例化。 . 部分特例化中的模板参数列表中不能含有默认实参，否则会报错 . #include &lt;array&gt; // 原始类模板Base template&lt;typename T&gt; struct Base; // 错误，模板参数列表的N不能含有默认实参 template&lt;typename T, int N = 6&gt; struct Base&lt;T[N]&gt;; // 正确，类模板Base的部分特例化 template&lt;typename T&gt; struct Base&lt;const T&gt;; . 部分特例化中的显式模板实参表中，必须要按原始模板的形参声明顺序，列出原始模板的所有模板参数(对于有默认实参的形参，可以省略其实参)，列出规则为： . | 对于未指定、只指定部分和扩展的模板形参，则在显式实参表中直接写出该模板形参的名字、指定的部分以及该扩展。 | 对于已指定具体实参的模板形参，则在表中写上该实参。 | . 对于模板参数包来说，在显式模板实参表中如果不指定具体实参给该参数包，则必须要用其扩展形式，因为参数包只有扩展后才能用。 . #include &lt;functional&gt; /** * @brief 用于同调用形式不同实现的函数的比较声明，类似std::function * * @tparam CallableType */ template &lt;typename CallableType&gt; class FunctionDiff; // 包含模板参数包扩展的部分特例化 /** * @brief 抽象基类，用于同调用形式不同实现的函数的比较，使用std::function实现 * * @tparam ResultType 调用形式中的返回类型 * @tparam ArgsTypes 调用形式中的各形参 */ template &lt;typename ResultType, typename... ArgsTypes&gt; class FunctionDiff&lt;ResultType(ArgsTypes...)&gt; { public: virtual void operator()(std::function&lt;ResultType(ArgsTypes ...)&gt;) = 0; virtual ~FunctionDiff() = default; }; . 因为部分特例化就是原始模板的一个重载模板，所以当要生成一个实例时，如果该实例中的每个模板实参与该部分特例化中的显式模板实参表所表示的实参一模一样时(对于类型实参来说，就是要能转换成对应的实参，且转换所需的内容更少，还要该类型实参的主要特性与实例实参相同)，则编译器会优先调用该部分特例化来生成该实例，否则就调用原始模板。 . 对于常量、引用和指针类型等特性，主要特性就是指其常量、引用和指针，对于显式实参表中没有显式标注常量、引用或者指针等特性的类型实参，其主要特性就不是该特性。 . 指向常量对象的非常量指针或引用，其主要特性是指针或者引用，不是常量。 而对于指向非常量或常量对象的常量指针，其主要特性都是常量，而不是指针类型。 . 如果使用模板时已经存在了相同声明的实例，则编译器是不会调用对应的部分特例化来生成实例的。 . template &lt;class ty, typename ty2&gt; struct Cls { ty ob; }; // 类模板Cls的部分特例化 template &lt;typename ty&gt; struct Cls&lt;ty*, string&gt; { string ob = \"str\"; void prints () { cout &lt;&lt; ob; } }; // 调用普通模板来生成实例 Cls&lt;int, string&gt; obj; // 模板实参匹配，所以调用部分特例化模板来生成实例 Cls&lt;int*, string&gt; obj2; // 错误：普通模板的实例中没有prints成员 obj.prints(); // 正确：输出str obj2.prints(); . template &lt;class ty, typename ty2&gt; struct Cls { static void prints() { cout &lt;&lt; \"original\\n\"; } }; // 该部分特例化中的显式实参表的第一个类型实参的主要特性为常量类型 template &lt;class ty, typename ty2&gt; struct Cls&lt;const ty, ty2&gt; { static void prints() { cout &lt;&lt; \"partial spec\\n\"; } }; // 该部分特例化中的显式实参表的第一个类型实参的主要特性为指针类型 template &lt;class ty, typename ty2&gt; struct Cls&lt;ty*, ty2&gt; { static void prints() { cout &lt;&lt; \"partial spec2\\n\"; } }; // 该部分特例化中的显式实参表的第一个类型实参的主要特性为引用类型 template &lt;class ty, typename ty2&gt; struct Cls&lt;ty&amp;, ty2&gt; { static void prints() { cout &lt;&lt; \"partial spec3\\n\"; } }; // 该部分特例化中的显式实参表的第一个类型实参的主要特性为引用类型 template &lt;class ty, typename ty2&gt; struct Cls&lt;const ty&amp;, ty2&gt; { static void prints() { cout &lt;&lt; \"partial spec4\\n\"; } }; int main() { // 第一个实参的主要特性为普通对象，所以调用原始模板\\ 输出original Cls&lt;int, string&gt;::prints(); // 第一个实参的主要特性为常量，第一个偏例化的主要特性与其相同，所以调用该模板\\ 输出partial spec Cls&lt;const int, string&gt;::prints(); // 第一个实参的主要特性为指针，第二个偏例化的主要特性与其相同，所以调用该模板\\ 输出partial spec2 Cls&lt;const int*, string&gt;::prints(); // 第一个实参的主要特性为常量，第一个偏例化的主要特性与其相同，所以调用该模板\\ 输出partial spec Cls&lt;int *const, string&gt;::prints(); // 第一个实参的主要特性为引用，第三偏例化能转换成该实参，且主要特性与其相同，所以调用该模板\\ 输出partial spec3 Cls&lt;int&amp;, string&gt;::prints(); // 第一个实参的主要特性为引用，第三，第四偏例化能转换成该实参，且主要特性与其相同，但第四偏例化转换所需的内容更少，所以调用该模板\\ 输出partial spec4 Cls&lt;const int&amp;, string&gt;::prints(); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1062-%E9%83%A8%E5%88%86%E7%89%B9%E4%BE%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1062-部分特例化"
  },"73": {
    "doc": "模板概念详解",
    "title": "10.7 类模板再探",
    "content": "类模板是可以生成类实例的一种模板。 所以类模板中的类的定义可以包含各种类类型所能拥有的属性，比如有数据、函数以及类类型成员，可以有友元和基类等。 . 所以类模板中不能有任何模板的实例化和全部特例化语句。 . 类模板不是类，它只是一个生成类的蓝图，所以任何需要访问类模板成员的操作都需要通过该模板的实例或者实例的对象来进行。 . 一个类模板的每个实例都形成一个独立的类型。该类型与其他生成的实例的类型都没有关联，也不会对任何其他实例的类型的成员有任何特殊的访问权限。 . 类模板中类的定义与类类型一样，除了接下来所介绍的特性外，其他的都遵循类类型的各种规则。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#107-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%86%8D%E6%8E%A2",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#107-类模板再探"
  },"74": {
    "doc": "模板概念详解",
    "title": "10.71 类模板别名",
    "content": "我们可以定义类型别名，因为类模板的实例也是一个类型，所以我们也可以定义类模板实例的别名。 . template &lt;typename ty&gt; struct OtCls {}; template &lt;class ty, int val, template &lt;typename t&gt; typename temp&gt; struct Cls {}; // typedef定义类型别名 typedef Cls&lt;int, 15, OtCls&gt; Newcls; // using定义类型别名 using Newcls2 = Cls&lt;string, -8, OtCls&gt;; . c++11标准中，我们还可以用using关键字来定义类模板别名(不能用typedef)。 . 使用关键字using定义类模板别名的语句形式为 . template 模板形参表 using 类模板别名 = 类型说明符(可含有类型修饰符); . 定义类模板别名有些类似于类模板的定义： . | 类模板别名定义时的模板形参表和普通模板定义时的模板形参表一样，可以有各种模板形参，可以有默认实参等。 | 等号=右边可以含有类型修饰符，作用于类型说明符。 | 类型说明符可以是普通的类，也可以是类模板的实例。 如果是类模板的实例，则该实例中的实参可以是该别名定义中的模板形参名或者模板形参的特性。 此时该实例对应的实参是由该using语句定义的类模板别名的实例所决定的。 | . 使用关键字using定义的类模板别名是一个含有给定模板形参表的类模板，该类模板所产生的实例也就是语句中等号=右边所对应的类。 . 因为类模板别名也是模板，所以遵循模板的特性，其语句不能在函数或函数模板内，但可以在类或类模板内。 . template &lt;typename ty&gt; struct OtCls {}; template &lt;class ty, int val, template &lt;typename t&gt; typename temp&gt; struct Cls {}; // 模板形参表为&lt;int, typename&gt;的类模板别名Newcls template &lt;int val, typename ty&gt; using Newcls = Cls&lt;ty, val, OtCls&gt;*; // 模板形参表为&lt;typename&gt;的类模板别名Newcls2 template &lt;typename ty&gt; using Newcls2 = const Cls&lt;string, 25, OtCls&gt;; // 等价于\\ Cls&lt;string, 15, OtCls&gt;* n_obj; Newcls&lt;15, string&gt; n_obj; // 等价于\\ Cls&lt;int, 48, OtCls&gt;* n_obj2; Newcls&lt;48, int&gt; n_obj2; // 等价于\\ const &lt;string, 25, OtCls&gt; n2_obj; Newcls2&lt;int&gt; n2_obj; // 等价于\\ const &lt;string, 25, OtCls&gt; n2_obj2; Newcls2&lt;double&gt; n2_obj2; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1071-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%88%AB%E5%90%8D",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1071-类模板别名"
  },"75": {
    "doc": "模板概念详解",
    "title": "10.72 类模板的特性",
    "content": "类模板既有模板的特性，也有类的特性。 . 因为类模板是一个模板，当模板成员或者友元需要使用该模板类型时(比如定义构造函数等)，除了一个例外，我们必须要像类模板的隐式实例化一样提供模板实参表来使用，该实参表的实参要与模板形参一一对应(对于有默认实参的形参，可以省略其实参)。 . 该模板实参表中可以包含以下任意一种(由于未命名形参没有名字，所以其只能用第1种方式)： . | 可以是任何实参，也就是具体的对象、类型或者模板(对应非类型、类型、模板类形参和模板参数包)： 此时该位置的模板类型对应的模板形参的实参就是所给的实参。 | 可以是含有模板形参名的非声明或定义的表达式(比如类型形参的引用，非类型形参与其他表达式的运算等等)或者模板参数包的扩展： 此时该位置的模板类型对应的模板形参的实参还是由该模板的实例所决定。 | . template &lt;class ty, int val, typename ty2 = int&gt; struct Cls { ty mem = ty(); int ins = val; void prints() { // 模板实参表包含实参和模板形参 Cls&lt;int, val + 10&gt; obj; std::cout &lt;&lt; obj.mem + obj.ins &lt;&lt; std::endl; } void prints2() { // 模板实参表包含模板形参和实参 Cls&lt;const ty*, 25&gt; obj2; obj2.mem = \"this is string\"; std::cout &lt;&lt; obj2.mem &lt;&lt; obj2.ins &lt;&lt; std::endl; } }; int main() { Cls&lt;std::string, 105, int&gt; ob; // 输出115 ob.prints(); Cls&lt;char, 105, int&gt; ob2; // 输出this is string 25 ob2.prints2(); return 0; } . 该例外就是： 当我们在模板的作用域内使用该模板类型时，可以不用提供模板实参表，此时编译器会自动帮我们加上模板实参表，每个实参都为对应的形参名(无名的形参就填一个无名标记)。 . template &lt;class ty, int val, typename&gt; struct Cls { ty mem; int ins; // 等价于\\ Cls&lt;ty, val, &lt;unnamed&gt;&gt; prints(); Cls prints(); // 等价于\\ Cls&lt;ty, val, &lt;unnamed&gt;&gt; (ty mem): mem(mem), ins(val) {} Cls(ty mem): mem(mem), ins(val) {} }; . 类模板和类类型一样，其成员和类类型的成员一样，既可以在模板内定义，也可以在模板外定义。 . 和类类型一样，因为类模板的类体也是一个作用域： . | 所以在模板内我们可以直接访问可访问的成员而不需要用模板类型及其对象来访问。 | 当我们在类模板外定义其成员时，我们并不在模板的作用域中，直到成员名遇到类名时才表示进入模板的作用域。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1072-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E6%80%A7",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1072-类模板的特性"
  },"76": {
    "doc": "模板概念详解",
    "title": "10.73 类模板成员的类外定义",
    "content": "类模板的成员可以在类外定义，不过因为是模板的成员，所以类外定义的形式与类类型的不一样。 . 因为是类模板的成员，类模板的每个实例都有其自己版本的成员。因此，类模板的成员具有和所在类模板相同声明的模板形参表。 . 类成员的类外定义的形式为： . template 模板形参表 成员的定义语句(其中包含模板类型) . 定义在类模板之外的成员必须以关键字template开始，后接类模板形参表，该形参表中的形参名可以与其模板的形参名不一样。 但是该形参表必须要与类模板的形参表的数量，类型和顺序一致(可以忽略顶层const)，而且该形参表中每个形参都必须要有形参名，且都不能有默认实参。 . 与往常一样，当我们在类模板外定义一个成员时，也必须说明该成员属于哪个模板类型。因此需要在类外定义语句的成员名之前加上模板类型和作用域运算符::。 因为类模板外定义不在模板的作用域中，所以使用该模板类型时必须要提供模板实参表，且该模板实参表的实参要与该成员的模板形参表中的形参一模一样(不能是具体的实参或者形参的特性)。 . 使用了模板参数的模板成员在类外定义时可以直接在模板形参表之后使用该模板参数的标识符。 . #include &lt;iostream&gt; #include &lt;string&gt; template &lt;class ty, int val, typename = int&gt; struct Cls { // 静态数据成员类内声明，使用了模板参数 static const ty mem; // 静态数据成员类内声明 static double dou; // 非静态函数成员类内声明 void empty(int value); // 非静态常量函数成员类内声明，使用了模板参数 int add(ty val1, int val2) const; // 静态constexpr函数成员类内声明，使用了模板参数 static constexpr ty prints(); }; // 类模板静态数据成员的类外定义 // 可以直接在模板形参表之后使用模板参数的标识符。 template &lt;typename t, int v, class t2&gt; const t Cls&lt;t, v, t2&gt;::mem = t{}; // 类模板静态数据成员的类外定义 template &lt;typename t2, int v2, class t22&gt; double Cls&lt;t2, v2, t22&gt;::dou = 3.14; // 类模板非静态函数成员的类外定义 template &lt;typename t, int v, class t2&gt; void Cls&lt;t, v, t2&gt;::empty(int) {} // 类模板非静态常量函数成员的类外定义 // 可以直接在模板形参表之后使用模板参数的标识符。 template &lt;typename t, int v, class t2&gt; int Cls&lt;t, v, t2&gt;::add(t, int) const { std::cout &lt;&lt; \"external add\\n\"; return 1; } // 类模板静态constexpr函数成员的类外定义 // 可以直接在模板形参表之后使用模板参数的标识符。 template &lt;typename t, int v, class t2&gt; constexpr t Cls&lt;t, v, t2&gt;::prints() { std::cout &lt;&lt; \"external print\\n\"; return t{}; } int main() { Cls&lt;std::string, 105&gt; ob; // 输出external add ob.add(\"string\", 0); // 输出external print ob.prints(); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1073-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1073-类模板成员的类外定义"
  },"77": {
    "doc": "模板概念详解",
    "title": "10.74 成员模板",
    "content": "一个类，无论是类类型还是类模板，都可以包含本身是模板的成员。这种成员被称为成员模板(member template)。 . 根据模板的类型，成员模板也分为两种： . | 成员函数模板 | 成员类模板 | . 成员函数模板的函数不能是虚函数，但可以是静态、常量等函数。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1074-%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1074-成员模板"
  },"78": {
    "doc": "模板概念详解",
    "title": "10.741 成员模板的定义",
    "content": "根据成员模板在类类型和类模板的区别，成员模板的定义分为两种： . | 类类型的成员模板定义 | 类模板的成员模板定义 | . 不管是哪一种成员模板，其定义与其对应的成员定义一样，既可以在类内定义，也可以在类外定义，也遵循成员定义的各种规则。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10741-%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10741-成员模板的定义"
  },"79": {
    "doc": "模板概念详解",
    "title": "10.7411 类类型的成员模板定义",
    "content": "对于在类类型中的成员模板，其定义与类类型的成员定义一样。 . 以下是类类型中的成员模板的类内定义： . struct Cls { string str = \"str\"; int ins = 8; // 类类型中的成员函数模板prints的类内定义 template &lt;typename cfy&gt; static void prints(cfy obj) { cout &lt;&lt; obj; } // 类类型中的成员类模板NestCls的类内定义 template &lt;class ccy, int ccval&gt; struct NestCls { ccy mem; static void Nprints() { cout &lt;&lt; ccval; } }; }; . 和类类型的类外成员定义一样，需要用作用域运算符表明定义的是类的成员，且还必须提供该成员模板自己的模板形参表(该模板形参表与类模板普通成员的类外定义中的模板形参表性质一样，有不能有默认实参等性质)。 . 以下是类类型中的成员模板的类外定义： . struct Cls { string str = \"str\"; int ins = 8; // 类类型中的成员函数模板prints的类内声明 template &lt;typename cfy&gt; static void prints(cfy obj); // 类类型中的成员类模板NestCls的类内声明 template &lt;class ccy, int ccval&gt; struct NestCls; }; // 类类型中的成员函数模板prints的类外定义 template &lt;typename cfy&gt; void Cls::prints(cfy obj) { cout &lt;&lt; obj; } // 类类型中的成员类模板NestCls的类外定义 template &lt;class ccy, int ccval&gt; struct Cls::NestCls { ccy mem; // 类类型中的成员类模板NestCls的函数成员Nprints的类内声明 static void Nprints(); }; // 类类型中的成员类模板NestCls的函数成员Nprints的类外定义 template &lt;class ccy, int ccval&gt; void Cls::NestCls&lt;ccy, ccval&gt;::Nprints() { cout &lt;&lt; ccval; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#107411-%E7%B1%BB%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#107411-类类型的成员模板定义"
  },"80": {
    "doc": "模板概念详解",
    "title": "10.7412 类模板的成员模板定义",
    "content": "成员模板也是模板，定义形式和其对应类型的模板定义形式一样，类模板的成员模板和其所在的类模板之前各有自己的独立的模板形参。 . 成员模板的模板形参名不能与所在类模板的模板形参名相同，否则出错。 . 以下是类模板中的成员模板的类内定义： . template &lt;class ty, typename ty2, int val&gt; struct Cls { ty mem; ty2 mem2; int ins = val; // 成员函数模板prints的类内定义 template &lt;typename cfy&gt; static void prints(cfy obj) { cout &lt;&lt; obj; } // 成员类模板NestCls的类内定义 template &lt;class ccy, int ccval&gt; struct NestCls { ccy mem; static void Nprints() { cout &lt;&lt; ccval; } }; }; . 因为成员模板也是模板，所以对于类模板的成员模板来说，该成员模板在类外定义时，既要提供所在类模板相同声明的模板形参表，也要提供该成员模板自己的模板形参表(该模板形参表与类模板普通成员的类外定义中的模板形参表性质一样，有不能有默认实参等性质)。 . 以下是类模板中的成员模板的类外定义： . template &lt;class ty, typename ty2, int val&gt; struct Cls { ty mem; ty2 mem2; int ins = val; // 成员函数模板prints的类内声明 template &lt;typename cfy&gt; static void prints(cfy obj); // 成员类模板NestCls的类内声明 template &lt;class ccy, int ccval&gt; struct NestCls; }; // 成员函数模板prints的类外定义 template &lt;class ty, typename ty2, int val&gt; template &lt;typename cfy&gt; void Cls&lt;ty, ty2, val&gt;::prints(cfy obj) { cout &lt;&lt; obj; } // 成员类模板NestCls的类外定义 template &lt;class ty, typename ty2, int val&gt; template &lt;class ccy, int ccval&gt; struct Cls&lt;ty, ty2, val&gt;::NestCls { ccy mem; // 成员类模板NestCls的函数成员Nprints的类内声明 static void Nprints(); }; // 成员类模板NestCls的函数成员Nprints的类外定义 template &lt;class ty, typename ty2, int val&gt; template &lt;class ccy, int ccval&gt; void Cls&lt;ty, ty2, val&gt;::NestCls&lt;ccy, ccval&gt;::Nprints() { cout &lt;&lt; ccval; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#107412-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#107412-类模板的成员模板定义"
  },"81": {
    "doc": "模板概念详解",
    "title": "10.742 成员模板的实例化",
    "content": "成员模板的实例化和普通模板的实例化一样，既可以隐式实例化，也可以显式实例化，同时也遵循模板显式实例化的各种规则。 . 根据显式实例化的规则，显式实例化语句不能出现在类体中。 . 对于类模板的成员模板来说，因为成员模板是类模板的成员，所以在实例化时必须还要提供该成员模板所在类模板的模板实参。 . 以下为成员模板的隐式实例化： . int main() { // 类类型Cls的成员函数模板prints的隐式实例化\\ 为模板实参推断 Cls::prints(\"str\"); // 类模板Cls的成员函数模板prints的隐式实例化\\ 为模板实参推断 Cls&lt;int, string, 8&gt;::prints(\"str\"); // 类类型Cls的成员类模板NestCls的隐式实例化\\ 为使用显式模板实参表 Cls::NestCls&lt;double, 10&gt;::Nprints(); // 类模板Cls的成员类模板NestCls的隐式实例化\\ 为使用显式模板实参表 Cls&lt;int, string, 8&gt;::NestCls&lt;double, 10&gt;::Nprints(); return 0; } . 以下为成员模板的显式实例化： . // 类类型Cls的成员函数模板prints的显式实例化声明 extern template void Cls::prints(string); // 类类型Cls的成员函数模板prints的显式实例化定义 template void Cls::prints(string); // 类模板Cls的成员函数模板prints的显式实例化声明 extern template void Cls&lt;int, string, 8&gt;::prints(string); // 类模板Cls的成员函数模板prints的显式实例化定义 template void Cls&lt;int, string, 8&gt;::prints(string); // 类类型Cls的成员类模板NestCls的显式实例化声明 extern template struct Cls::NestCls&lt;double, 10&gt;; // 类类型Cls的成员类模板NestCls的显式实例化定义 template struct Cls::NestCls&lt;double, 10&gt;; // 类模板Cls的成员类模板NestCls的显式实例化声明 extern template struct Cls&lt;int, string, 8&gt;::NestCls&lt;double, 10&gt;; // 类模板Cls的成员类模板NestCls的显式实例化定义 template struct Cls&lt;int, string, 8&gt;::NestCls&lt;double, 10&gt;; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10742-%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10742-成员模板的实例化"
  },"82": {
    "doc": "模板概念详解",
    "title": "10.743 成员模板的特例化",
    "content": "成员模板的特例化和普通模板的特例化一样，既可以全部特例化，也可以部分特例化，同时也遵循模板特例化的各种规则。 . 根据模板特例化的规则，全部特例化语句不能出现在类体中，而部分特例化可以出现在类体中。 . 以下是类类型中的成员模板的特例化定义： . struct Cls { // 类类型Cls的成员函数模板prints的定义 template &lt;typename cfy&gt; static void prints(cfy obj) { cout &lt;&lt; obj &lt;&lt; \"\\n\"; } // 类类型Cls的成员类模板NestCls的定义 template &lt;class ccy, int ccval&gt; struct NestCls { ccy mem; static void Nprints() { cout &lt;&lt; ccval &lt;&lt; \"\\n\"; } }; // 类类型Cls的成员类模板NestCls的部分特例化的类内定义 template &lt;class ccy&gt; struct NestCls&lt;ccy*, 15&gt; { static void Nprints() { cout &lt;&lt; \"internal partial spec\\n\"; } }; }; // 类类型Cls的成员函数模板prints的全部特例化定义 template &lt;&gt; void Cls::prints(int obj) { cout &lt;&lt; obj &lt;&lt; \" spec\\n\"; } // 类类型Cls的成员类模板NestCls的第1种形式的全部特例化的定义 template &lt;&gt; struct Cls::NestCls&lt;double, 15&gt; { static void Nprints() { cout &lt;&lt; \"spec No.1\\n\"; } }; // 类类型Cls的成员类模板NestCls的第2种形式的全部特例化的定义 template &lt;&gt; void Cls::NestCls&lt;string, 15&gt;::Nprints() { cout &lt;&lt; \"spec No.2\\n\"; } // 类类型Cls的成员类模板NestCls的部分特例化的类外定义 template &lt;class ccy, int ccval&gt; struct Cls::NestCls&lt;ccy&amp;, ccval&gt; { static void Nprints() { cout &lt;&lt; \"external partial spec\\n\"; } }; int main() { // 调用成员函数模板prints的普通实例\\ 输出3.5 Cls::prints(3.5); // 调用成员函数模板prints的特例化实例\\ 输出3 spec Cls::prints(3); // 调用成员类模板NestCls的普通实例\\ 输出20 Cls::NestCls&lt;string, 20&gt;::Nprints(); // 调用成员类模板NestCls的第1种形式的全部特例化实例\\ 输出spec No.1 Cls::NestCls&lt;double, 15&gt;::Nprints(); // 调用成员类模板NestCls的第2种形式的全部特例化实例\\ 输出spec No.2 Cls::NestCls&lt;string, 15&gt;::Nprints(); // 调用成员类模板NestCls的类内定义的部分特例化生成的实例\\ 输出internal partial spec Cls::NestCls&lt;string*, 15&gt;::Nprints(); // 调用成员类模板NestCls的类外定义的部分特例化生成的实例\\ 输出external partial spec Cls::NestCls&lt;string&amp;, 15&gt;::Nprints(); return 0; } . 对于类模板的成员模板来说，因为成员模板是类模板的成员，所以在类外特例化时必须还要提供该成员模板所在类模板的模板实参。 . 因为类模板也是模板，所以在声明或定义该类模板的成员模板的全部特例化语句时，该类模板也必须全部特例化，且其要用全部特例化的第2种形式，否则出错。 . 以下是类模板中的成员模板的特例化定义： . template &lt;typename ty, int val&gt; struct Cls { // 类模板Cls的成员函数模板prints的定义 template &lt;typename cfy&gt; static void prints(cfy obj) { cout &lt;&lt; obj &lt;&lt; \"\\n\"; } // 类模板Cls的成员类模板NestCls的定义 template &lt;class ccy, int ccval&gt; struct NestCls { ccy mem; static void Nprints() { cout &lt;&lt; ccval &lt;&lt; \"\\n\"; } }; // 类模板Cls的成员类模板NestCls的部分特例化的类内定义 template &lt;class ccy&gt; struct NestCls&lt;ccy*, 15&gt; { static void Nprints() { cout &lt;&lt; \"internal partial spec\\n\"; } }; }; // 类模板Cls的成员函数模板prints的全部特例化定义 template &lt;&gt; template &lt;&gt; void Cls&lt;int, 15&gt;::prints(int obj) { cout &lt;&lt; obj &lt;&lt; \" spec2\\n\"; } // 类模板Cls的成员类模板NestCls的第1种形式的全部特例化的定义 template &lt;&gt; template &lt;&gt; struct Cls&lt;int, 15&gt;::NestCls&lt;double, 15&gt; { static void Nprints() { cout &lt;&lt; \"spec No.1\\n\"; } }; // 类模板Cls的成员类模板NestCls的第2种形式的全部特例化的定义 template &lt;&gt; template &lt;&gt; void Cls&lt;int, 15&gt;::NestCls&lt;string, 15&gt;::Nprints() { cout &lt;&lt; \"spec No.2\\n\"; } // 类模板Cls的成员类模板NestCls的部分特例化的类外定义 template &lt;typename ty, int val&gt; template &lt;class ccy, int ccval&gt; struct Cls&lt;ty, val&gt;::NestCls&lt;ccy&amp;, ccval&gt; { static void Nprints() { cout &lt;&lt; \"external partial spec\\n\"; } }; int main() { // 调用成员函数模板prints的普通实例\\ 输出3.5 Cls&lt;int, 15&gt;::prints(3.5); // 调用成员函数模板prints的特例化实例\\ 输出3 spec Cls&lt;int, 15&gt;::prints(3); // 调用成员类模板NestCls的普通实例\\ 输出20 Cls&lt;int, 15&gt;::NestCls&lt;string, 20&gt;::Nprints(); // 调用成员类模板NestCls的第1种形式的全部特例化实例\\ 输出spec No.1 Cls&lt;int, 15&gt;::NestCls&lt;double, 15&gt;::Nprints(); // 调用成员类模板NestCls的第2种形式的全部特例化实例\\ 输出spec No.2 Cls&lt;int, 15&gt;::NestCls&lt;string, 15&gt;::Nprints(); // 调用成员类模板NestCls的类内定义的部分特例化生成的实例\\ 输出internal partial spec Cls&lt;int, 15&gt;::NestCls&lt;string*, 15&gt;::Nprints(); // 调用成员类模板NestCls的类外定义的部分特例化生成的实例\\ 输出external partial spec Cls&lt;int, 15&gt;::NestCls&lt;string&amp;, 15&gt;::Nprints(); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10743-%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E4%BE%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10743-成员模板的特例化"
  },"83": {
    "doc": "模板概念详解",
    "title": "10.75 类模板与友元",
    "content": "之前我们在介绍类类型时谈到过友元，友元不仅可以是函数或者类，还可以是模板。 . 类模板可以有任何类类型所具有的属性，所以类模板也可以拥有友元。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1075-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#1075-类模板与友元"
  },"84": {
    "doc": "模板概念详解",
    "title": "10.751 模板实例友元",
    "content": "对于各种模板实例友元来说，和普通友元一样，遵循各种友元声明的规则： . | 函数模板实例友元的声明规则和友元函数相同，所以函数模板实例友元可以是在定义类的作用域中不存在的实体。 | 类模板实例友元的声明规则和友元类相同，所以类模板实例友元必须是定义类所能访问到的。 | . 对于类模板中的普通友元(包括内置类型和类类型友元)和模板实例友元来说，该类模板的所有实例都将视它们为友元。 . 我们也可以将类模板的模板类型形参以及模板类形参的实例声明为友元，其访问权限和类模板中的普通友元一样。 . // 类类型Fcls的声明 struct Fcls; // 类模板Cls的定义 template &lt;class ty, int val&gt; class Cls { // 函数prints为类Cls的友元 friend void prints(); // 类型形参ty为类Cls的友元 friend ty; // 类类型Fcls为类Cls的友元 friend Fcls; int ins = val; string str = \"strCls\"; ty mem = ty(); public: static void cprint() { ty::fprints(); } }; // 函数prints的定义 void prints() { Cls&lt;string, 35&gt; obj; cout &lt;&lt; obj.str &lt;&lt; \" \" &lt;&lt; obj.ins &lt;&lt; \"\\n\"; } // 类类型Fcls的定义 struct Fcls { static void fprints() { Cls&lt;int, 5&gt; obj; cout &lt;&lt; obj.str &lt;&lt; \" \" &lt;&lt; obj.ins &lt;&lt; \"\\n\"; } }; int main() { // 输出strCls 35 prints(); // 输出strCls 5 Fcls::fprints(); // 输出strCls 5 Cls&lt;Fcls, 74&gt;::cprint(); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10751-%E6%A8%A1%E6%9D%BF%E5%AE%9E%E4%BE%8B%E5%8F%8B%E5%85%83",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10751-模板实例友元"
  },"85": {
    "doc": "模板概念详解",
    "title": "10.752 模板友元",
    "content": "和模板实例友元一样，模板友元也遵循各种友元声明的规则： . | 函数模板友元的声明规则和友元函数相同，所以函数模板友元可以是在定义类的作用域中不存在的实体。 | 类模板友元的声明规则和友元类相同，所以类模板友元必须是定义类所能访问到的。 | . 模板友元的声明语句和普通模板的声明语句类似，为： . template 模板参数列表 friend 函数或类的声明语句 . 我们还可以声明类模板的函数成员、类类型成员和成员模板为友元，该友元的声明和它们在类模板的类外声明类似，规则也一样，需要写上所在类模板的形参表、关键字friend和类模板类型以及作用域运算符::。 . // 类模板Fcls的定义 template &lt;class ty, int val&gt; struct Fcls { static void fprints(); template &lt;class cty&gt; struct Nest; }; class Cls { // 函数模板prints为类Cls的友元 template &lt;typename ty, int val&gt; friend void prints(ty = val); // 类模板Fcls为类Cls的友元 template &lt;class ty, int val&gt; friend struct Fcls; // 类模板Fcls的成员函数fprints为类Cls的友元 template &lt;class ty, int val&gt; friend void Fcls&lt;ty, val&gt;::fprints(); // 类模板Fcls的成员类模板Nest为类Cls的友元 template &lt;class ty, int val&gt; template &lt;class cty&gt; friend struct Fcls&lt;ty, val&gt;::Nest; int ins = 76; string str = \"strCls\"; }; // 函数模板prints的定义 template &lt;typename ty, int val&gt; void prints(ty v1) { Cls obj; cout &lt;&lt; obj.str &lt;&lt; \" \" &lt;&lt; v1 &lt;&lt; \"\\n\"; } // 类模板Fcls的成员函数fprints的类外定义 template &lt;class ty, int val&gt; void Fcls&lt;ty, val&gt;::fprints() { Cls obj; cout &lt;&lt; obj.ins &lt;&lt; \"\\n\"; } // 类模板Fcls的成员类模板Nest的类外定义 template &lt;class ty, int val&gt; template &lt;class cty&gt; struct Fcls&lt;ty, val&gt;::Nest { static void fnprints() { Cls obj; cout &lt;&lt; obj.ins &lt;&lt; \" \" &lt;&lt; obj.str &lt;&lt; \"\\n\"; } }; . 模板友元的访问权限为： . | 对于类类型的模板友元来说，该模板友元的所有实例都是该类类型的友元。 | 对于类模板的模板友元来说，该类模板的所有实例都将视其模板友元的任意实例为友元。 | . int main() { // 输出strCls 6 prints&lt;int, 6&gt;(); // 输出76 Fcls&lt;int, 39&gt;::fprints(); // 输出76 strCls Fcls&lt;double, 9&gt;::Nest&lt;int&gt;::fnprints(); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10752-%E6%A8%A1%E6%9D%BF%E5%8F%8B%E5%85%83",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#10752-模板友元"
  },"86": {
    "doc": "模板概念详解",
    "title": "10.8 模板重载",
    "content": "函数模板可以被另一个相同名字的模板或者一个普通非模板同名函数重载。只要它们之间的模板形参表或者函数形参表不一致就行。 . 不过类模板不支持重载，所以类名相同但模板形参表不同的模板会导致重复定义。 . 类模板的部分特例化虽然是模板，但这不是重载，部分特例化与重载有很大区别，部分特例化不支持随意拓展或者改变原始的模板形参表。 . 含有函数模板的函数匹配和普通函数的匹配规则类似，只有某些不同，以下是含有函数模板的函数匹配流程： . | 对于一个函数调用，其候选函数不仅仅是在调用点可访问的普通同名函数，还包括所有的可行的函数模板实例。 可行的函数模板实例是指： 编译器根据实参类型，推断所有在调用点可访问的同名模板所对应的函数实例。并在其中排除掉所有的不可行函数实例，最后留下的都是可行的函数实例，也就是可行的函数模板实例。 编译器只是推断实参所对应的实例，而不是真正的生成实例。 . | 与往常一样，编译器会排除所有不可行的普通同名函数，然后对所有可行函数(包括普通函数和模板所推断的函数)按形参类型进行优先级排序。 | 与往常一样，如果有且只有一个最佳函数，则调用该函数；但如果有多个匹配度同样好的函数，那么当这些同样好的函数中有且只有一个非模板函数，则调用该函数；否则，此调用无匹配或者有歧义。 | . // 对于调用prints(&amp;ins)，该模板对应的函数实例声明为：\\ void prints(const int* &amp;); template &lt;class ty&gt; void prints(const ty &amp;obj) { cout &lt;&lt; \"Temp func No.1\\n\"; } // 对于调用prints(&amp;ins)，该模板对应的函数实例声明为：\\ void prints(int*); template &lt;class ty&gt; void prints(ty* obj) { cout &lt;&lt; \"Temp func No.2\\n\"; } // 普通函数 void prints(const int* obj) { cout &lt;&lt; \"Func No.1\\n\"; } int main() { int ins = 15; // 最佳函数的声明为\\ void prints(int*);\\ 所以就调用template &lt;class ty&gt; void prints(ty* obj)模板\\ 输出Temp func No.2 prints(&amp;ins); return 0; } . // 对于调用prints(&amp;ins)，该模板对应的函数实例声明为：\\ void prints(const int* &amp;); template &lt;class ty&gt; void prints(const ty &amp;obj) { cout &lt;&lt; \"Temp func No.1\\n\"; } // 对于调用prints(&amp;ins)，该模板对应的函数实例声明为：\\ void prints(int*); template &lt;class ty&gt; void prints(ty* obj) { cout &lt;&lt; \"Temp func No.2\\n\"; } // 普通函数 void prints(int* obj) { cout &lt;&lt; \"Func No.1\\n\"; } int main() { int ins = 15; // 最佳函数的声明为\\ void prints(int*);\\ 有两个函数满足该声明，其中一个是普通函数，所以调用普通函数的版本\\ 输出Func No.1 prints(&amp;ins); return 0; } . 模板匹配时如果出现歧义，但又需要调用函数模板生成的实例，则可以在调用时显式指定一个空的模板列表，来表示调用函数模板的实例。 . #include &lt;iostream&gt; // 取最大值 int Max(int a, int b) { std::cout &lt;&lt; \"this is notemplate function\" &lt;&lt; std::endl; return b &lt; a ? a : b; } // 取两个相同类型对象的最大值 template&lt;typename T&gt; T Max(T a, T b) { std::cout &lt;&lt; \"this is template function\" &lt;&lt; std::endl; return b &lt; a ? a : b; } int main() { // 最佳匹配为int(int, int)，但非模板函数优先级更高，所以调用非模板函数 // 输出this is notemplate function double dou = Max(15,87); // 最佳匹配为int(int, int)，但是由于显式指定了一个空的模板列表 // 因此只匹配模板函数实例 // 输出this is template function dou = Max&lt;&gt;(15,87); return 0; } . 对于含有模板参数包的函数模板来说，如果某些重载函数中含有函数参数包，不管是显式提供实参表还是进行模板实参推断，对于所有的可行模板实例来说，没有函数参数包的模板实例优先级最高，其次是含有其他非函数参数包的形参最多的模板实例，以此类推，只含有函数参数包的模板实例优先级最低。 . #include &lt;iostream&gt; #include &lt;string&gt; template &lt;typename ty&gt; void prints(ty obj) { std::cout &lt;&lt; \"common\\n\"; } template &lt;class ty, typename ...tys&gt; void prints(ty obj, tys... objs) { std::cout &lt;&lt; \"omission\\n\"; } template &lt;class ty, class ty2, typename ...tys&gt; void prints(ty obj, ty2 obj2, tys... objs) { std::cout &lt;&lt; \"omission2\\n\"; } template &lt;class ty, class ty2, class ty3, typename ...tys&gt; void prints(ty obj, ty2 obj2, ty3 obj3, tys... objs) { std::cout &lt;&lt; \"omission3\\n\"; } int main() { // 都输出common prints(45); prints&lt;double&gt;(31.1); // 都输出omission2 prints(45, \"str\"); prints&lt;int, double&gt;(45, -0.15); // 都输出omission3 prints(45, \"str\", 23.4); prints&lt;std::string, int, double&gt;(\"str\", 45, 23.4); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#108-%E6%A8%A1%E6%9D%BF%E9%87%8D%E8%BD%BD",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html#108-模板重载"
  },"87": {
    "doc": "模板概念详解",
    "title": "模板概念详解",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html",
    
    "relUrl": "/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html"
  },"88": {
    "doc": "第十一章 派生类类型",
    "title": "第十一章 派生类类型",
    "content": "第11章介绍了C++其他的派生类类型：枚举类型和共用体类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/index.html",
    
    "relUrl": "/guide_files/chap11/index.html"
  },"89": {
    "doc": "派生类类型概念详解",
    "title": "11.1 枚举类型",
    "content": "枚举类型(enumeration)使我们可以将一组整型常量组织在一起。和类类型一样，每个枚举类型定义的是一种新的类型。每种定义的枚举类型都是属于字面值类型。 . C++包含两种枚举： . | 限定作用域 | 不限定作用域的 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#111-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#111-枚举类型"
  },"90": {
    "doc": "派生类类型概念详解",
    "title": "11.11 枚举类型的定义",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#1111-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#1111-枚举类型的定义"
  },"91": {
    "doc": "派生类类型概念详解",
    "title": "11.111 枚举类型的定义形式",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#11111-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#11111-枚举类型的定义形式"
  },"92": {
    "doc": "派生类类型概念详解",
    "title": "11.1111 限定作用域的枚举类型的定义形式",
    "content": "C++11新标准引入了限定作用域的枚举类型(scoped enumeration) 声明限定作用域的枚举类型的一般语句形式是： . enum class/struct 枚举类型名(可选 :成员类型说明符) (可选 {枚举成员列表}); . 如果加上后面的枚举成员列表就是定义，不加则只是声明。 . // 我们定义了一个名为open_modes的枚举类型 // 它包含三个枚举成员：input、output 和 append。 enum class open_modes {input, output, append}; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#111111-%E9%99%90%E5%AE%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#111111-限定作用域的枚举类型的定义形式"
  },"93": {
    "doc": "派生类类型概念详解",
    "title": "11.1112 不限定作用域的枚举类型的定义形式",
    "content": "定义不限定作用域的枚举类型的一般语句形式和限定作用域类似，只需要省略关键字class或struct： . 不限定作用域的枚举类型的定义： . enum (可选 枚举类型名) (可选 :成员类型说明符) {枚举成员列表}; . 不限定作用域的枚举类型的声明： . enum 枚举类型名 : 成员类型说明符; . 如果enum是未命名的，则我们只能在定义该enum时定义它的对象。和类的定义类似，我们需要在enum定义的右侧花括号和最后的分号之间提供逗号分隔的声明列表。 . 枚举类型不是对象，所以枚举类型的定义中不能加各种类型修饰符。 . 不能只声明未命名的不限定作用域的枚举类型而不定义。 . 在同一个作用域内，所有不限定作用域的枚举类型中不能有同名的枚举成员，每个枚举成员的成员名必须唯一，否则会导致重复定义的错误 . C++11新标准中，我们可以只声明enum类型而不定义，但是声明enum时必须指定其成员的类型，枚举类型的成员类型必须为非字符和布尔的整型变量。 . // 不限定作用域的枚举类型的前置声明 enum intValues; // 错误: 不限定作用域的枚举类型，必须要指定其成员类型。 enum intValues2: unsigned long long; // 正确: 已指定成员类型的不限定作用域枚举类型。 enum class open_modes; // 正确: 限定作用域的枚举类型可以使用默认成员类型int。 . 和其他声明语句一样，enum的声明和定义必须严格匹配，因此所有的声明和定义必须对该enum是限定作用域的还是不限定作用域的保持一致，不能声明两个同名不同限定作用域的枚举类型 . // 错误: 所有的声明和定义必须对该enum是限定作用域的还是不限定作用域的保持一致。 enum class intValues; enum intValues; // 错误: intValues已经被声明成限定作用域的enum。 enum intValues: long; // 错误: intValues已经被声明成int。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#111112-%E4%B8%8D%E9%99%90%E5%AE%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#111112-不限定作用域的枚举类型的定义形式"
  },"94": {
    "doc": "派生类类型概念详解",
    "title": "11.112 枚举成员",
    "content": "枚举类型中的枚举成员都是constexpr的非字符和布尔的整型变量，且每个枚举成员的类型都一样。 默认情况下，限定作用域的枚举成员类型为int。而不限定作用域的枚举成员没有默认类型，只知道成员的类型足够大，肯定能够容纳枚举值。 . 不限定作用域的枚举成员的类型为其中枚举成员尺寸最大的类型。其中的枚举成员没有显式赋值时默认为int型。 . 我们可以在声明枚举类型的语句中显式指定枚举类型中的成员类型(必须为非字符和布尔的整型变量)，语句形式为： . | enum class/struct 枚举类型名: 成员类型说明符 (可选：{枚举成员列表}); . | enum (可选：枚举类型名): 成员类型说明符 {枚举成员列表}; . | . 枚举类型中的每个枚举成员都代表着一个整型值，也叫做枚举值。 一个枚举类型中的枚举值不一定唯一，也就是类型中不同枚举成员可以是同一个整型值。 . 默认情况下，一个枚举类型中的每个枚举成员的枚举值从0开始，从左到右，枚举值依次加1。 . 我们也能在定义枚举类型的语句中为一个或几个枚举成员显式指定其枚举值，显式指定的==枚举值必须是常量表达式==，且其类型必须要为该枚举类型中的成员类型或者能隐式转换成成员类型。如果我们提供的值超出了该成员类型所能容纳的范围，将引发程序错误。 . 如果我们只提供了某些枚举成员的枚举值，则没有显式指定值的枚举成员的值为上一个枚举成员的值加1。 . enum class intTypes { charTyp = 8, shortTyp = 16, intTyp = 16, longTyp = 32, long_longTyp = 64 }; enum intValues : unsigned long long { charTyp = 255, shortTyp = 65535, intTyp = 65535, longTyp = 4294967295UL, long_longTyp = 18446744073709551615ULL}; . 如果枚举对象没有显式初始化，则该对象的枚举值是未定义的，所以最好在定义时显式进行初始化。 . enum class EnumType { mem1 = 2, mem2 = -48, mem3 = 4 }; enum class EnumType2 { mem21 = 0, mem22 = -1, mem23 = 0 }; EnumType obj; EnumType2 obj2; int main() { // obj值未定义 std::cout &lt;&lt; (obj == EnumType::mem1); // obj2值未定义 std::cout &lt;&lt; (obj2 == EnumType2::mem21); } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#11112-%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#11112-枚举成员"
  },"95": {
    "doc": "派生类类型概念详解",
    "title": "11.12 枚举类型的使用",
    "content": "在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，所以在该枚举类外是不可直接访问的。要想访问限定作用域的枚举类成员，要用该类名加作用域运算符来访问 . 枚举类类名::成员名 . 而不限定作用域的枚举类型中的枚举成员在类本身的作用域中可以直接访问，不需要用作用域运算符来访问(当然也可以用) . enum color { red, yellow, green}; // 不限定作用域的枚举类型 enum stoplight {red, yellow, green}; // 错误：重复定义了枚举成员 enum class peppers {red, yellow, green}; // 正确：枚举成员被隐藏了 color eyes = green; //正确:不限定作用域的枚举类型的枚举成员位于有效的作用域中 //错误：peppers的枚举成员不在有效的作用域中 // color::green在有效的作用域中，但是类型错误 peppers p = green; // 正确：允许显式地访问枚举成员 color hair = color::red; // 正确：使用pappers的red peppers p2 = peppers::red; . 对于有名字的枚举类型，我们可以 . | 将一个enum类型作为switch语句的表达式，而将枚举值作为case标签。 | 定义并初始化该类型的对象，还能为该对象赋值，但必须使用该类型的枚举成员来为其初始化或赋值(对于没有显式初始化的枚举对象，执行默认初始化)。 | 对于不限定作用域的枚举类型(限定作用域的枚举类型不行)来说，其对象或枚举成员可以用在所有需要整型常量表达式的地方，其对象或枚举成员将会自动地转换为整型常量表达式。 注意：整型常量表达式或整型变量都不能隐式转换为枚举类型的对象（无论是限定作用域还是不限定的），只能显式转换。 . | . enum color { red, yellow, green}; // 不限定作用域的枚举类型 enum class peppers {red, yellow, green}; // 限定作用域的枚举类型 int i = color::red; // 正确：不限定作用域的枚举类型的枚举成员隐式地转换成int int j = peppers::red; // 错误：限定作用域的枚举类型不会进行隐式转换 color om = 2; // 错误：2不属于类型color，不能隐式转换为类型color om = color::green; // 正确：green是color的一个枚举成员 om = static_cast&lt;color&gt;(1); // 正确：整型表达式1被转换为枚举成员yellow。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#1112-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#1112-枚举类型的使用"
  },"96": {
    "doc": "派生类类型概念详解",
    "title": "11.2 共用体类型",
    "content": "共用体类型也叫做联合(union)类型，它是一种特殊的类型。 共用体类型和类类型很相似，可以含有除了引用类型的数据、任意函数(包括构造函数和析构函数)和任意类类型成员(类类型成员包括共用体类型)，且成员也有静态和非静态之分。 共用体类型还可以为其成员指定public，protected和private等保护标记。默认情况下，共用体类型的成员都是公有的，这一点与struct相同。 共用体类型既不能继承自其他类，也不能作为基类使用，所以也不能含有虚函数。 . 共用体类型与类类型最大的区别就是对于共用体类型的所有非静态数据成员来说，任意时刻只有一个成员可以有值。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#112-%E5%85%B1%E7%94%A8%E4%BD%93%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#112-共用体类型"
  },"97": {
    "doc": "派生类类型概念详解",
    "title": "11.21 共用体类型的定义和声明",
    "content": "共用体类型的定义和声明和类类型类似： . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#1121-%E5%85%B1%E7%94%A8%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#1121-共用体类型的定义和声明"
  },"98": {
    "doc": "派生类类型概念详解",
    "title": "11.211 共用体类型的定义",
    "content": "共用体类型的定义和类类型的差不多，遵循类类型的规则： . union (可选 类名) 类体 (可选 类对象列表); . 共用体类型和类类型不一样的是，共用体可以在定义时使用存储说明符声明该共用体类型。 . 共用体类型的类体和类类型的类体一样，遵循类体的规则。 类体里的成员也可以在类外定义；非静态数据成员可以有类内初始值(因为同一时刻只有一个非静态数据成员可以有值，所以类体中只能存在最多一个非静态数据成员的类内初始值)。 . 对于定义共用体类型的构造函数来说，每个构造函数的初始值列表最多只能有一个成员。 当非静态数据成员的类内初始值与构造函数同时存在时，只有构造函数中被初始化的成员才有值，类内初始值会被忽略。 . // 共用体类型Un union Un { int ins; double dou = 6.15; static string sta_str; void prints() { cout &lt;&lt; sta_str; } }; string Un::sta_str = \"sta_str\"; . 当一个共用体类型没有类名和类对象列表，且类体中只含有非静态数据成员，这些成员都是公有成员时，该共用体类型就是一个特殊的共用体类型，叫做匿名union（anonymous union）。 一旦我们定义了一个匿名union，编译器就自动地为该union创建一个未命名的对象，在其作用域内，该union成员都是可以直接访问的。 . 对于全局作用域或者命名空间中定义的匿名union，必须要将其声明为static才行。 . static union { int ins; double dou = 6.15; bool bo; }; // 输出6.15 cout &lt;&lt; dou; . 对于共用体类型的合成默认构造函数和合成的拷贝控制成员的合成条件，是这样的： 当union包含的是内置类型的非静态数据成员时，编译器将按照成员的次序依次合成默认构造函数或拷贝控制成员。 但是如果union含有类类型的非静态数据成员，并且该类型显式定义了默认构造函数或拷贝控制成员，或者该类型的默认构造函数或拷贝控制成员为已删除的，则编译器将为union合成对应的版本并将其声明为删除的(显式的合成也是这样的)。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#11211-%E5%85%B1%E7%94%A8%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#11211-共用体类型的定义"
  },"99": {
    "doc": "派生类类型概念详解",
    "title": "11.212 共用体类型的声明",
    "content": "共用体类型的声明和类类型的声明一样： . union 类名; . 共用体类型的声明中不能含有存储说明符。 . union Un; . 只声明而未定义的共用体类型也是不完全类型，遵循不完全类型的规则。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#11212-%E5%85%B1%E7%94%A8%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#11212-共用体类型的声明"
  },"100": {
    "doc": "派生类类型概念详解",
    "title": "11.22 共用体类型的使用",
    "content": "共用体类型的使用和类类型一样，可以调用或者创建类对象。 . 对于共用体类型对象的初始化，我们既可以直接初始化，也可以拷贝初始化，只要与可用的构造函数匹配就行。 . 对于一个满足如下条件的共用体类型，该类型还可以使用聚合类的初始化方式： . | 所有成员都是public的。 | 没有定义任何构造函数。 | 所有非静态数据成员都没有类内初始值。 | . 但是因为任意时刻只有一个非静态数据成员可以有值，所以聚合类的初始化方式只能初始化一个成员，且因为是按顺序初始化的，所以只能初始化第一个成员。 . union Un { int ins; bool bo; double dou; }; // 错误：只能初始化一个成员 Un ob{6, true, 5.48}; // 错误：第一个成员为int，不是double Un ob{5.48}; // 正确：初始化ins成员 Un ob{6}; . 我们也可以通过成员访问符来对共用体类对象的成员进行操作。 不过为共用体类对象的一个非静态数据成员赋值会令其他的非静态数据成员变成未定义的状态。 . union Un { int ins; bool bo; double dou; }; // 正确：初始化ins成员 Un ob{6}; // 正确：输出6 cout &lt;&lt; ob.ins; // 正确：赋值dou成员，其他非静态数据成员变成未定义 ob.dou = 6.78; // 错误：ins成员未定义 cout &lt;&lt; ob.ins; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#1122-%E5%85%B1%E7%94%A8%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#1122-共用体类型的使用"
  },"101": {
    "doc": "派生类类型概念详解",
    "title": "11.23 管理union成员",
    "content": "对于共用体来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此我们通常把含有类类型成员的共用体内嵌在另一个类当中。这个类可以管理并控制与共用体的类类型成员有关的状态转换。 . 举个例子，我们为共用体添加一个string成员，并将我们的共用体定义成匿名union，最后将它作为Token类的一个成员。此时，Token类将可以管理该类的成员。 . 为了追踪共用体中到底存储了什么类型的值，我们通常会定义一个独立的对象，该对象称为union的判别式(discriminant)。我们可以使用判别式辨认共用体存储的值。 为了保持共用体与其判别式同步，我们通常将判别式也作为该共用体的成员。我们的共用体类通常还将定义一个枚举类型的成员来追踪其共用体成员的状态。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#1123-%E7%AE%A1%E7%90%86union%E6%88%90%E5%91%98",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#1123-管理union成员"
  },"102": {
    "doc": "派生类类型概念详解",
    "title": "派生类类型概念详解",
    "content": "c++的派生类类型一般都是指可以自己定义某种类型的方式。 派生类类型有以下几种。 . | 派生类类型 . | 函数类型 | 自定义类型(类类型)(struct/class) | 枚举类型(enum) | 共用体类型(union) | . | . 之前我们讲述过函数和类类型的用法，接下来我们介绍的是枚举类型和共用体类型的使用方法。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html",
    
    "relUrl": "/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html"
  },"103": {
    "doc": "第十二章 命名空间",
    "title": "第十二章 命名空间",
    "content": "第12章先介绍了命名空间的概念以及定义，然后介绍了命名空间的各种使用方法，最后介绍了命名空间的作用域以及其作用。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/index.html",
    
    "relUrl": "/guide_files/chap12/index.html"
  },"104": {
    "doc": "命名空间概念详解",
    "title": "12.1 命名空间的定义",
    "content": "一个命名空间的定义包含三部分：首先是关键字namespace，随后是命名空间的名字；最后在命名空间名字后面是一个复合语句，复合语句中包含一系列的声明和定义。 . 命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#121-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#121-命名空间的定义"
  },"105": {
    "doc": "命名空间概念详解",
    "title": "12.11 命名空间的定义形式",
    "content": "定义形式为： . (可选 inline) namespace (可选 命名空间名) 复合语句 . 对于命名空间的复合语句来说，只要能出现在全局作用域中的声明或定义，就能置于命名空间的复合语句内，主要包括：类、变量(及其初始化操作)、函数(及其定义)、模板和其他命名空间，这些都可以称为该命名空间的成员。 . 也就是说，命名空间中只能存在各种声明和定义语句，不能存在其他类型的语句。 . namespace ns { int ins = 35; void prints() {} struct Cls {}; template&lt;int inst, class ty&gt; inline ty prints(double val = inst) { cout &lt;&lt; val &lt;&lt; \"\\n\"; return ty(); } namespace nest { double dou = 7.8; } } . 命名空间是无法声明的，只能定义。 . // 错误：不能声明命名空间 namespace ns; // 正确：定义命名空间 namespace ns {} . 因为每个复合语句就是一个作用域，所以每个命名空间也就是一个作用域。 对于在大多数命名空间作用域之外的实体来说，如果想使用命名空间内的成员，就必须要使用作用域运算符来操作，形式为： . 命名空间名::成员名 . namespace ns { int ins = 35; void prints() { cout &lt;&lt; ins; } } // 输出365 ns::ins = 365; ns::prints(); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1211-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1211-命名空间的定义形式"
  },"106": {
    "doc": "命名空间概念详解",
    "title": "12.12 命名空间的不连续性",
    "content": "命名空间可以是不连续的，这一点与其他作用域不太一样。 我们每次定义命名空间时，编译器会检查定义位置的作用域中是否存在同名的命名空间： 如果存在，则我们随后声明或定义的成员将会被添加到之前同名的命名空间中；否则就新建一个命名空间来保存成员。 所以不同作用域中的同名命名空间并不是指的是同一个命名空间。 . 命名空间的作用域范围是根据第一次定义的的范围所决定的，之后对该命名空间的添加语句的位置不会影响该命名空间的作用域范围。 . namespace ns { int ins = 35; void prints(); void prints2(); namespace ns { double dou = 6.8; } } namespace ns { string str = \"external\"; } // 正确：str为ns的成员 void ns::prints() { cout &lt;&lt; str; } // 错误：dou不为外层ns的成员，是为内层的ns成员 void ns::prints2() { cout &lt;&lt; dou; } . 因为命名空间的不连续性，我们甚至可以在某个命名空间的作用域外定义或声明该命名空间的成员，只要用作用域运算符显式指明所要被添加成员的命名空间。 . namespace ns { int ins = 35; void prints() { cout &lt;&lt; ins; } namespace ns2 { double dou = 3.45; void prints2() { cout &lt;&lt; dou; } } } namespace ns::ns2 { void prints3() { cout &lt;&lt; dou; } } // 正确：输出3.45 ns::ns2::prints3(); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1212-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%B8%8D%E8%BF%9E%E7%BB%AD%E6%80%A7",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1212-命名空间的不连续性"
  },"107": {
    "doc": "命名空间概念详解",
    "title": "12.13 命名空间的成员的定义",
    "content": "和类类型一样，命名空间的成员也可以在命名空间之外定义，不过也需要在其命名空间内有声明且定义时要用作用域运算符显式指明为命名空间的成员。 . 在命名空间内的所有成员都默认为该命名空间的成员或嵌套在该命名空间的命名空间的成员以及其嵌套命名空间的嵌套命名空间的成员(以此类推，直到最里层的命名空间成员)，所以不能在命名空间内定义非嵌套在该命名空间的其他命名空间的成员，否则出错。 (反过来说，嵌套的命名空间的成员可以定义在其外层命名空间内，包括外层的外层，以此类推，直到最外层的命名空间内) . 所以，我们不把#include放在命名空间内部。如果我们这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员。 . namespace ns { int ins = 35; void prints(); namespace ns2 { void prints2(); } void ns2::prints2() { cout &lt;&lt; 88; } } void ns::prints() { cout &lt;&lt; ins; } ns::ins = 365; // 输出365 ns::prints(); // 输出88 ns::ns2::prints2(); . 模板特例化必须要在原始模板所属的命名空间中声明，不能在该命名空间之外声明。 和其他命名空间名字类似，只要我们在命名空间中声明了特例化，就能在该命名空间外部定义它了。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1213-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%88%90%E5%91%98%E7%9A%84%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1213-命名空间的成员的定义"
  },"108": {
    "doc": "命名空间概念详解",
    "title": "12.2 命名空间的分类",
    "content": "根据命名空间的性质，可以将所有的命名空间分为以下几种： . | 全局命名空间 | 未命名的命名空间 | 内联命名空间 | . 除了全局命名空间以外，其他所有的命名空间都能为未命名或者内联的。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#122-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E7%B1%BB",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#122-命名空间的分类"
  },"109": {
    "doc": "命名空间概念详解",
    "title": "12.21 全局命名空间",
    "content": "全局命名空间(global namespace)是隐式定义的命名空间，我们不能定义显式全局命名空间。 全局命名空间在所有程序中都存在。 所有在全局作用域中声明或定义的名字(即在所有类、函数及命名空间之外定义的名字)都是全局命名空间的成员。 . 作用域运算符同样能作用于全局命名空间的成员，因为它是隐式的，所以它并没有名字。 以下表示访问一个全局命名空间中的成员： . ::成员名 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1221-%E5%85%A8%E5%B1%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1221-全局命名空间"
  },"110": {
    "doc": "命名空间概念详解",
    "title": "12.22 未命名的命名空间",
    "content": "未命名的命名空间(unnamed namespace)是指定义时没有名字的命名空间。 . 未命名的命名空间和普通命名空间一样，可以不连续，但是对于定义在全局作用域中的未命名的命名空间，它的不连续性只能在某个给定的文件内，不能跨越多个文件。 . 所以每个文件定义自己的全局作用域中的未命名的命名空间，如果两个文件都含有全局作用域的未命名的命名空间，则这两个空间互相无关。 这两个未命名的命名空间中可以定义相同名字的实体，并且这些定义表示的是不同实体。 因此如果一个头文件定义了全局作用域中的未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体。 . 所以和其他命名空间不同，全局作用域中的未命名的命名空间仅在特定的文件内部有效，其作用范围不会橫跨多个不同的文件，所以可以用全局作用域中的未命名的命名空间来代替每个文件中的静态声明。 . 定义在未命名的命名空间中的名字可以在该命名空间所在的作用域中直接使用，毕竟我们找不到什么命名空间的名字来限定它们；同样的，我们也不能在该命名空间所在的作用域中对其成员使用作用域运算符。 . 未命名的命名空间中的实体名字可以与该命名空间所在的作用域的其他实体名字相同，不会出现重复定义，但是会出现二义性问题，此时可以用作用域运算符来消除二义性(但因为未命名的命名空间不能用作用域运算符，所以也就用不了其同名成员了)。 . namespace ns { int ins = 35; namespace { int ins = 84; } // 错误：二义性 void prints() { cout &lt;&lt; ins; } // 正确：显式调用ns命名空间的成员 void prints2() { cout &lt;&lt; ns::ins; } } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1222-%E6%9C%AA%E5%91%BD%E5%90%8D%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1222-未命名的命名空间"
  },"111": {
    "doc": "命名空间概念详解",
    "title": "12.23 内联命名空间",
    "content": "C++11新标准引入了一种新的嵌套命名空间，称为内联命名空间(inline namespace)。 对于每个声明为inline的命名空间，都叫做内联命名空间。 . 内联的未命名的命名空间以未命名的命名空间的规则为主。 . 和普通的嵌套命名空间不同，内联命名空间中的名字可以被其外层的命名空间直接使用。 也就是说，我们无须使用作用域运算符，就可以在其外层命名空间的作用域中直接访问它的成员(当然也可以用作用域运算符访问)。 . 和未命名的命名空间一样，内联命名空间中的名字可以与该命名空间所在的作用域的实体名字相同，不会出现重复定义，但是会出现二义性问题，此时可以用作用域运算符来消除二义性。 . namespace ns { int ins = 35; inline namespace ne { int ins = 84; } // 错误：二义性 void prints() { cout &lt;&lt; ins; } // 正确：显式调用ns命名空间的成员 void prints2() { cout &lt;&lt; ns::ins; } // 正确：显式调用ne命名空间的成员 void prints2() { cout &lt;&lt; ne::ins; } } . 内联命名空间与未命名的命名空间的区别也就是全局作用域中的内联的已命名的命名空间可以在多个文件中不连续，且可以使用作用域运算符访问。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1223-%E5%86%85%E8%81%94%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1223-内联命名空间"
  },"112": {
    "doc": "命名空间概念详解",
    "title": "12.3 命名空间成员的使用",
    "content": "我们之前介绍过访问命名空间成员的方法是用作用域运算符的方式，但是当命名空间太长时，访问成员就会异常的麻烦，所以为了解决这个问题，我们有两种方法： . | 定义命名空间的别名 | 拓展成员的作用域 . | using声明 | using指示 | . | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#123-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%88%90%E5%91%98%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#123-命名空间成员的使用"
  },"113": {
    "doc": "命名空间概念详解",
    "title": "12.31 命名空间的别名",
    "content": "命名空间的别名(namespace alias)使得我们可以为命名空间的名字设定一个短得多的同义词，我们可以像对原命名空间一样对该别名作出任何可以的操作。 . 命名空间的别名只在该别名声明语句所在的作用域中生效。 . 一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价。 . 命名空间别名的声明语句除了不能存在于类内以外，其他的和类型别名一样，可以存在于全局作用域、命名空间和函数内。 . 命名空间的别名声明语句是以关键字namespace开始，后面是别名所用的名字、赋值号=、命名空间原来的名字以及一个分号;。 . 别名声明语句的形式为： . namespace 别名 = 命名空间名; . 声明的别名不能是该语句所在作用域中的其他命名空间名，否则会有重复定义错误。 而且声明后的别名不能用于该命名空间成员的声明或定义，只能用于被调用。 . #include &lt;iostream&gt; // 正确，ns命名空间的成员定义 namespace ns { int ins = 55; } // 正确，ns命名空间的成员定义 namespace ns { double dou = 55.5; } // 全局作用域中，的命名空间别名nc namespace nc = ns; // 函数内，的命名空间别名fns int foo() { namespace fns = ns; std::cout &lt;&lt; fns::dou &lt;&lt; std::endl; } // 命名空间内，的命名空间别名nns namespace nestn { namespace nns = ns; nns::ins; } // 重复定义错误，别名nc不能用于后续ns命名空间成员的声明或定义 namespace nc { double dou2 = 55.5; } // 正确，ns命名空间的成员定义 namespace ns { double dou3 = 55.55; } . 但可以与所在作用域的外层作用域的命名空间同名，此时会在该语句所在作用域中隐藏掉外层的同名命名空间。 . 声明语句中的命名空间名可以是嵌套在命名空间中的命名空间，但不能是未命名或者未定义的命名空间。 . namespace ns { int ins = 35; namespace nest { void prints() { cout &lt;&lt; ins; } } } // 别名声明语句 namespace nc = ns::nest; // 正确：输出35 ns::nest::prints(); nc::prints(); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1231-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%AB%E5%90%8D",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1231-命名空间的别名"
  },"114": {
    "doc": "命名空间概念详解",
    "title": "12.32 拓展成员的作用域",
    "content": "我们也可以直接拓展某个命名空间的成员作用域来直接访问该空间的某些成员。 . 拓展成员的作用域的方法有两种： . | using声明 | using指示 | . 这两种方法只在该方法语句所在的作用域中生效。 . 不管是哪种方法，在被拓展的作用域内出现的实体都可以直接访问这些被拓展的命名空间成员而不需要用到作用域运算符(当然也可以用)。 . 拓展成员的作用域后，我们还是可以用作用域运算符来访问这些成员，不过要注意： 如果在使用using指示后还是用作用域运算符来访问这些成员，则该命名空间中不能有与其同名的内嵌命名空间，否则使用作用域运算符访问的就是内嵌命名空间的成员了。 . 这两种方法和类型别名一样，可以存在于全局作用域，命名空间、函数内或者是类内。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1232-%E6%8B%93%E5%B1%95%E6%88%90%E5%91%98%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1232-拓展成员的作用域"
  },"115": {
    "doc": "命名空间概念详解",
    "title": "12.321 using声明",
    "content": "using声明(using declaration)语句一次只能拓展命名空间的一个非命名空间成员。 . 被拓展的成员的==作用域范围是从using声明语句的出现位置到该语句所在作用域的末尾==。 . using声明语句为： . using 命名空间名::成员名; . using声明语句中的命名空间名可以是嵌套的命名空间，但不能是未命名或者未定义的命名空间。 . using声明语句中的成员名不能为命名空间成员。 而且对于非函数成员名来说，不能与该语句所在作用域中的其他实体同名；对于函数成员名来说，不能与该语句所在作用域中的其他函数定义语句中的函数首部有冲突。否则会有重复定义错误。 但可以与所在作用域的外层作用域的实体同名，此时会在该语句所在作用域中隐藏掉外层的所有同名实体。 . 当using声明语句中的成员名为重载函数名时，该函数在命名空间的所有版本都会被拓展。 . namespace ns { int ins = 35; void prints() { cout &lt;&lt; ins; } namespace ns2 { double dou = 3.45; void prints2() { cout &lt;&lt; dou; } } } // 错误：不能直接访问ns中的ns2的成员 prints2(); // using声明语句 using ns::ns2::prints2; // 正确：输出3.45 prints2(); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#12321-using%E5%A3%B0%E6%98%8E",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#12321-using声明"
  },"116": {
    "doc": "命名空间概念详解",
    "title": "12.322 using指示",
    "content": "using指示(using directive)是另一种拓展成员作用域的方法。 和using声明不一样的地方是，using指示会拓展给定命名空间的所有成员的作用域(包括在using指示语句之后添加进该空间的成员)。 . 所有被拓展的成员的作用域范围==被提升到与包含该命名空间本身和该using指示语句的最近作用域范围一样的范围==。 . using指示语句的形式为： . using namespace 命名空间名; . using指示语句中的命名空间名可以是嵌套的命名空间，但不能是未命名或者未定义的命名空间。 . 对于using指示语句中给定的命名空间中的成员来说： . | 非函数成员名不能与该语句所在作用域中的其他实体同名，否则在使用该同名时会出现二义性错误。 | 函数成员名不能与该语句所在作用域中的其他函数定义语句中的函数首部有冲突，否则在使用该同名时会出现二义性错误。 | . 但该using指示语句所提升的作用域中的内层作用域的实体可以与该命名空间的成员同名，此时会在内层作用域中隐藏掉该命名空间的所有同名成员。 . namespace ns { int ins = 35; void prints() { std::cout &lt;&lt; 49; } double dou = 3.45; } int ins = 56; namespace ns { string str = \"good\"; } int main() { // using指示语句 using namespace ns; // 隐藏了ns的dou成员 double dou = 94.45; // 正确：输出49 prints(); // 正确：输出good cout &lt;&lt; str; // 隐藏了ns的dou成员，所以\\ 输出94.45 cout &lt;&lt; dou; // 错误：ns中的ins成员与外层成员ins起冲突\\ 导致二义性错误 cout &lt;&lt; ins; // 正确：显式调用ns中的ins成员\\ 输出35 cout &lt;&lt; ns::ins; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#12322-using%E6%8C%87%E7%A4%BA",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#12322-using指示"
  },"117": {
    "doc": "命名空间概念详解",
    "title": "12.4 命名空间与函数匹配",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#124-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#124-命名空间与函数匹配"
  },"118": {
    "doc": "命名空间概念详解",
    "title": "12.41 命名空间的名字查找",
    "content": "对命名空间内部名字的查找(包括类的成员)遵循常规的查找规则：即由内向外依次査找每个外层作用域。 . 外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过程终止。只有位于使用点之前声明的名字才被考虑。 . 所以如果某命名空间中不含嵌套的同名命名空间，则该命名空间的成员定义可以使用本身自己的命名空间名及作用域运算符来调用本身自己命名空间的成员。 . // 命名空间ns namespace ns { int g_ins = 5; } // 命名空间ns namespace ns { // 查找到本身ns的g_ins int g_ins2 = g_ins; // 查找到本身ns的g_ins int g_ins3 = ns::g_ins; } // 命名空间ns2 namespace ns2 { double g_dou = 5.5; } // 命名空间ns2 namespace ns2 { // 命名空间ns2::ns2 namespace ns2 { double g_dou = 7.99; } // 查找到本身ns2的g_dou double g_dou3 = g_dou; // 查找到ns2::ns2的g_dou2 double g_dou4 = ns2::g_dou; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1241-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1241-命名空间的名字查找"
  },"119": {
    "doc": "命名空间概念详解",
    "title": "12.42 函数匹配",
    "content": "命名空间成员的函数匹配与普通的函数匹配的流程大部分一样，只不过有以下的这些区别： . | 函数匹配时的名字查找还会在实参类所属的命名空间中进行： 按照调用表达式的实参顺序，在每个实参类(以及实参类的基类)所属的命名空间中进行查找(只会在这个命名空间中查找，不会在该命名空间的外层作用域(包括外层空间)中进行查找)，并将查找到的所有同名函数加入到候选函数集中(即使该函数所属的命名空间在调用点不可见，也会将其加入)。 | . namespace ns { namespace nest { struct Cls { string str = \"Cls\"; }; void prints(Cls obj, double) { cout &lt;&lt; obj.str &lt;&lt; \" nest\\n\"; } } void prints(nest::Cls obj, string) { cout &lt;&lt; obj.str &lt;&lt; \" ns\\n\"; } } void prints(ns::nest::Cls obj, int) { cout &lt;&lt; obj.str &lt;&lt; \" external\\n\"; } int main() { ns::nest::Cls ob; // 调用void prints(ns::nest::Cls obj, int)\\ 输出Cls external prints(ob, 3); // 调用void ns::nest::prints(ns::nest::Cls obj, double)\\ 输出Cls nest prints(ob, 5.1); // 错误：void ns::prints(ns::nest::Cls obj, string)在调用点不可见 prints(ob, \"str\"); } . | 命名空间中的类的友元声明会被隐式当成该类所属命名空间的成员声明： 命名空间中的类的友元声明不再仅仅只是一个权限说明了，也是一个该类所属命名空间的隐式成员声明。 所以命名空间中的类的友元只能是该命名空间的成员。 | . namespace ns { class Cls { // 友元声明 friend void prints(Cls obj, int val); friend void prints2(int val); int ins = 15; }; } // 错误：Cls的友元必须要为ns的成员，该函数不是友元\\ 所以该函数无法访问Cls的ins成员 void prints(ns::Cls obj, int val) { cout &lt;&lt; val &lt;&lt; ' ' &lt;&lt; obj.ins &lt;&lt; \" Cls\\n\"; } // 正确：为Cls的友元void prints(Cls obj, int val)的定义 void ns::prints(Cls obj, int val) { cout &lt;&lt; val &lt;&lt; ' ' &lt;&lt; obj.ins &lt;&lt; \" Cls2\\n\"; } int main() { ns::Cls ob; // 错误：有多个函数匹配 prints(ob, 3); // 正确：调用Cls类的友元\\ 输出3 15 Cls2 ns::prints(ob, 3); // 错误：prints2为ns的成员，所以不可见 prints2(3); } . 当我们使用了拓展命名空间成员的作用域的方法时，被拓展的函数成员同样遵循普通的函数匹配规则。 . namespace ns { void prints(int val) { cout &lt;&lt; val &lt;&lt; \" ns\\n\"; } void prints(string val) { cout &lt;&lt; val &lt;&lt; \" ns\\n\"; } } void prints(double val) { cout &lt;&lt; val &lt;&lt; \" external\\n\"; } // using声明语句 using ns::prints; int main() { // 调用void ns::prints(std::string val)\\ 输出str ns prints(\"str\"); // 调用void ns::prints(int val)\\ 输出5 ns prints(5); // 调用void prints(double val)\\ 输出3.58 external prints(3.58); } . namespace ns { void prints(double val) { cout &lt;&lt; val &lt;&lt; \" ns\\n\"; } void prints(string val) { cout &lt;&lt; val &lt;&lt; \" ns\\n\"; } } void prints(int val) { cout &lt;&lt; val &lt;&lt; \" external\\n\"; } void prints(double val) { cout &lt;&lt; val &lt;&lt; \" external\\n\"; } int main() { // using指示语句 using namespace ns; // 正确：调用void ns::prints(std::string val)\\ 输出str ns prints(\"str\"); // 正确：调用void ns::prints(int val)\\ 输出5 ns prints(5); // 错误：ns中和全局作用域的void prints(double val)函数都是最佳匹配 prints(3.58); // 正确：显式调用void ns::prints(double val)\\ 输出3.58 ns ns::prints(3.58); } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1242-%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#1242-函数匹配"
  },"120": {
    "doc": "命名空间概念详解",
    "title": "命名空间概念详解",
    "content": "大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。 当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染(namespace pollution)。 . 为了防止名字冲突，也为了简化命名操作，C++提供了命名空间(namespace)机制。 命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者(以及用户)可以避免全局名字可能会造成的冲突。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html",
    
    "relUrl": "/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html"
  },"121": {
    "doc": "第十三章 分离式编译",
    "title": "第十三章 分离式编译",
    "content": "第13章先介绍了分离式编译的概念以及使用，然后再次详细地介绍了代码的编译流程，最后对分离式编译的使用给出了一些建议。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap13/index.html",
    
    "relUrl": "/guide_files/chap13/index.html"
  },"122": {
    "doc": "分离式编译概念详解",
    "title": "13.1 概念",
    "content": "随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同文件中。在一般的程序中，不可能只有单个文件的。 我们在写代码的时候，通常会对各种代码的结构进行组织，从而使之后的调试修改等工作更加方便。 . C++语言支持所谓的分离式编译（separate compilation）。 分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译，最后再链接到一起。 . 一般来说，我们可以将实体的定义与其声明分离，使它们的定义与其声明分属不同的文件中，从而方便管理组织程序的代码。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#131-%E6%A6%82%E5%BF%B5",
    
    "relUrl": "/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#131-概念"
  },"123": {
    "doc": "分离式编译概念详解",
    "title": "13.2 代码的翻译过程",
    "content": "我们的程序代码通常是由多个代码文件组成的，其中包含头文件和源文件(对于Windows系统来说，C++语言的头文件通常以.h为后缀，源文件通常以.cpp为后缀)。 从程序代码到程序运行，我们需要进行程序代码的翻译工作，翻译工作都是由c++的编译器驱动程序进行的，编译器驱动程序会对程序所有的代码进行一些操作，这些操作也就是我们之前所讲的C++代码翻译的四大阶段。 . 我们再回顾以下这四个阶段，其中有需要注意的几个地方： . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#132-%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B",
    
    "relUrl": "/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#132-代码的翻译过程"
  },"124": {
    "doc": "分离式编译概念详解",
    "title": "13.21 预处理阶段",
    "content": ". | 在预处理阶段，预处理器会对程序代码中的每个代码文件.cpp/.h独立地执行其所有的预处理指令，并将其中的每行注释替换成一行空行。每个文件处理完后的所有代码保存在一个预处理文本文件.i中。 #include也是预处理指令之一，它的作用就是将指定的文件的所有内容包含在指令出现的位置，该指令会自动展开包含文件的代码到该使用位置，如果该包含文件也有预处理指令，则也执行该指令。 所以为了防止包含文件时出现重复定义，我们需要在被包含文件中使用宏和条件编译(这几个操作的综合也就叫做头文件保护符(header guard))来防止多次包含该文件的内容。 | . // 在windows系统上使用GNU编译器套件进行C++的代码翻译 // 以下是test.cpp源文件中的代码 #include \"te.h\" #define MA(a,b) a * b; int main() { int ins = MA(23,13) double dou = 17; // 这是一行注释，会被替换成一行空行。 /* 这是两行注释，会被替换成四行空行。 这是两行注释，会被替换成四行空行。*/ return 0; } // te.h头文件与test.cpp源文件为同一路径。 // te.h头文件使用了头文件保护符操作。 // 以下是te.h头文件中的代码 #ifndef TE_H #define TE_H extern int ins; extern double dou; #endif /* 在命令行中的这两个文件所在路径下输入以下命令进行test.cpp文件的预处理操作： g++ -E test.cpp -o t.i -o指令是指定生成文件的文件名(可包含路径信息)， 因为GNU预处理指令-E默认在命令行输出预处理文本文件(.i)， 而不保存下来，所以需要显式指定文件名。 预处理后生成的文件为同路径下的t.i */ // 以下都是t.i文件中的代码 # 1 \"test.cpp\" # 1 \"&lt;built-in&gt;\" # 1 \"&lt;command-line&gt;\" # 1 \"test.cpp\" # 1 \"te.h\" 1 extern int ins; extern double dou; # 2 \"test.cpp\" 2 int main() { int ins = 23 * 13; double dou = 17; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#1321-%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5",
    
    "relUrl": "/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#1321-预处理阶段"
  },"125": {
    "doc": "分离式编译概念详解",
    "title": "13.22 编译阶段",
    "content": ". | 在编译阶段，编译器会独立地检查所有从程序代码转换而成的预处理文本文件.i，也就是只检查该文件中的代码，而不会考虑其他文件对其的影响。当某个预处理文本文件通过了编译检查时，编译器会将该文件里的所有代码翻译成一种能被汇编语言程序所识别的代码，所有翻译后的代码保存在一个汇编文本文件.s中。 其中，有以下几点需要注意： . | 编译器在进行编译检查时，如果我们使用了某个对象(包括普通函数、类的非类类型成员、类的非成员模板成员和模板实例)时，编译器会检查这些对象的声明是否在该作用域中存在： . | 对于声明存在但定义不存在的对象，编译器会在汇编文本文件.s中做一个标记，告诉之后的链接器在链接的时候去找该对象的定义，把问题移交给链接器，此时不会触发编译出错。 | 如果该对象的声明不存在，或者声明存在但与其定义不匹配，或者该对象有多个不匹配的声明或定义时，就会编译出错。 | . | 但是当我们在不符合不完全类型的使用情形时使用了某类型(包括类类型和类模板)，则编译器不仅会检查其声明，还会检查是否存在对应的定义，否则编译出错。 | 对于模板来说，模板的实例化只会在编译阶段进行，生成的实例(也就是实例定义)包含以下部分： . | 对于类模板来说： 编译器生成的实例包含该类的定义和其所有成员的声明(不包含其成员的定义)。 | 对于函数模板来说： 编译器生成的实例包含该函数的定义。 | . | 编译器实例化模板的时机： . | 当遇到模板或者模板部分特例化的声明以及定义语句时，编译器不进行实例化。 | 当遇到使用非类模板的模板语句(隐式实例化)，且该语句不是显式实例化定义或者全部特例化时，编译器还是按常规进行声明检查： . | 如果满足以下任意一项，则编译器不会生成任何实例，否则编译器就会生成对应的实例定义： . | 该模板只有声明而不存在定义。 | 同作用域中已存在该处所使用的对应的实例声明。 | 同作用域中已存在该处所使用的对应的实例定义(由其他隐式或显式实例化所产生的)。 | . | . | 当遇到全部特例化的声明或定义语句时： 如果满足以下任意一项，则会编译出错，否则编译器就会生成对应特殊实例的声明或定义： . | 原始模板的声明不存在时。 | 该特例化语句是定义语句，且该文件中已存在该特例化对应的实例定义(由其他隐式或显式实例化所产生的)。 | . 对于全部特例化声明所生成的特殊实例声明，后续会在链接阶段与该模板的其他同声明的实例定义链接上。 . | 当遇到显式实例化的定义语句时： . | 如果满足以下任意一项，则会编译出错： . | 同作用域中不存在该模板的定义。 | 同作用域中已存在同与其相同的显式实例化定义。 | . | 如果满足以下任意一项，则编译器不会生成对应的实例： . | 同作用域中已存在该处所使用的对应的实例定义(由其他隐式实例化所产生的)。 | . | . 否则，编译器就会生成对应的实例定义。 . | . | . 所以为了生成一个模板的实例，编译器可能既需要模板自身的定义，也需要模板成员的定义。因此与其他对象不同的是，模板通常将其声明和定义放在同一个文件中。 . | . // 在windows系统上使用GNU编译器套件进行C++的代码翻译 // 以下是test.cpp源文件中的代码 #include \"te.h\" extern template int t_ret(int); int main() { int var = ins; int var2 = ret(); ret(); int var3 = t_ret&lt;int&gt;(15); t_ret(t_ret(152)); return 0; } // te.h头文件与test.cpp源文件为同一路径。 // te.h头文件使用了头文件保护符操作。 // 以下是te.h头文件中的代码 #ifndef TE_H #define TE_H extern int ins; int ret(); template &lt;typename ty&gt; ty t_ret(ty val); #endif /* 在命令行中的这两个文件所在路径下输入以下命令进行test.cpp文件的预处理以及编译操作： g++ -S test.cpp 因为GNU预处理加编译的合成操作-S(该操作也可接受预处理文本文件， 从而只对该文件进行编译操作)默认在同路径下创建一个同名的汇编文本文件(.s)， 所以可以不用-o显式指定文件名。 编译成功，在同路径下生成文件test.s */ // 以下都是test.s文件中的代码 .file \"test.cpp\" .text .def __main; .scl 2; .type 32; .endef .globl main .def main; .scl 2; .type 32; .endef .seh_proc main main: .LFB0: pushq %rbp .seh_pushreg %rbp movq %rsp, %rbp .seh_setframe %rbp, 0 subq $48, %rsp .seh_stackalloc 48 .seh_endprologue call __main movq .refptr.ins(%rip), %rax movl (%rax), %eax movl %eax, -4(%rbp) call _Z3retv movl %eax, -8(%rbp) call _Z3retv movl $15, %ecx call _Z5t_retIiET_S0_ movl %eax, -12(%rbp) movl $152, %ecx call _Z5t_retIiET_S0_ movl %eax, %ecx call _Z5t_retIiET_S0_ movl $0, %eax addq $48, %rsp popq %rbp ret .seh_endproc .ident \"GCC: (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0\" .def _Z3retv; .scl 2; .type 32; .endef .def _Z5t_retIiET_S0_; .scl 2; .type 32; .endef .section .rdata$.refptr.ins, \"dr\" .globl .refptr.ins .linkonce discard .refptr.ins: .quad ins . // 在windows系统上使用GNU编译器套件进行C++的代码翻译 // 以下是test.cpp源文件中的代码 #include \"te.h\" // 函数模板t_ret的显式实例化定义 // 编译会出错， // 因为te.h中的函数模板t_ret只有声明没有定义 template int t_ret(int); int main() { // 类类型Cls对象的定义 // 编译会出错， // 因为te.h中的类类型Cls只有声明没有定义 Cls obj; // 类模板T_cls对象的定义 // 编译会出错， // 因为te.h中的类模板T_cls只有声明没有定义 T_cls&lt;int, 48&gt; t_obj; return 0; } // te.h头文件与test.cpp源文件为同一路径。 // te.h头文件使用了头文件保护符操作。 // 以下是te.h头文件中的代码 #ifndef TE_H #define TE_H template &lt;typename ty&gt; ty t_ret(ty val); struct Cls; template &lt;typename ty, int val&gt; struct T_cls; #endif /* 在命令行中的这两个文件所在路径下输入以下命令进行test.cpp文件的预处理以及编译操作： g++ -S test.cpp 因为GNU预处理加编译的合成操作-S(该操作也可接受预处理文本文件， 从而只对该文件进行编译操作)默认在同路径下创建一个同名的汇编文本文件(.s)， 所以可以不用-o显式指定文件名。 编译失败，没有生成任何文件。 */ . // 在windows系统上使用GNU编译器套件进行C++的代码翻译 // 以下是test.cpp源文件中的代码 #include \"te.h\" // 函数模板t_ret的显式实例化定义 // 编译会通过， // 因为te.h中，函数模板t_ret的全部特例化声明会生成一个对应的实例声明 template int t_ret(int); // 类模板T_cls的显式实例化定义 // 编译会通过， // 因为te.h中，类模板T_cls的全部特例化定义会生成一个对应的实例定义，其中包含其成员prints的声明。 template struct T_cls&lt;int, 48&gt;; int main() { int var3 = t_ret&lt;int&gt;(15); t_ret(t_ret(152)); // 类类型Cls对象的定义 // 编译会通过， // 因为te.h中有类类型Cls的定义。 Cls obj; T_cls&lt;int, 48&gt; t_obj; // 编译会通过， // 因为te.h中有函数prints的声明。 t_obj.prints(); return 0; } // te.h头文件与test.cpp源文件为同一路径。 // te.h头文件使用了头文件保护符操作。 // 以下是te.h头文件中的代码 #ifndef TE_H #define TE_H template &lt;typename ty&gt; ty t_ret(ty val); template&lt;&gt; int t_ret(int); struct Cls {}; template &lt;typename ty, int val&gt; struct T_cls; template&lt;&gt; struct T_cls&lt;int, 48&gt; { void prints(); }; #endif /* 在命令行中的这两个文件所在路径下输入以下命令进行test.cpp文件的预处理以及编译操作： g++ -S test.cpp 因为GNU预处理加编译的合成操作-S(该操作也可接受预处理文本文件， 从而只对该文件进行编译操作)默认在同路径下创建一个同名的汇编文本文件(.s)， 所以可以不用-o显式指定文件名。 编译成功，在同路径下生成文件test.s。 */ . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#1322-%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5",
    
    "relUrl": "/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#1322-编译阶段"
  },"126": {
    "doc": "分离式编译概念详解",
    "title": "13.23 汇编阶段",
    "content": ". | 在汇编阶段期间，汇编器会独立地将所有从程序代码转换而成的汇编文本文件.s翻译成机器代码，也叫做机器语言指令(也就是由二进制值组成的代码，计算器能够识别的代码)，并将这些机器语言指令打包成一种叫做可重定位目标程序(relocate object program)的格式，最后将每个文件的打包结果保存在一个为其创建的可重定位目标文件.o中。 | . // 在windows系统上使用GNU编译器套件进行C++的代码翻译 // 以下是test.cpp源文件中的代码 #include \"te.h\" template int t_ret(int); template struct T_cls&lt;int, 48&gt;; int main() { int var3 = t_ret&lt;int&gt;(15); t_ret(t_ret(152)); Cls obj; T_cls&lt;int, 48&gt; t_obj; t_obj.prints(); return 0; } // te.h头文件与test.cpp源文件为同一路径。 // te.h头文件使用了头文件保护符操作。 // 以下是te.h头文件中的代码 #ifndef TE_H #define TE_H template &lt;typename ty&gt; ty t_ret(ty val); template&lt;&gt; int t_ret(int); struct Cls {}; template &lt;typename ty, int val&gt; struct T_cls; template&lt;&gt; struct T_cls&lt;int, 48&gt; { void prints(); }; #endif /* 在命令行中的这两个文件所在路径下输入以下命令进行test.cpp文件的预处理、编译以及汇编的合成操作： g++ -c test.cpp 因为GNU预处理加编译加汇编的合成操作-c(该操作也可接受预处理文本文件或者汇编文本文件， 从而进行对应文件的合成操作)默认在同路径下创建一个同名的目标文件(.o)， 所以可以不用-o显式指定文件名。 汇编成功，在同路径下生成文件test.o。 */ . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#1323-%E6%B1%87%E7%BC%96%E9%98%B6%E6%AE%B5",
    
    "relUrl": "/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#1323-汇编阶段"
  },"127": {
    "doc": "分离式编译概念详解",
    "title": "13.24 链接阶段",
    "content": ". | 在链接阶段，链接器会把所有从程序代码转换而成的目标文件.o链接到一起，并进行检查合并： 链接器会将所有文件中的对象的声明和定义链接在一起，如果链接器在链接时发现有对象进行了重复定义，或者是该对象的声明和定义不匹配，又或者是某句使用了未定义的对象(此时，使用了未实例化的实例的地方就会被认为是使用了未定义对象)，则会链接出错。 当所有地方都链接无误后，链接器就会形成一个可执行文件.exe/.out，此时程序才真正可以在操作系统中运行。 | . // 在windows系统上使用GNU编译器套件进行C++的代码翻译 // 以下是test.cpp源文件中的代码 #include \"te.h\" template struct T_cls&lt;int, 48&gt;; template int t_ret(int); int main() { int var = ins; int var2 = ret(); int var3 = t_ret&lt;int&gt;(15); // 输出74 60 169 cout &lt;&lt; var &lt;&lt; \" \" &lt;&lt; var2 &lt;&lt; \" \" &lt;&lt; var3 &lt;&lt; \"\\n\"; Cls obj; T_cls&lt;int, 48&gt; t_obj; // 输出spec t_obj.prints(); return 0; } // te.h头文件与test.cpp源文件为同一路径。 // te.h头文件使用了头文件保护符操作。 // 以下是te.h头文件中的代码 #ifndef TE_H #define TE_H #include &lt;iostream&gt; using namespace std; extern int ins; int ret(); template &lt;typename ty&gt; ty t_ret(ty val); template&lt;&gt; int t_ret(int); struct Cls {}; template &lt;typename ty, int val&gt; struct T_cls { void prints(); }; template&lt;&gt; void T_cls&lt;int, 48&gt;::prints(); #endif // te.cpp源文件与te.h头文件为同一路径。 // 以下是te.cpp源文件中的代码 #include \"te.h\" int ins = 74; int ret() { return 60; } template &lt;typename ty&gt; ty t_ret(ty val) { return val + 25; } template&lt;&gt; int t_ret(int val) { return val + 154; } template &lt;typename ty, int val&gt; void T_cls&lt;ty, val&gt;::prints() { cout &lt;&lt; \"original\\n\"; } template&lt;&gt; void T_cls&lt;int, 48&gt;::prints() { cout &lt;&lt; \"spec\\n\"; } /* 在命令行中的这几个文件所在路径下输入以下命令进行test.cpp、te.cpp文件的预处理、编译、汇编以及链接的合成操作： g++ test.cpp te.cpp GNU的默认操作就是预处理加编译加汇编加链接的合成操作(该操作也可接受预处理文本文件、汇编文本文件或者目标文件，从而进行对应文件的合成操作)。 GNU的默认操作默认在同路径下创建一个文件名为a的可执行文件(.exe)，所以可以不用-o显式指定文件名。 链接成功，在同路径下生成文件a.exe。 */ . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#1324-%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5",
    
    "relUrl": "/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#1324-链接阶段"
  },"128": {
    "doc": "分离式编译概念详解",
    "title": "13.3 代码翻译过程的注意事项",
    "content": "综上来说，我们建议： . | 所有头文件应使用头文件保护符来防止重复定义。 | 各种变量、函数，类的非类类型或者非成员模板成员应该在头文件中独立声明，而它们的定义部分可以放在其它的源文件中，且这些源文件应该把包含其对应声明的头文件包含进来，这样就可以使编译器来验证其定义和声明是否匹配。 | 对于模板来说，要么提前实例化模板的所有所需实例(一般不推荐，因为需要提前实例化多个，很麻烦)，要么就将模板的声明和定义(不包括类模板的非类类型或者非成员模板成员的定义)放在同一个头文件中。 | 当我们的某些文件需要使用这些实体时，只需要用包含预编译指令将包含该实体声明的头文件包含进来就行了，而不需要将这些实体的定义文件包含进来。 | 链接时不要忘记链接这些实体的定义文件。 | . /* * 综合示例 */ // 在windows系统上使用GNU编译器套件进行C++的代码翻译 // 以下是test.cpp源文件中的代码 #include \"test.h\" std::string ret() { return std::string(\"linker\"); } // test.h头文件与test.cpp源文件为同一路径。 // test.h头文件使用了头文件保护符操作。 // 以下是test.h头文件中的代码 #ifndef TEST_H_ #define TEST_H_ #include &lt;string&gt; std::string ret(); std::string sprints() { return ret(); } #endif // main.cpp源文件与test.h头文件为同一路径。 // 以下是main.cpp源文件中的代码 #include &lt;iostream&gt; #include \"test.h\" int main() { std::cout &lt;&lt; sprints() &lt;&lt; std::endl; return 0; } /* 在命令行中的这几个文件所在路径下输入以下命令进行test.cpp、main.cpp文件的预处理、编译、汇编以及链接的合成操作： g++ test.cpp main.cpp 此时会链接出错，提示sprints函数重定义。 造成重定义的原因为： test.cpp和main.cpp在经过预处理阶段后，这两个文件都包含了sprints的定义， 编译时编译器只单独检查每个文件，因此这两个文件都通过了编译， 但在链接阶段，链接器整合这两个文件的所有对象进行链接时就发现了sprints的定义重复的现象，于是报错。 正确做法是将sprints的定义移到test.cpp，test.h只包含sprints的声明，也就是： // 以下是修改后的test.cpp源文件中的代码 #include \"test.h\" std::string ret() { return std::string(\"linker\"); } std::string sprints() { return ret(); } // 以下是修改后的test.h头文件中的代码 #ifndef TEST_H_ #define TEST_H_ #include &lt;string&gt; std::string ret(); std::string sprints(); #endif 这样修改后重新运行以下操作： g++ test.cpp main.cpp 此时就会链接成功，在同路径下生成文件a.exe。 */ . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#133-%E4%BB%A3%E7%A0%81%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9",
    
    "relUrl": "/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html#133-代码翻译过程的注意事项"
  },"129": {
    "doc": "分离式编译概念详解",
    "title": "分离式编译概念详解",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html",
    
    "relUrl": "/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html"
  },"130": {
    "doc": "第十四章 固有的不可移植特性",
    "title": "第十四章 固有的不可移植特性",
    "content": "第14章介绍了一些C++的固有特性，该特性可能会影响到C++代码的移植。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap14/index.html",
    
    "relUrl": "/guide_files/chap14/index.html"
  },"131": {
    "doc": "固有的不可移植特性概念详解",
    "title": "14.1 不可移植特性的概念",
    "content": "为了支持低层编程，C++定义了一些固有的不可移植(nonportable)的特性。所谓不可移植的特性是指因机器或者操作系统而异的特性，当我们将含有不可移植特性的程序从一台机器或者操作系统转移到另一台机器或者操作系统上时，通常需要重新编写该程序。 . 对于C++的不可移植特性，一般有以下几种： . | 算术类型的所占字节的大小 | 位域 | volatile限定符 | 链接指示 | . 算术类型的所占字节的大小我们在将数据类型时介绍过，接下来我们主要介绍后三种不可移植特性。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#141-%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7%E7%9A%84%E6%A6%82%E5%BF%B5",
    
    "relUrl": "/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#141-不可移植特性的概念"
  },"132": {
    "doc": "固有的不可移植特性概念详解",
    "title": "14.2 位域",
    "content": "类可以将其非静态数据成员定义成位域(bit-field),在一个位域中含有一定数量的二进制位。 当一个程序需要向其他程序或硬件设备传递二进制数据吋，通常会用到位域。 . 位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式。 . 位域的声明形式为： . 类型说明符(可含类型修饰符) 位域名: 常量表达式; . 位域的类型必须是整型或枚举类型。 . 因为带符号位域的行为是由具体实现确定的，所以在通常情况下我们使用无符号类型保存一个位域。 . 声明中的常量表达式用于说明该位域所占的二进制位数的数量。 . 位域不能有类内初始值。 . 一般来说, 在类的内部连续定义的位域内存空间会被压缩在同一整数的相邻位，从而提供存储压缩。 . 取地址运算符&amp;不能作用于位域，因此任何指针都无法指向类的位域。 . 位域和其他的整型变量一样，可以被初始化或赋值，也可以初始化或赋值其他对象，只要所给的值的类型是该位域的类型或者能隐式转换成该类型就行。 因为位域所占的空间只有给定位数的大小，所以当位域被初始化或赋值时，从低位向高位储存每位的值，直至达到规定位数；如果用于初始化或赋值的值的位数小于位域时，则位域也是从低位向高位储存每位的值，高位如有空，则其位值为0。用位域来初始化或赋值与其类似。 . 位域在内存中的布局是与机器相关的。 . struct Cls { // 位域bits的声明 unsigned bits : 3; Cls(): bits(9) {} }; // 位域bits被int型字面值初始化 // 字面值9的最低的4位二进制为 // 1001 // 位域bits的位数为3位，按照赋值规则，bits初始化后的位数为 // 001 // 按无符号int型就表示数字1 Cls obj; // 输出1 cout &lt;&lt; obj.bits; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#142-%E4%BD%8D%E5%9F%9F",
    
    "relUrl": "/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#142-位域"
  },"133": {
    "doc": "固有的不可移植特性概念详解",
    "title": "14.3 volatile限定符",
    "content": "直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制。例如，程序可能包含一个由系统时钟定时更新的变量。 当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为volatile，关键字volatile告诉编译器不应对这样的对象进行优化。 . volatile限定符的用法和const几乎一样，遵循各种const的规则，且const能和volatile同时作用与一个对象中。 . 一般定义volatile对象的语句形式为 . | volatile 类型说明符 变量名 (初始化); . | 类型说明符 volatile 变量名 (初始化); . | . 类的非静态函数成员能定义成const成员函数，所以非静态函数成员也能定义成volatile的。 volatile对象为类类型时，其不能使用该类型的非volatile的非静态成员函数。 . struct Cls { // volatile的成员函数prints void prints(int) volatile { cout &lt;&lt; \"vo\"; } void nprints() {} }; volatile Cls obj; // 正确：volatile对象可以调用其volatile成员函数prints obj.prints(15); // 错误：volatile对象不能使用非volatile的非静态成员函数 obj.nprints(); . volatile限定符的用法有一点与const不同，这也就是： 我们不能使用合成的拷贝/移动构造函数及赋值运算符来初始化或赋值类类型中的volatile数据成员。 所以我们必须自定义这些函数来初始化或赋值volatile数据成员。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#143-volatile%E9%99%90%E5%AE%9A%E7%AC%A6",
    
    "relUrl": "/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#143-volatile限定符"
  },"134": {
    "doc": "固有的不可移植特性概念详解",
    "title": "14.4 链接指示",
    "content": "C++程序有时需要调用其他语言编写的函数，或者其他语言有时也需要调用C++编写的函数，最常见的是C和C++。 C++使用链接指示（linkage directive）指出任意非C++函数所用的语言。 . 链接指示语句只能用C++编译器编译，所以所有涉及到链接指示语句的文件要用C++编译器编译。 . 要想把C++代码和其他语言（包括C语言）编写的代码放在一起使用(也就是相互都可以使用)，要求我们所使用的C++编译器必须能够有权访问该语言的编译器，并且也兼容这个语言的编译器。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#144-%E9%93%BE%E6%8E%A5%E6%8C%87%E7%A4%BA",
    
    "relUrl": "/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#144-链接指示"
  },"135": {
    "doc": "固有的不可移植特性概念详解",
    "title": "14.41 C++调用其他语言的函数",
    "content": "像所有其他名字一样，其他语言中的函数名字也必须在C++中进行声明，并且该声明必须指定返回类型和形参列表。 对于其他语言编写的函数来说，编译器检查其调用的方式与处理普通C++函数的方式相同，但是生成的代码有所区别。 . 链接指示可以有两种形式：单个的或复合的： . | extern 字符串字面值 函数声明或定义语句 . | extern 字符串字面值 { 多个函数的声明或定义语句 } . | . 这两种形式都是首先包含一个关键字extern，后面跟是一个字符串字面值以及一个普通的函数声明或定义。 . 字符串字面值指出了编写函数所用的语言。比如\"C\"、\"Ada\"、\"FORTRAN\"等。 . 函数声明或定义语句也就是其他语言编写的函数，这些函数必须指定返回类型和形参列表。 . 对于第二种花括号括起的形式，它可以支持多个其他语言函数的链接指示。 花括号的作用是将其中的多个声明或定义聚合在一起，一次性建立多个链接，花括号中声明或定义的函数名字就是可见的，就好像在花括号之外声明或定义的一样。 花括号中还可以包含#include指令，当一个#include指令被放置在的花括号中时，头文件中的所有普通函数声明或定义都会被认为是由链接指示的语言编写的。 . 链接指示可以嵌套，如果花括号中包含带自带链接指示的函数，则该函数的还是按自己的链接来，不受外层链接指示的影响。 . 对于某个函数来说，如果其函数声明已带有链接指示，则该函数的定义可以不用再显式写明其链接指示，编译器会自动匹配该函数的定义并将其视为对应语言的函数。 对于某个带有链接指示的函数声明或定义，其函数的其他声明最好也应带有链接指示，且链接指示必须一致。 . // 文件test.h extern \"C\" void print(); extern \"C\" { int ret(); void get(int); } // 文件test.cpp // 会编译为test.o #include \"test.h\" void print() { /*···*/ } extern \"C\" int ret() { /*···*/ } void get(int) { /*···*/ } // 文件test2.cpp // 会链接test.o #include \"test.h\" int main() { print(); int ins = ret(); get(5); } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#1441-c%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#1441-c调用其他语言的函数"
  },"136": {
    "doc": "固有的不可移植特性概念详解",
    "title": "14.411 链接指示指针",
    "content": "我们还可以声明或定义指向其他语言的函数的指针，该指针的声明或定义与普通的指针声明或定义类似，就在前面加上关键字extern和表示语言的字符串字面值 . 链接指示指针的形式为： . extern 字符串字面值 函数指针声明或定义语句 . 该函数指针声明或定义语句也必须指定返回类型和形参列表。 . // pf指向一个C函数，该函数接受一个int返回void extern \"C\" void (*pf) (int); . 链接指示指针可以初始化、赋值和使用，但是它只能对该语言对应声明的函数使用，C++的函数不能和它起作用，否则出错。 . //指向一个C++函数 void (*pf1) (int); //指向一个C函数 extern \"C\" void (*pf2) (int); //错误：pfl和pf2的类型不同 pf1 = pf; . 如果链接指示指针的返回类型或者某形参是函数指针类型时，这些返回类型或者形参也是链接指示指针。 . // f1是一个C函数，它的形参是一个指向C函数的指针 extern \"C\" void f1(void(*) (int)); . 如果我们希望某个C++函数的返回类型或者某形参是链接指示指针类型时，则我们必须使用类型别名，来声明这些链接指示指针可以当做C++函数的返回类型或者某形参。 . 形式为： . extern 字符串字面值 typedef 函数指针声明语句 . // FC是一个指向C函数的指针 extern \"C\" typedef void FC(int); // f2是一个C++函數，该函数的形参是指向C函数的指针 void f2(FC*); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#14411-%E9%93%BE%E6%8E%A5%E6%8C%87%E7%A4%BA%E6%8C%87%E9%92%88",
    
    "relUrl": "/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#14411-链接指示指针"
  },"137": {
    "doc": "固有的不可移植特性概念详解",
    "title": "14.42 其他语言调用C++的函数",
    "content": "我们也可以令C++函数在其他语言编写的程序中可用，也可以在其他语言中声明或定义指向C++函数的指针(如果该语言有指针的话)。 . 这些也是用链接指示来声明或定义的，形式一模一样，只要在表示语言的字符串字面值中写上所要用C++函数的语言就行。 . // calc函数可以被C程序调用 extern \"C\" double calc(double dparm) { /* ...*/ } // ptr函数指针可以在C程序中指向C++函数 extern \"C\" double (ptr*) (double); . 值得注意的是，可被其他语言使用的C++函数的返回类型或形参类型会受到很多限制。 例如，我们不太可能把一个C++类的对象传给C程序，因为C程序根本无法理解构造函数、析构函数以及其他类特有的操作。 . 因为C语言也不支持函数重载，所以我们在定义能被C程序使用的C++函数时不能定义多个名字相同的函数。 . //错误：两个extern \"C\"函数的名字相同 extern \"C\" void print(const char*); extern \"C\" void print(int); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#1442-%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8c%E7%9A%84%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html#1442-其他语言调用c的函数"
  },"138": {
    "doc": "固有的不可移植特性概念详解",
    "title": "固有的不可移植特性概念详解",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html",
    
    "relUrl": "/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html"
  },"139": {
    "doc": "第十五章 标准库",
    "title": "第十五章 标准库",
    "content": "第15章介绍了一些常用的C++标准库以及这些标准库的接口和用法。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/index.html",
    
    "relUrl": "/guide_files/chap15/index.html"
  },"140": {
    "doc": "标准库详解",
    "title": "15.1 标准库概念",
    "content": "C++标准库（standard library）是C++委员会所提供的由C++语言所编写的一系列头文件。 这些库扩展了很多C++的操作，比如C++语言并未定义任何输入输出操作，所以输入输出操作是由标准库来提供的，C++标准库还提供了其他许多的功能。 . 因为标准库是官方所提供的头文件，不是语言自带的语言特性，所以我们在使用标准库时必须要用#include预处理指令来包含所需要使用的标准库头文件。 . 对于标准库头文件来说，#include预处理指令后的文件名是用符号&lt;&gt;而不是\"\"来包含。 . // c++输入输出标准库文件 #include &lt;iostream&gt; . 因为C++是从C语言的基础上拓展而来的，所以C++语言也兼容了C语言的标准库。 我们可以直接使用C语言标准库，也可以使用有C++修改后的C语言标准库，这些经过C++修改后的C语言标准库和原始标准库的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。 修改后的C语言标准库与原始的C语言标准库有以下区别： . | 修改后的C语言标准库的所有头文件名都在其最前面加上了字母c，而且末尾也不用再加.h。 | 修改后的C语言标准库中定义的名字从属于命名空间std，而原始标准库中的则不然。 | . // C语言输入输出标准库文件 #include &lt;stdio.h&gt; // 经过C++修改后的C语言输入输出标准库文件 #include &lt;cstdio&gt; . 对于C++标准库来说，我们所常用的操作分为以下几个部分： . | 输入输出操作(io操作) | 容器 . | 顺序容器 | 关联容器 | . | 迭代器 | 泛型算法 | 多类型集合 . | tuple类型 | . | 位集合 . | bitset类型 | . | 正则表达式 | 随机数 | 内存管理 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#151-%E6%A0%87%E5%87%86%E5%BA%93%E6%A6%82%E5%BF%B5",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#151-标准库概念"
  },"141": {
    "doc": "标准库详解",
    "title": "15.2 输入输出操作",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#152-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#152-输入输出操作"
  },"142": {
    "doc": "标准库详解",
    "title": "15.21 输入输出概念",
    "content": ". ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#1521-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A6%82%E5%BF%B5",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#1521-输入输出概念"
  },"143": {
    "doc": "标准库详解",
    "title": "15.211 条件状态",
    "content": ". ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#15211-%E6%9D%A1%E4%BB%B6%E7%8A%B6%E6%80%81",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#15211-条件状态"
  },"144": {
    "doc": "标准库详解",
    "title": "15.212 操纵符",
    "content": ". ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#15212-%E6%93%8D%E7%BA%B5%E7%AC%A6",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#15212-操纵符"
  },"145": {
    "doc": "标准库详解",
    "title": "15.2121 输出补白",
    "content": ". ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#152121-%E8%BE%93%E5%87%BA%E8%A1%A5%E7%99%BD",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#152121-输出补白"
  },"146": {
    "doc": "标准库详解",
    "title": "15.213 未格式化IO",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#15213-%E6%9C%AA%E6%A0%BC%E5%BC%8F%E5%8C%96io",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#15213-未格式化io"
  },"147": {
    "doc": "标准库详解",
    "title": "15.2131 单字节操作",
    "content": ". ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#152131-%E5%8D%95%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#152131-单字节操作"
  },"148": {
    "doc": "标准库详解",
    "title": "15.2132 多字节操作",
    "content": ". ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#152132-%E5%A4%9A%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#152132-多字节操作"
  },"149": {
    "doc": "标准库详解",
    "title": "15.214 流随机访问",
    "content": ". ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#15214-%E6%B5%81%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#15214-流随机访问"
  },"150": {
    "doc": "标准库详解",
    "title": "15.22 fstream",
    "content": ". ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#1522-fstream",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#1522-fstream"
  },"151": {
    "doc": "标准库详解",
    "title": "15.23 stringstream",
    "content": ". ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#1523-stringstream",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html#1523-stringstream"
  },"152": {
    "doc": "标准库详解",
    "title": "标准库详解",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html",
    
    "relUrl": "/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html"
  },"153": {
    "doc": "第二章 基本类型与变量",
    "title": "第二章 基本类型与变量",
    "content": "第2章分布: . | 开始几节先介绍了基本的数据类型和变量的定义声明，然后介绍了c++所含有的各种隐式和显式转换。 | 中间介绍了c++的几种复合类型：数组、引用与指针。 | 最后几节介绍了c++的几种限定符、类型别名和类型自动推断机制。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/index.html",
    
    "relUrl": "/guide_files/chap2/index.html"
  },"154": {
    "doc": "类型与变量",
    "title": "2.1 基本数据类型",
    "content": "cpp的数据类型衍生与c的数据类型，以下为cpp的数据类型分类 . | 空类型(void) | 算术类型 . | 基本类型 . | 整数类型 . | 短整型(short) | 整型(int) | 长整型(long) | 双长整型(long long) | 字符型(char) . | 宽字符(wchar_t) | Unicode字符(char16_t/char32_t) | . | 布尔型(bool) | . | 浮点型 . | 单精度浮点型(float) | 双精度浮点型(double) | 扩展精度浮点型(long double) | . | . | . | 复合类型 . | 数组类型([]) | 引用类型 . | 左值引用(&amp;) | 右值引用(&amp;&amp;) | . | 指针类型(*) . | 普通指针 | 与数组有关的指针 | 函数指针 | 类成员指针 | . | . | 派生类类型 . | 函数类型 | 自定义类型(类类型)(struct/class) | 枚举类型(enum) | 共用体类型(union) | . | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#21-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#21-基本数据类型"
  },"155": {
    "doc": "类型与变量",
    "title": "2.12 算术类型",
    "content": "基本内置类型是由系统定义的，最基本的几种类型，我们常用的比如字符，整型都是基本类型，以下是基本数据类型的分类 . | 算术类型 . | 整数类型 . | 短整型(short) | 整型(int) | 长整型(long) | 双长整型(long long) | 字符型(char) . | 宽字符(wchar_t) | Unicode字符(char16_t/char32_t) | . | 布尔型(bool) | . | 浮点型 . | 单精度浮点型(float) | 双精度浮点型(double) | 扩展精度浮点型(long double) | . | . | . 类型的尺寸也就是该类型数据所占的比特数，在不同机器上有所差别，类型数据所占的比特数的不同，可以决定了该类型能够表示的数据范围。 . 以下是各个类型所规定的的尺寸 . 布尔类型（bool）的取值是真（true）或者假（false）。 . C++提供了几种字符类型，其中多数支持国际化。基本的字符类型是char, 一个char 的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char 的大小和一个机器字节一样。 . 其他字符类型用于扩展字符集，如wchar_t, charl6_t, char32_t。 . wchar_t类型用于确保可以存放机器最大扩展字符集的任意一个予符，类型char16_tln char32_t则为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）。 . 除字符和布尔类型之外，其他整型用于表示（可能）不同尺寸的整数。C++语言规定一个int至少和一个short一样大,一个long至少和一个int一样大，一个long long至少和一个long一样大。其中，数据类型long long是在C++11中新定义的。 . 浮点型可表示单精度、双精度和扩展精度值。C++标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，float以1个字（32比特）来表示，double以2个字（64比特）来表示，long double以3或4个字（96或128比特）来表示。一般来说，类型float和double分别有7和16个有效位；类型long double则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。 . 计算机以比特序列存储数据，每个比特非0即1,例如： . 00011011011100010110010000111011 . 大多数计算机以2的整数次寡个比特作为块来处理内存，可寻址的最小内存块称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常由几个字节组成。在C++语言 中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8比特构成， 字则由32或64比特构成，也就是4或8字节。 大多数计算机将内存中的每个字节与一个数字（被称为“地址（address ）”）关联起 来，在一个字节为8比特、字为32比特的机器上，我们可能看到一个字的内存区域如下所示： . 其中，左侧是字节的地址，右侧是字节中8比特的具体内容。 我们能够使用某个地址来表示从这个地址开始的大小不同的比特串，例如，我们可能会说地址736424的那个字或者地址736427的那个字节。为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。 如果位置736424处的对象类型是float,并且该机器中float以32比特存储， 那么我们就能知道这个对象的内容占满了整个字.这个float数的实际值依赖于该机 器是如何存储浮点数的。或者如果位置736424处的对象类型是unsigned char,并且 该机器使用ISO-Latin-l字符集，则该位置处的字节表示一个分号。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#212-%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#212-算术类型"
  },"156": {
    "doc": "类型与变量",
    "title": "2.121 无符号类型",
    "content": "除去布尔型和扩展的字符型外，其他的整型可以划分为两种 . | 带符号的(signed) | 无符号的(unsigned) | . 带符号的可以表示正，负和0的数，cpp规定了在表示范围内正值和负值的量应该保持平衡。比如8bit的signed char通常表示范围为-128至127。 . 而无符号的不能表示负数，但无符号中能表示的数据范围还是一样大。比如8bit的unsigned char通常表示范围为0-255。 . 非字符型整型可以通过在类型名前添加unsigned就可以成为无符号型, 如long的无符号型的就是unsigned long。类型unsigned int可以缩写成unsigned，其他的类型不行。 . 字符型整型被分为三种： . | char | signed char | unsigned char | . 其中要注意的是char和signed char并不一样，因为其中char类型是由编译器决定是为signed char还是unsigned char。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2121-%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2121-无符号类型"
  },"157": {
    "doc": "类型与变量",
    "title": "2.13 字面值常量",
    "content": "形如55的值被称为字面值常量(literal)，字面值常量是不能被修改的值，所以字面值常量都为const类型，且也都是右值表达式。 根据它的形式和值，可以分为七种字面值常量类型： . | 整型字面值 | 浮点型字面值 | 字符字面值 | 字符串字面值 | 布尔字面值 | 指针字面值 | 自定义字面值 | . 当字面值被使用时，编译器会根据该字面值的数据创建一个含有该数据的临时对象。这个临时对象会代替之后的对字面值的所有操作。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#213-%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#213-字面值常量"
  },"158": {
    "doc": "类型与变量",
    "title": "2.131 整型字面值",
    "content": "整型字面值是为整型类型的字面值，形如42，3等。 我们可以将整型字面值写作十进制数，八进制数，十六进制数的形式，以下都表示十进制数20 . | 八进制数是以0开头的整数，如024 | 十六进制数是以0x或0X开头的整数，如0x14 | 除此以外形式的整数都是十进制数，如20 整型字面值的具体类型由其值和符号共同决定。 默认情况，十进制是带符号数，八进制数和十六进制可能是带符号或者无符号数。虽然十进制是带符号，十进制字面值不会是负值，即使我们使用了形如-42十进制字面值，但那个负号并不是字面值的，负号的作用只是让其取负值而已。 它们的尺寸是当前能够容纳下它们值的最小类型。如果最大类型都容纳不下，就会发生错误。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2131-%E6%95%B4%E5%9E%8B%E5%AD%97%E9%9D%A2%E5%80%BC",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2131-整型字面值"
  },"159": {
    "doc": "类型与变量",
    "title": "2.132 浮点字面值",
    "content": "浮点字面值是为浮点类型的字面值，形如3.6等。 浮点字面值可以表示为 . | 小数表示，如 . | 3.14 | 0. | .005 | . | 科学计数法表示的指数，指数的底数是为10，指数部分用e或E标识 . | 3.1415e0 | 2E10 | . | . 和整型字面值一样，浮点字面值的具体类型由其值和符号共同决定。 默认情况，浮点字面值类型为double . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2132-%E6%B5%AE%E7%82%B9%E5%AD%97%E9%9D%A2%E5%80%BC",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2132-浮点字面值"
  },"160": {
    "doc": "类型与变量",
    "title": "2.133 字符字面值",
    "content": "字符字面值是为const char类型的字面值，形如 . 's' . 字符字面值是由单括号括起来的一个字符，如 . 'a' . 单括号(‘)通常只用来括单个字符，但也可以用来括多个字符，不过括多个字符时是未定义行为，编译器会警告 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2133-%E5%AD%97%E7%AC%A6%E5%AD%97%E9%9D%A2%E5%80%BC",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2133-字符字面值"
  },"161": {
    "doc": "类型与变量",
    "title": "2.134 字符串字面值",
    "content": "字符串字面值是为const char* 类型的字面值，形如\"bag\"等。 字符串字面值是由双括号括起来的零个或多个字符构成的，如\"hello world\"。 编译器在处理字符串字面值时，会再每个字符串字面值末尾添加一个空字符’\\0’，因此字符串字面值的实际长度比它内容多1。如字符串字面值\"dog\"的实际长度为4，分别是'd','o','g','\\0'。 . 如果两个字符串字面值位置紧邻且仅由空格，缩进，换行符分隔，则他们实际是一个整体，比如 . \"I'm a good boy.\" \"you are a nice girl.\"; //分多行书写的字符串字面值 . 上面是一个字符串字面值而不是两个。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2134-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2134-字符串字面值"
  },"162": {
    "doc": "类型与变量",
    "title": "2.135 布尔字面值和指针字面值",
    "content": "true和false是布尔类型的字面值。 nullptr是指针类型的字面值。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2135-%E5%B8%83%E5%B0%94%E5%AD%97%E9%9D%A2%E5%80%BC%E5%92%8C%E6%8C%87%E9%92%88%E5%AD%97%E9%9D%A2%E5%80%BC",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2135-布尔字面值和指针字面值"
  },"163": {
    "doc": "类型与变量",
    "title": "2.136 转义序列",
    "content": "有两种特殊字符是我们不能直接使用的 . | 不可打印字符(nonprintable) | 特殊含义的字符 | . 不可打印字符：是没有可是图标的字符，如退格，换行等。 . 特殊含义的字符： 是在c++中有特殊含义的字符，如单引号，双引号等。 . 要想用到这两种特殊字符，我们必须要用到转义序列(escape sequence)，转义序列的形式是反斜线后面跟一个字符。如\\n (换行符)。 转义序列可以当成普通的字符字面值来使用，如 . std::cout &lt;&lt; \"Hi, mom!\\n\"; . 以下是c++规定的转义序列 . | 转义序列可以用来表示不可打印字符，如\\n表示的是换行符 . | 转义序列也可以用在特殊含义的字符前，使其可以正常使用，如单引号正常情况下当不了单引号的符号，所以我们可以用'来表示单引号 . | 特殊字符的转义序列不仅可以用反斜线后面跟一个字符的形式来表示，还可以用反斜线后面跟一个八进制或十六进制的整型字面值的形式来表示(其中八进制位数要在3以内)，整型字面值表示的是其字符对应的数值。如 . | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2136-%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2136-转义序列"
  },"164": {
    "doc": "类型与变量",
    "title": "2.137 显式指定字面值的类型",
    "content": "通过在字面值的前面或者是后面添加一些特殊的字面值，可以改变整型、浮点型和字符型字面值的默认类型。 下表为特殊字面值 . 特殊字面值和普通字面值之间不能有空格等空白字符 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2137-%E6%98%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E5%AD%97%E9%9D%A2%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2137-显式指定字面值的类型"
  },"165": {
    "doc": "类型与变量",
    "title": "2.138 自定义字面值",
    "content": "当我们使用字面值常量时，有时候会想要改变一些字面值的类型或者对其进行一些操作，此时可以自定义一些字面值来对其操作。 . 自定义字面值的定义 . 定义自定义字面值是用字面值运算符函数进行的。定义一个自定义字面值就需要定义一个对应的字面值运算符函数。 . 和其他运算符函数一样，定义形式为： . 返回类型 operator”” 自定义字面值名 形参表 函数体 . 和其他运算符函数一样，可以有重载函数，自定义字面值名相同的函数就是重载函数。 和其他运算符函数一样，形参里不能有默认实参 . 自定义字面值名一般约定的命名规范为以下划线开头加小写字母。 . 自定义字面值就是将其前面的普通字面值当成实参传递给字面值运算符函数进行运算，最后返回一个返回类型的对象。 字面值运算符函数的返回类型没有限制，但是其形参表有特殊的限制，其形参数量一般都只能有一个，用来表示普通字面值的类型： . | 作用于整型字面值的自定义字面值的形参类型只能为unsigned long long。 | 作用于浮点字面值的自定义字面值的形参类型只能为long double。 | 作用于字符字面值的自定义字面值的形参类型能为普通字符，宽字符和Unicode字符。 | 作用于字符串字面值的自定义字面值的形参类型能为指向常量普通字符的指针，指向常量宽字符的指针和指向常量Unicode字符的指针，且可以有第二个类型为size_t的形参，用来表示字符串的长度。 | . // 定义了整型，浮点和字符字面值转换成string类型的自定义字面值 // 字符串字面值转换成浮点数的自定义字面值 // 用的是string类自带的数值转换 string operator \"\"_litToStr(unsigned long long ins) { return to_string(ins); } string operator \"\"_litToStr(long double dou) { return to_string(dou); } string operator \"\"_litToStr(char ch) { return string{} + ch; } double operator \"\"_litToDou(const char* cstr, size_t len) { return stod(cstr); } . 自定义字面值的使用 . 要注意，我们此时所说的自定义字面值必须要结合系统自带的非布尔和指针类的普通字面值才能操作，不能对系统自带的特殊字面值使用。 . 且自定义字面值必须放在普通字面值之后，且中间不能有空格等空白字符。 . 自定义字面值可以和前缀特殊字面值结合使用，不能和后缀特殊字面值使用(会导致编译器识别不了) . // 定义了整型，浮点和字符字面值转换成string类型的自定义字面值 // 字符串字面值转换成浮点数的自定义字面值 // 用的是string类自带的数值转换 string operator \"\"_litToStr(unsigned long long ins) { return to_string(ins); } string operator \"\"_litToStr(long double dou) { return to_string(dou); } string operator \"\"_litToStr(char ch) { return string{} + ch; } double operator \"\"_litToDou(const char* cstr, size_t len) { return stod(cstr); } // 调用 _litToStr(unsigned long long ins) cout &lt;&lt; 88_litToStr; // 调用 _litToStr(long double dou) cout &lt;&lt; 64.18_litToStr; // 调用 operator \"\"_litToStr(char ch) cout &lt;&lt; '1'_litToStr; // 调用 _litToDou(const char* cstr, size_t len) cout &lt;&lt; \"-3.1848\"_litToDou; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2138-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E5%80%BC",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2138-自定义字面值"
  },"166": {
    "doc": "类型与变量",
    "title": "2.2 变量",
    "content": "变量提供一个具名的、可供程序操作的存储空间。c++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。 . 对C++程序员来说，一般情况下，”变量(variable)”和”对象(object)”可以互换使用。 . 变量和对象的区别： . 对象是指在内存中有自己内存空间的实体。 变量是指有名字(标识符)表示的对象，而对象有可能是一个无名对象(临时对象)。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#22-%E5%8F%98%E9%87%8F",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#22-变量"
  },"167": {
    "doc": "类型与变量",
    "title": "2.21 变量的定义与声明",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#221-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#221-变量的定义与声明"
  },"168": {
    "doc": "类型与变量",
    "title": "2.211 变量的定义",
    "content": "当我们需要一个变量来进行操作时，可以定义变量。 变量定义的基本形式是：首先是类型说明符(type specifier)，也就是说明其变量的类型，也就是变量定义的基本类型。随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔。列表中每个变量名的类型都由刚开始指定的类型说明符指定，定义时还可以为一个或多个变量赋初值： . 基本类型(类型说明符) 变量名1(可选 初始化), 变量名2(可选 初始化)，… . int sum = 0, value, units_sold = 0; //sum、value 和 units_sold 都是 int // sum 和 units_sold 初值为 0 . 要注意在大多数用法上，变量的定义是一个语句，而语句的结尾必须要有分号。 而且一个定义表达式有且仅有在开头的一个类型说明符，而不能在定义表达式的其他地方存在类型说明符。 . // 以下都为错误定义 int a = 8 int i = int j = 2; k = int b; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2211-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2211-变量的定义"
  },"169": {
    "doc": "类型与变量",
    "title": "2.212 变量的初始化",
    "content": "当对象在创建时获得了一个特定的值，我们说这个对象被初始化(initialized) 了。 用于初始化变量的值可以是任意复杂的表达式。当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义表达式中，可以用先定义的变量值去初 始化后定义的其他变量。 . 要注意无论用什么形式来初始化，用来初始化其他变量的对象的值都不会有改变。 . //正确：price先被定义并赋值，随后被用于初始化discount double price = 109.99, discount = price * 0.16; . 不要用未定义的变量去初始化其他变量，如 . //错误 int i = j = 3; . 因为根据变量定义的规则，编译器是从左到右，先执行第一个变量的定义和初始化，再接着对第二个变量执行。所以当执行i的初始化时，由于j还未定义，所以就会出错。 . 正确的方法应该是这样 . //正确 int j = 6; int i = j = 3; // i定义时初值由j提供，i被初始化为6。 // 由于等号的结合律是从右到左，所以再进行赋值表达式，j变为3， // 接着i被赋值为3。最终i为3，j为3 . 要注意： 初始化不是赋值 变量初始化是在变量定义时就开始的，所有变量在定义后进行的值的改变都只是赋值而不是初始化。 初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代，也就是用等号将右边的对象的值给左边的变量 . c++定义了多种初始化语句形式，可分为两类： . | 直接初始化 . | 变量类型名 变量名(初始值)，如 int sold_num(3); | 变量类型名 变量名{初始值}，如 int sold_num{3}; | . | 拷贝初始化 . | 变量类型名 变量名= 初始值/(初始值)，如 int sold_num = 3; int sold_num = (3); | 变量类型名 变量名= {初始值}，如 int sold_num = {3}; | . | . 我们可以观察到，所有不用赋值运算符的初始化都是直接初始化。 . 拷贝初始化的语句形式不仅是初始化的语句形式，也是赋值时的语句形式。 . 拷贝和赋值一般指的都是某对象能够将自己的值赋给其他变量，使其值与自己的一样的能力 而拷贝强调的是在其他变量的初始化过程时的能力，赋值则是非初始化过程时的能力。 简单来说，拷贝指的是初始化时的赋值。 . C++11新标准规定了可以用花括号來初始化变量 ，这种初始化的形式被称为列表初始化(list initialization)。列表初始化是利用花括号，把一个或多个初始值放在一起的初始化形式。 现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用这样由花括号括起来的初始值了 . 当用于内置类型的变量时，列表初始化有个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错（或者报警）： . long double ld = 3.1415926536; int a{ld}, b = {ld}; //错误：转换未执行，因为存在丢失信息的危险 int c(ld), d = ld; //正确：转换执行，且确实丢失了部分值 . 用列表初始化时，列表所给的初始值数量不能大于所给类型所规定的初始值数量，对于算术类型和除了数组类型的复合类型来说，这些类型的对象所规定的初始值数量为1。 . 在用列表初始化时，如果列表所给的初始值数量小于所给类型所规定的初始值数量，那么其他没有被初始值初始化的值会被值初始化。 . // 错误：初始值数量过多 int ins = {3,5,8}; // 正确：初始值数量小于1，所以ins2的值被值初始化为0。 int ins2 = {}; // 正确：初始值数量为1，所以ins2的值被初始值初始化为5。 int ins3 = {5}; . 默认初始化 . 如果定义变量时没有指定初值，则变量被默认初始化（default initialized），此时变量被赋予了 “默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。 . 对于以下这些类型来说，都视为内置类型： . | 算术类型 | 复合类型 | 函数类型 | 枚举类型 | . 其中const，constexpr和引用类型不能默认初始化，必须显式初始化。 . 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。 . 定义于任何函数体之外的变量被初始化为0。 . 在函数体内部(包括main函数)的内置类型变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。 . 所有的类类型和共用体类型各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。 . 值初始化 . 值初始化一般出现在类类型的初始化过程中，也可以说是某些类类型的默认初始化。 . 值初始化就是当某变量初始化时没有指定初值，如果该变量为算术类型或者复合类型时，则该变量的值自动设为0，空或者其内部的元素也被值初始化的一种(根据该变量的类型决定)；如果该变量为类类型，则其执行默认初始化。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2212-%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2212-变量的初始化"
  },"170": {
    "doc": "类型与变量",
    "title": "2.213 变量的声明",
    "content": "当我们目前只想创建一个变量，而不想初始化，或者想使用其他文件里定义的变量并在当前文件标出来时，就可以进行变量声明。 由于编译器是从上到下编译，后面定义或声明的变量，前面的代码不能使用他们。所以可以通过先在前面声明，再到后面定义来使定义之前的代码能够使用到这个变量 . 声明和定义的区别 . | 声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。 定义(definition)负责创建与名字关联的实体。 | 定义包含声明的作用，当一个变量被定义时也就同时被声明了，反之不是。 | 当变量只声明但没有定义过时，此变量无法使用也无法被赋值，所以要想使用变量，则必须要定义过才行。 | 变量能且只能被定义一次，同名同作用域同形参类型的变量多次定义会导致重复定义。但是同一变量可以被多次声明。 | 同一作用域内不能出现同名但不同声明的的变量，同一变量的多次声明的类名和类型修饰符等要一模一样才行，否则出错。 | . 声明的形式 . 如果想声明一个变量而非定义它，就在变量名前添加关键字extern,而且不要显式地初始化变量。 . 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。 而在函数体外部，任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋初始值，但是这么做也就抵消了extern的作用。含extern的表达式如果包含初始值就不再是声明，而变成定义了 . extern int i; //声明i而非定义i int j; //声明并定义j extern double pi = 3.14159; // 定义 . 同一个变量的声明和定义要严格一致，包括各种类型修饰符也要相同，否则就成了另一个变量或者出错。 . extern const int ins; // 错误定义：声明和定义不一致 int ins = 15; // 正确定义 int ins = 15; . 变量的声明和定义一样，大多数用法上都是语句，且遵循变量定义的规则。 . // 以下都为错误声明 extern int a = 8 int i = extern int j = 2; k = extern int b; . 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2213-%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2213-变量的声明"
  },"171": {
    "doc": "类型与变量",
    "title": "2.214 变量的命名",
    "content": "标识符就是用于表示各种对象，实体，操作等事物的==字符序列==(sequence of characters)。 . 标识符可以用于表示以下这几种事物： . | 对象或变量的名称 | 类型、结构体、联合类和枚举类的名称以及它们成员的名称 | 函数名称以及其参数的名称 | 类型别名 | 标签名称 | 宏名称以及其参数的名称 | . 同一作用域下的某些事物的名称必须有所区别： . | 各种类型的变量名要和函数名有所区别 | 各种类型的变量名之间要有所区别 | 各种类型名之间要有所区别 | . 标识符只能由==字母、数字、下划线_和美元符号$组成==，其中必须以字母、下划线或者美元符号开头。标识符的长度没有限制，但是对大小写字母敏感。 . 同时C++语言也保留了一些名字供语言本身使用，这些名字也叫做关键字，关键字不能被当做名称来使用。 . 变量的命名规范 . 变量命名有许多约定俗成的规范，下面的这些规范能有效提高程序的可读性： . | 用户自定义的标识符中尽量不要连续出现两个下划线，也不要以下划线紧连大写字母开头。此外，定义在函数体外的标识符也不要以下划线开头。因为这些通常是系统标识符的命名形式。 | 标识符要能体现实际含义。 | 变量名一般用小写字母，如index,不要使用Index或INDEX。 | 用户自定义的类名一般以大写字母开头，如Sales_item。 | 如果标识符由多个单词组成，则单词间应有明显区分，如student_loan或studentLoan，而不要使用studentloan。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2214-%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2214-变量的命名"
  },"172": {
    "doc": "类型与变量",
    "title": "2.215 名字的作用域",
    "content": "不论是在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、类型等。 每个命名的实体都有两个属性： . | 名字 | 作用域 | . 这也就表示一个名字如果出现在程序的不同位置，也可能指向的是不同实体。 . 作用域(scope)是程序的一部分，C++语言中大多数作用域都以花括号分隔。 同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明表达式，以声明表达式所在的作用域末端为结束。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2215-%E5%90%8D%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2215-名字的作用域"
  },"173": {
    "doc": "类型与变量",
    "title": "2.2151 作用域分类",
    "content": "作用域根据大小分为： . | 全局作用域(global scope) | 块作用域/局部作用域(block scope) | . 全局作用域是定义于某文件所有花括号({})之外的实体所拥有的作用域，一旦声明之后，全局作用域内的名字在整个程序的范围内都可使用。 . 在全局作用域中只能存在各种声明和定义语句，不能存在其他类型的语句。 . 块作用域，也叫做局部作用域，是定义于某花括号之内的实体所拥有的作用域，在花括号之外是无法访问的。 . 作用域根据包含关系分为： . | 内层作用域(inner scope) | 外层作用域(outer scope) | . 作用域能彼此包含，被含(或者说被嵌套)的作用域称为内层作用域，包含着别的作用域的作用域称为外层作用域。 . 作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。 . 同时，允许在内层作用域中用外层作用域己有的名字来声明或定义一个新的块作用域的实体。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#22151-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%88%86%E7%B1%BB",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#22151-作用域分类"
  },"174": {
    "doc": "类型与变量",
    "title": "2.2152 编译器匹配规则",
    "content": "在c++中，编译器的匹配顺序为： . | 先进行名字查找， | 再进行类型检查。 | . 根据匹配对象不同，编译器的匹配过程可以分为三种： . | 对于用存储说明符extern的变量声明表达式(非定义)。 | 对于非extern的变量声明表达式(非定义)和变量定义表达式的声明部分。 | 对于各种使用实体(包括变量和类类型的使用)的表达式。 | . 对于用extern的变量声明表达式(非定义)来说： . 当变量的声明在全局作用域下的块作用域(比如定义的函数体或者类体等)内或者在全局作用域中时： . 名字查找顺序为： . | 先查找该声明的同一作用域的所有位置。 | (只用于非全局作用域中的变量声明)再查找全局作用域中(不查找该作用域的内层作用域)的所有位置。 | . 判断规则为： . | (全局作用域下的块作用域的变量声明所独有的规则)该声明的同一作用域中不能有同名变量的各种定义语句(包括该声明对应的定义语句)。 | 所查找的各个作用域中： . | 不能有同名变量的其他不同声明语句。 | 同名变量的定义语句只能有一个，且必须是对应该声明的。 | . | . 对于非extern的变量声明表达式(非定义)和变量定义表达式的声明部分来说： . | 关于含有extern变量声明表达式的情况遵循extern变量声明表达式的规则。 | 对于非extern的变量声明表达式(非定义) 来说，同一作用域中不能含有仅仅只有返回类型不同的多个声明表达式(对于函数声明)。 | 对于变量定义表达式的声明部分来说，除了函数重载，同一作用域中不能有其他同名变量的定义语句。 | . 对于各种使用实体(包括变量和类类型的使用)的表达式来说： . | 从使用该实体的位置向上查找与其名字一样的实体的声明或定义语句。 如果没找到，则终止程序并提示未定义变量的错误。 向上查找只会找该位置所属的作用域以及包含该位置作用域的外层作用域，不会找里层作用域的。 . | 如果找到了一个实体的声明语句，则向上查找该声明语句对应的定义语句(找到不对应的定义语句也要继续向上查找)。 如果没找到对应的定义语句，则终止程序并提示未定义实体或声明不匹配的错误。 | 如果找到了实体声明语句对应的定义语句，则开始进行类型检查: . | 检查该定义语句所在的作用域内是否存在重复的定义语句。 如果存在，则终止程序并提示重复定义的错误；否则继续之后的类型检查。 | 对于实体为变量时，检查该变量的类型是否符合使用的条件。 如果不符合，则终止程序并提示类型错误；符合则使用合法。 | . | . 注意 . | 因为编译器是==先进行名字查找，再进行类型检查==，所以在内外层都有同名的实体时，在非显式指定时某实体时，编译器是不会去查找外层的同名实体的，即使内层的同名实体类型不匹配也不会去查找外层的。 | 所以在内层作用域中用外层作用域己有的名字来声明或定义一个新的块作用域的实体。新定义的实体在其作用域内会隐藏掉外层的同名实体，所以在其作用域内无法直接访问外层的同名实体，但可以用作用域运算符来显式访问外层的同名实体。 | 注意声明的规则，只声明而没定义过的变量是不能使用和赋值的 | 当非静态对象在离开其作用域时会自动销毁，所以其对象不能通过声明来扩展其作用域的 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#22152-%E7%BC%96%E8%AF%91%E5%99%A8%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#22152-编译器匹配规则"
  },"175": {
    "doc": "类型与变量",
    "title": "2.216 对象的作用域与生命周期",
    "content": "之前我们谈到了对象和实体这两个词，实体是指在程序中能够操作的东西，而对象通常是指一块能存储数据并具有某种类型的内存空间(函数也是对象)。所以，对象一定是实体，但实体不一定是对象。 . 每种对象的属性都有三种，而命名的对象则多一个名字属性： . | 类型 | 作用域 | 名字 | 生命周期/生存期(lifetime) | . 对象的类型决定该对象所占空间的大小以及能存储数据的类型。 作用域影响对象的可访问性以其名字可见性。 对象的生命周期是程序执行过程中该对象存在的时间。 . 和C语言一样，C++中的每个对象都可以指明对象的存储类别，指明对象的存储类别只能在定义或者声明对象时才能指明。 . 存储类别会影响对象的作用域或者生存期，指明对象的存储类别的表达式形式为: . 存储说明符 类型说明符(可含有类型修饰符) 变量名 (可选 初始化) . 如static int i = 6; . 在定义或者声明对象时，可以显式指定其存储类别，也可以隐式(默认)指定。要注意每个对象只能有一种存储类别。 . c++继承了c的3种存储说明符，删除了auto存储符： . | 外部存储符(extern) | 静态存储符(static) | 寄存器存储符(register) | . 根据作用域的不同，对象可以分为2种形式： . | 全局对象 | 局部对象 | . 全局对象是有全局作用域的对象，局部对象是有块作用域的对象。 . 其中，存储说明符extern，static，可以影响全局对象的作用域(extern可以用于局部对象，static不行)。 . | 存储说明符extern： . | 作用于全局对象的存储说明符extern可以扩展全局对象的同文件作用域，也可以扩展全局对象作用域到其他文件。也就是之前声明所说的操作技巧。 | 作用于局部对象的存储说明符extern是将外层的作用域或其他文件定义的同名变量(必须要有变量的定义而不能不存在该变量或者只是声明)扩展到局部对象的作用域中。 注意该局部对象的函数中不能存在该extern声明对应的定义，否则会出错。 . | . | 存储说明符static可以将全局对象的作用域限制在本文件内，其他文件里的代码即使用extern声明了该对象，也无法访问该对象。 默认情况下，全局对象是extern，局部对象是static | . int ins = 55; int main() { // 错误：该函数中不能存在extern声明对应的定义。 int ins = 20; // 正确：该定义语句不是extern声明对应的语句。 double ins = 48.6; { extern int ins; // extern声明。 cout &lt;&lt; ins; } } . 根据生存期的不同，对象可以分为3种形式： . | 静态对象 | 自动对象 | 寄存器对象 | . 对象的生存期的不一样是由程序执行过程中编译器分配的存储空间的方式的不同所决定的。 . 在内存空间中，编译器将系统的所有内存空间分为三种不同的区域(内存池)： . | 静态存储区(static) | 动态存储区/栈区(stack) | 自由空间区(free store)/堆区(heap) | . 静态存储区的对象在程序执行过程中由编译器分配存储单元，并在运行过程中不释放其内存。 静态存储区的对象也叫做静态内存对象。 . 动态存储区也叫栈区，动态存储区的对象在程序执行过程中由编译器根据需要自动分配存储单元和释放其内存。 动态存储区的对象也叫做栈内存对象。 . 自由空间区也叫堆区，自由空间区的对象不是由编译器来控制其存储的，而是由程序自行控制，也就是由我们自己的代码来控制其对象的生存期。 自由空间区的对象也叫做动态内存对象。 . 其中，存储说明符static，register，可以影响局部对象的生存期(不能用于全局对象) 存储说明符static可以用于栈区的局部对象(静态区和堆区可以使用，但无意义)，使其对象存储在静态存储区。 存储说明符register叫做寄存器存储符，当一些局部对象使用频繁，每次从内存存取花费时间高，所以可以声明对象为register使其存储在cpu的寄存器中，寄存器读取速度远高于内存速度，因此可以提高执行效率。但现在大多数编译器能够自动识别使用频繁的局部对象并将其放入寄存器中，所以实际上可以无需显式指定对象为register。 默认情况下，全局对象是放在静态存储区，局部对象是在栈区的。 . 注意，static存储说明符有两种作用： . | 作用于全局对象则是改变其作用域。 | 作用于局部对象则是改变其生存期。 | . 因为用static存储说明符修饰的局部对象（包括函数以及类类型静态与非静态成员函数中的局部对象）为静态内存对象，因此其在运行过程中只会执行一次初始化，而且在程序运行过程中不被释放其内存。 . #include &lt;iostream&gt; #include &lt;string&gt; // 全局函数，带有一个静态局部对象 void prints() { static int i = 0; std::cout &lt;&lt; ++i &lt;&lt; std::endl; } class Cls { public: // 成员函数，带有一个静态局部对象 void prints() { static double j = 0; j += 1.12; std::cout &lt;&lt; j &lt;&lt; std::endl; } // 静态成员函数，带有一个静态局部对象 static void prints2() { static double k = 0; k += 2.25; std::cout &lt;&lt; k &lt;&lt; std::endl; } }; int main() { // 输出1 prints(); // 输出2 prints(); // 输出2.25 Cls::prints2(); Cls obj; // 输出1.12 obj.prints(); // 输出4.5 obj.prints2(); // 输出2.24 obj.prints(); // 输出6.75 obj.prints2(); // 输出9 Cls::prints2(); // 输出11.25 Cls::prints2(); return 0; } . 根据static修饰的局部对象的特性，对同一作用域中的相同函数（相同函数首部）的不同调用，函数中所有对应的static对象都为同一个（相同地址）。具体来说： . | 全局函数以及lambda函数：共享同一个static对象（相同地址）。 | 类成员函数：不管是否为静态函数，也不管是否为继承而来的，相同函数（相同地址）的的不同调用共享同一个static对象（相同地址）。 | 类模板：因为模板是用于生成类类型的，因此不同模板实参所生成的类类型实例是不一样的。因此只有生成的模板实例中的成员函数为相同地址时的不同调用，才会共享同一个static对象（相同地址）。 | . #include &lt;iostream&gt; #include &lt;string&gt; // 全局函数，带有一个静态局部对象 void isFirst() { static bool is_first = true; std::cout &lt;&lt; \"normal func: \" &lt;&lt; ((is_first) ? \"is first\": \"not first\" ) &lt;&lt; std::endl; is_first = false; } // 重载全局函数isFirst，带有一个静态局部对象 void isFirst(int) { static bool is_first = true; std::cout &lt;&lt; \"normal func2: \" &lt;&lt; ((is_first) ? \"is first\": \"not first\" ) &lt;&lt; std::endl; is_first = false; } class Cls { public: // 成员函数，带有一个静态局部对象 void isFirstMem() { static bool is_first = true; std::cout &lt;&lt; \"member func: \" &lt;&lt; ((is_first) ? \"is first\": \"not first\" ) &lt;&lt; std::endl; is_first = false; } // 静态成员函数，带有一个静态局部对象 static void isFirstStaMem() { static bool is_first = true; std::cout &lt;&lt; \"static member func: \" &lt;&lt; ((is_first) ? \"is first\": \"not first\" ) &lt;&lt; std::endl; is_first = false; } }; // 继承Cls类的类模板，继承的函数其地址是一样的 template&lt;class T&gt; class DerivedClsTemplate: public Cls {}; // 类模板 template&lt;class T&gt; class ClsTemplate { public: // 成员函数，带有一个静态局部对象 void isFirstMem() { static bool is_first = true; std::cout &lt;&lt; \"templte member func: \" &lt;&lt; ((is_first) ? \"is first\": \"not first\" ) &lt;&lt; std::endl; is_first = false; } // 静态成员函数，带有一个静态局部对象 static void isFirstStaMem() { static bool is_first = true; std::cout &lt;&lt; \"templte static member func: \" &lt;&lt; ((is_first) ? \"is first\": \"not first\" ) &lt;&lt; std::endl; is_first = false; } }; int main() { // 输出normal func: is first isFirst(); // 输出normal func: not first isFirst(); // 输出normal func: is first isFirst(1); // 输出normal func: not first isFirst(1); // 输出static member func: is first Cls::isFirstStaMem(); // 输出static member func: not first Cls::isFirstStaMem(); Cls obj; // 输出member func: is first obj.isFirstMem(); // 输出member func: not first obj.isFirstMem(); // 输出static member func: not first DerivedClsTemplate&lt;int&gt;::isFirstStaMem(); // 输出static member func: not first DerivedClsTemplate&lt;double&gt;::isFirstStaMem(); DerivedClsTemplate&lt;bool&gt; dt_obj; DerivedClsTemplate&lt;char&gt; dt_obj2; // 输出member func: not first dt_obj.isFirstMem(); // 输出member func: not first dt_obj2.isFirstMem(); // 输出templte static member func: is first ClsTemplate&lt;int&gt;::isFirstStaMem(); // 输出templte static member func: is first ClsTemplate&lt;double&gt;::isFirstStaMem(); // 输出templte static member func: not first ClsTemplate&lt;int&gt;::isFirstStaMem(); // 输出templte static member func: not first ClsTemplate&lt;double&gt;::isFirstStaMem(); ClsTemplate&lt;bool&gt; t_obj; ClsTemplate&lt;char&gt; t_obj2; // 输出templte member func: is first t_obj.isFirstMem(); // 输出templte member func: is first t_obj2.isFirstMem(); // 输出templte member func: not first t_obj.isFirstMem(); // 输出templte member func: not first t_obj2.isFirstMem(); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2216-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2216-对象的作用域与生命周期"
  },"176": {
    "doc": "类型与变量",
    "title": "2.3 类型转换",
    "content": "对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型转换（convert）为另一种相关类型。 如果两种类型有关联，那么当程序需要其中一种类型的运算对象时，可以用另一种关联类型的对象或值来替代。换句话说，如果两种类 型可以相互转换(conversion)，那么它们就是关联的。 . 类型转换能且只能在有关联的类型之间进行 . 以下例子说明了当给某种类型的对象强行赋了另一种类型的值时，到底会发生什么。 . bool b = 42; // b为真 int i = b; // i的值为1 i = 3.14; // i的值为3，编译器可能会警告该运算损失了精度 double pi = i; // pi的值为3.0 unsigned char c = -1; //假设char占8比特，c的值为255 signed char c2 = 256; //假设char占8比特，c2的值是未定义的 . 类型转换分为两种： . | 隐式转换 | 显式转换 | . C++语言不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型统一后再求值。上述的类型转换是自动执行的，无须程序员的介入，有时甚至不需要程序员了解。 因此，它们被称作隐式转换(implicit conversion)。 . 我们也可以显式的指定某对象的转换类型来强制性将其转换成我们所指定的类型，这也叫作显式转换。 . 编译器在执行转换时，会根据转换规则生成一个具有转换目标类型的临时对象，且该临时对象的值是由需要转换的对象的值经过转换规则处理后的值。 此临时对象会一直存在并会代替需要转换的对象参与之后的运算，直到包含有该对象的最大表达式计算完成为止。 所以不管是什么类型的转换，都不会对被转换的变量的值有任何的改变(除了引用类型的显式转换)。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#23-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#23-类型转换"
  },"177": {
    "doc": "类型与变量",
    "title": "2.31 基本隐式转换",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#231-%E5%9F%BA%E6%9C%AC%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#231-基本隐式转换"
  },"178": {
    "doc": "类型与变量",
    "title": "2.311 算术类型的隐式转换",
    "content": "算术转换（arithmetic conversion）的含义是把一种算术类型转换成另外一种算术类型。 算术转换的规则定义了一套类型转换的层次，其中规则的优先级由高到低排列，先执行满足条件的优先级高的，再是低的： . | 整型提升 | 小类型转大类型 | 有符号转无符号 | 不同类型的赋值时转换 | . 整型提升 . 如果一个运算符的运算对象中，有某个是小整型对象，而另一个是非小整型对象。此时就会执行整型提升（integral promotion）。 对于尺寸小于int的整型对象，就会将其类型转换为int。 对于尺寸大于等于int的字符型，将会转换成能容纳原类型所有可能值的最小类型。 . 小类型转大类型 . 表达式中，运算符的运算对象根据运算符的结合律和优先级逐个将两个之中最小的类型转换成的最宽尺寸的类型。 例如，如果一个运算对象的类型是long double，那么不论另外一个运算对象的类型是什么都会转换成long double。 . int ins = 5; float flo = 8.3; double dou = 3.5; dou = ins + flo; // ins先转换成float，执行+运算后，其结果再转换成double . 有符号转无符号 . 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，且其中的无符号类型不小于带符号类型，则执行该规则。带符号的运算对象转换成无符号的类型。 . 赋值时的转换 . 类型所能表示的值的范围决定了转换的过程: . | 当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。 | 当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。 | 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。 | 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。 | 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。 例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。 -1 % 256 == 255; | 当我们赋给某对象一个超出它类型表示范围的值时，结果是未定义的(undefined)。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2311-%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2311-算术类型的隐式转换"
  },"179": {
    "doc": "类型与变量",
    "title": "2.312 其他类型的隐式转换",
    "content": "除了算术转换之外还有几种隐式类型转换 . | 整型字面值，数组或函数转换成指针： . | 整型字面值 C++规定了整型字面值0和nullptr能转换成任意指针类型。 | 数组和函数 在大多数用到数组和函数的表达式中(包括用于函数形参时)，数组名和函数名会自动转换成指向数组首元素的指针和函数指针。 当数组或函数被用于 . | decltype关键字的参数 | 函数的返回类型 | 初始化对应类型的引用 | 类的成员 | 作为取地址符(&amp;)、sizeof及typeid 等运算符的运算对象 | . | . 以上这些情况时，上述转换不会发生。此外，如果用一个对应类型的引用来初始化数组，上述转换也不会发生。 . | 指针之间的转换： . | 指向任意非常量的指针能转换成void*指针。 | 指向任意对象的指针能转换成const void*指针。 注意void*或者const void*指针不能隐式转换成其他任意类型的非常量或者常量指针。 注意任何的非void的**指针以及void的***等指针与对应的void指针不能相互进行隐式转换。 . | 派生类的指针能转换成基类指针。 | . | 转换成布尔类型： 存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为0，转换结果是false；否则转换结果是true。 . | 非常量与常量之间的转换： 允许将各种const顶层类型对象与其对应的各种非常量类型相互转换。 还允许指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。也就是说，如果T是一种类型，我们就能将指向T的指针或引用分别转换成指向const T的指针或引用，相反的转换并不存在，因为它试图删除掉底层const。 . | 类类型之间的转换： 类类型能定义由编译器自动执行的转换操作，不过编译器毎次只能执行一种类类型的转换。 但是类类型的隐式转换可以置于算术类型的隐式转换之前或之后，与其一起使用。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2312-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#2312-其他类型的隐式转换"
  },"180": {
    "doc": "类型与变量",
    "title": "2.32 显式转换",
    "content": "有时我们希望显式地将对象强制转换成另外一种类型。 . c++的显式转换有两种，一种是命名强制类型转换，一种是旧式强制类型转换： . | 命名强制类型转换 . cast-name&lt;type&gt; (expression) . | static_cast | const_cast | reinterpret_cast | dynamic_cast | . | 旧式强制类型转换 . | 函数形式的强制类型转换 . type(expr) . | C语言风格的强制类型转换 . (type)expr . | . | . 命名的强制类型转换 . 一个命名的强制类型转换具有如下形式 . cast-name&lt;type&gt; (expression) . 其中，cast-name指定执行的是哪种转换，type是转换的目标类型，而expression是要转换的值，如果type是引用类型，则结果是左值。 . static_cast . 任何具有明确定义的类型转换，只要不包含底层const, 都可以使用static_cast。 . 可以将左值引用转换为右值引用。 . //进行强制类型转换以便执行浮点数除法 double slope = static_cast&lt;double〉(j) / i; . 当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。一般來说，如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息：但是当我们执行了显式的类型转换后，警告信息就会被关闭了。 static_cast对于编译器无法自动执行的类型转换也非常有用。 . const_cast . const_cast只能改变运算对象的底层const，所以const_cast转换的目标类型只能是引用或者是指针类型。 也只有const_cast能改变运算对象的底层const，使用其他形式的命名强制类型转换来改变表达式的常量属性，都将引发编译器错误。 . const char *pc; char *p = const_cast&lt;char*&gt; (pc); //正确：但是通过p写值是未定义的行为 . reinterpret_cast . reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。 假设有如下的转换： . int *ip; char *pc = reinterpret_cast&lt;char*&gt;(ip); . 我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。 . 旧式强制类型转换 . 旧式强制类型转换的形式包含以下两种。 . 函数形式的强制类型转换： . type(expr) . C语言风格(C语言只有这一种强制转换)的强制类型转换： . (type)expr . 根据所涉及的类型不同，旧式的强制类型转换分别具有与const_cast、 static_cast或reinterpret_cast相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成const_cast和static_cast也合法，则其行为与对应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与reinterpret_cast类似的功能。 . char *pc = (char*) ip; // ip是指向整数的 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#232-%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#232-显式转换"
  },"181": {
    "doc": "类型与变量",
    "title": "2.33 标准库类型转换模板",
    "content": "对于类型转换，C++标准库也定义了多个类型转换类模板来进行一些类型转换，这些类型转换主要用于一些含有类型自动推断的操作(比如auto、decltype和模板形参推断等)和模板元程序设计中。 . 这些类型转换类模板定义在头文件type_traits中，这些模板都有一个模板形参和一个名为type的公有类类型成员。 . 以下是某些类型转换模板的参数： . 这些模板会根据所给予的模板实参将该实参的类型转换成另外某种类型，这个类型和对应模板的类类型成员一样。 . 例如：如果我们使用remove_reference&lt;int&amp;&gt;，则类类型成员type将是int；类似的，如果我们使用remove_reference&lt;string&amp;&gt;,则类类型成员type将是string，以此类推。 . #include &lt;type_traits&gt; // 等价于int ins = 18; remove_reference&lt;int&amp;&gt;::type ins = 18; // 等价于double dou = 15.4; remove_pointer&lt;double*&gt;::type dou = 15.4; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#233-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%A8%A1%E6%9D%BF",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html#233-标准库类型转换模板"
  },"182": {
    "doc": "类型与变量",
    "title": "类型与变量",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html"
  },"183": {
    "doc": "复合类型",
    "title": "2.4 复合类型",
    "content": "复合类型(compound type)是指基于其他类型定义的类型。C++语言有以下几种复合类型: . | 复合类型 . | 数组类型([]) | 引用类型 . | 左值引用(&amp;) | 右值引用(&amp;&amp;) | . | 指针类型(*) . | 普通指针 | 与数组有关的指针 | 函数指针 | 类成员指针 | . | . | . 在变量的声明语句中，一条声明语句由一个类型说明符和紧随其后的一个声明符列表组成。 . 类型说明符(type specifier)就是指的是类型的名字 . 声明符(declarator)是声明的一部分，包括了被声明的变量名和类型修饰符。 每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。 声明语句中可以没有类型修饰符。 . 类型修饰符也是声明的一部分，用来说明该变量的一些其他特性，如&amp;, *, const等。 每种类型修饰符所作用的实体(作用于类型或者变量)和放置的位置(放置在所作用的实体的左右)有所不同。 有些类型修饰符只作用于变量，如&amp;, *(只能放在变量的左边)。 有些类型修饰符既能作用于类型也能作用于变量，如const。 某些类型修饰符可以同时存在于一个声明语句中。 当某类型修饰符作用于变量时，是对其作用的那个变量起作用，并不能影响到其他变量，所以要注意在一个声明语句中存在多个变量声明的情况。 . 面对一条比较复杂的有多个类型修饰符的声明语句时，==要根据每个类型修饰符的修饰实体与放置位置，从里到外(有圆括号从圆括号内读)，从右向左开始阅读，离修饰实体最近的符号对变量的类型有最直接的影响==，这样有助于弄清楚它的真实含义。 如： int *(&amp;arry)[10] = ptrs; //arry是数组的引用，该数组含有10个指针 . 复合类型变量的初始化方式与其他类型变量一样，可以直接初始化和拷贝初始化。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24-复合类型"
  },"184": {
    "doc": "复合类型",
    "title": "2.41 容器",
    "content": "在介绍复合类型中的数组类型之前，我们首先要介绍一下容器的概念。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#241-%E5%AE%B9%E5%99%A8",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#241-容器"
  },"185": {
    "doc": "复合类型",
    "title": "2.411 容器的介绍",
    "content": "容器也就是容纳对象的集合，定义了一个容器对象就是定义了一个能容纳对象的集合。 . 普通的对象存储的是单个的数据，而容器类对象则是存储着多个数据的对象，且每个数据的类型都相同。 . 容器类对象中的每个元素可以看做为一个未命名的对象。我们可以对这些对象进行访问。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2411-%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2411-容器的介绍"
  },"186": {
    "doc": "复合类型",
    "title": "2.412 容器的性质",
    "content": "容器类对象作为容纳对象的集合，有两种属性： . | 容量可变性 | 有序性 | . 容量可变性： 是指容器类对象在定义后是否可以改变容纳对象的数目。 . 比如定义了一个能容纳5个元素的容器类对象，当想同时存5个以上的元素时，如果该容器对象支持这种此操作，那么其就具备容量可变性，反之不具备 . 有序性： 是指容器类对象的元素是否是以某种规律所排列存放的，比如按元素的大小排列。 . 对于有有序性的容器来说，我们可以按照其位置顺序来进行元素访问 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2412-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%80%A7%E8%B4%A8",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2412-容器的性质"
  },"187": {
    "doc": "复合类型",
    "title": "2.413 容器元素的访问",
    "content": "每个元素在容器中都有其存放位置的，我们可以通过其位置来访问该元素。 . 大多数容器都提供两种访问操作，对于标准库里的容器还提供了叫做迭代器的指针的访问操作： . | 下标运算符 | 指向容器元素的指针 . | 迭代器 | . | . 通过迭代器的元素访问操作我们之后会在介绍标准库容器时进行介绍。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2413-%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2413-容器元素的访问"
  },"188": {
    "doc": "复合类型",
    "title": "2.4131 下标运算符的元素访问",
    "content": "大多数容器都提供一种用下标运算符来访问其元素的操作，形式为 . 容器对象名[索引] . [ ]为下标运算符，下标运算符中必须要指明所要访问的元素的位置编号(也就是索引)。通过这种形式就能访问容器对象中的对应元素了。 . 在使用下标运算符来访问元素时，要注意==每个容器对象的索引范围==，使用的索引必须要在范围内，否则会出现未定义行为。 . 大多数容器的索引是从0开始的，且该容器的最大索引值比该容器对象的容量值小1。以一个包含10个元素的数组为例，它的索引从0到9,而非从1到10。 . 下标运算符[ ]为一元运算符，运算对象在中间。 运算对象为右值，运算结果为左值 . int a[] = {3, 4, 2}; //含有3个整数的数组 cout &lt;&lt; a[0]; //输出首元素(索引为0的元素)的值，为3。 a[0] = 8; cout &lt;&lt; a[0]; //首元素的值被改为8，所以输出8。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24131-%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24131-下标运算符的元素访问"
  },"189": {
    "doc": "复合类型",
    "title": "2.4132 指向容器元素的指针的元素访问",
    "content": "大多数指针不支持容器的元素访问，只有指向容器元素的指针才能够进行元素访问。 . 指向容器元素的指针和普通指针一样，都需要用地址来初始化或赋值才能使用。之后会介绍指针的相关信息。 . 对于容器元素访问，指向容器元素的指针既可以像普通指针一样使用解引用来访问，也可以使用下标运算符来访问。 . 1. 使用下标运算符来访问 . 指向容器元素的指针的下标访问操作和容器的下标元素访问操作一样，使用时将该指针放在容器名的位置上就行，该操作也遵循各种容器下标访问的规则。 . #include &lt;iostream&gt; using namespace std; int main() { // 含有5个元素的数组arr int arr[5] = {3,8,6,78,35}; // 指向数组arr元素的指针p int *p = arr; // 使用p的下标访问操作 // 输出6 cout &lt;&lt; p[2] &lt;&lt; endl; // 使用p的下标访问操作来修改arr的元素 p[3] = 43; // 输出43 cout &lt;&lt; arr[3] &lt;&lt; endl; return 0; } . 2. 使用算术和解引用运算符来访问 . 指向容器元素的指针与普通指针的另一个区别就是：指向容器元素的指针还可以与整型类型的字面值或者变量做一些算术和赋值运算，用于便捷的访问该容器内的元素： . | 加法运算符 . | 指针 + 整型 | . | 减法运算符 . | 指针 - 整型 | 指针 - 指针 | . | 递增运算符 . | 前置版本：++指针 | 后置版本：指针++ | . | 递减运算符 . | 前置版本：–指针 | 后置版本：指针– | . | . 指针与整型的加减： . 指针与整型的加减是指该指针向前或者向后移动给定整型值的单位的元素位置： . 比如一个指针a指向容器的第3个元素，则a+3是指该指针a向后移动到指向容器的第6个元素；a-3是指该指针a向前移动到指向容器的第0个元素。 . 指针与指针的加减： . 指针与指针的加减只有这两个指针在指向同一容器的元素才有意义。 . 指针与指针的加减是指这两个指针之间的元素数量的相对间隔： . 比如指针a指向容器的第3个元素，指针b指向容器的第6个元素。 则a-b的值为-3，指的是指针a在指针b前面，且中间间隔3个元素；同样的，b-a的值为3，指的是指针b在指针a后面，且中间间隔3个元素。 . 递增递减运算符： . 递增递减运算符和加法减法差不多： . | 前置版本(++指针/–指针)的运算符 首先将运算对象加1(或减1)，然后将改变后的对象作为求值结果。 | 后置版本(指针++/指针–)的运算符 首先将运算对象加1(或减1)，但是求值结果是运算对象改变之前那个值的副本(右值)。 | . // 以数组容器为例:\\ 建立一个5个元素为int的数组array，一个指针指向数组array的首元素，一个指向数组array的尾元素。 int array[5] = {3,5,8,9,0}; int *p_head = array; int *p_tail = &amp;array[4]; // 输出4，指p_tail和p_head之间间隔4个元素。 cout &lt;&lt; p_tail - p_head &lt;&lt; \"\\n\"; // 输出3 8，分别指向数组array的第1和第3个元素。 cout &lt;&lt; *p_head &lt;&lt; \" \" &lt;&lt; *(p_head+2) &lt;&lt; \"\\n\"; // 输出0 8，分别指向数组array的第5和第3个元素。 cout &lt;&lt; *p_tail &lt;&lt; \" \" &lt;&lt; *(p_tail-2) &lt;&lt; \"\\n\"; // 输出5 5，指向数组array的第2个元素。 cout &lt;&lt; *++p_head &lt;&lt; \" \"; cout &lt;&lt; *p_head++ &lt;&lt; \"\\n\"; // 输出9 9，指向数组array的第4个元素 cout &lt;&lt; *--p_tail &lt;&lt; \" \"; cout &lt;&lt; *p_tail-- &lt;&lt; \"\\n\"; . // 以标准库的vector容器为例:\\ 建立一个5个元素为int的vector容器v1，一个指针指向v1的首元素，一个指向数组v1的尾元素。 vector&lt;int&gt; v1 = {3,5,8,9,0}; int *p_head = &amp;v1[0]; int *p_tail = &amp;v1[4]; // 输出4，指p_tail和p_head之间间隔4个元素。 cout &lt;&lt; p_tail - p_head &lt;&lt; \"\\n\"; // 输出3 8，分别指向v1的第1和第3个元素。 cout &lt;&lt; *p_head &lt;&lt; \" \" &lt;&lt; *(p_head+2) &lt;&lt; \"\\n\"; // 输出0 8，分别指向v1的第5和第3个元素。 cout &lt;&lt; *p_tail &lt;&lt; \" \" &lt;&lt; *(p_tail-2) &lt;&lt; \"\\n\"; // 输出5 5，指向v1的第2个元素。 cout &lt;&lt; *++p_head &lt;&lt; \" \"; cout &lt;&lt; *p_head++ &lt;&lt; \"\\n\"; // 输出9 9，指向v1的第4个元素 cout &lt;&lt; *--p_tail &lt;&lt; \" \"; cout &lt;&lt; *p_tail-- &lt;&lt; \"\\n\"; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24132-%E6%8C%87%E5%90%91%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88%E7%9A%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24132-指向容器元素的指针的元素访问"
  },"190": {
    "doc": "复合类型",
    "title": "2.42 数组类型",
    "content": "数组是一种复合类型，数组可以看成是一种容器。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#242-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#242-数组类型"
  },"191": {
    "doc": "复合类型",
    "title": "2.421 数组的定义",
    "content": "数组作为一种容量不可变的有序容器，不能随意向数组中增删元素。因为数组的大小固定。 . 数组类型修饰符[ ]只作用于变量，且放置在变量的右边。 . 定义数组类变量的语句形式为： . 基本类型(类型说明符) 变量名[容量大小] (可选: 初始化); . unsigned ent = 42; //不是常量表达式 constexpr unsigned sz = 42; // 常量表达式， int arr [10] ; //含有10个整数的数组 int *parr [sz] ; //含有42个整型指针的数组 string bad[cnt] ; //错误：ent不是常量表达式 string strs [get_size()] ; // 当 get_size是 constexpr时正确，否则错误 . 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。 因为数组的元素应为对象，因此不存在引用的数组。 . 数组容量的大小是放在数组类型修饰符[ ]中的，因为容量的大小也是属于数组类型的一部分，所以必须要为常量表达式。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2421-%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2421-数组的定义"
  },"192": {
    "doc": "复合类型",
    "title": "2.412 数组的初始化",
    "content": "数组初始化只能用列表初始化的形式，如果数组没有被显式初始化，则数组的元素被默认初始化。 . 当数组被显式初始化时，可以省略其容量大小，编译器会根据初始值的数量计算并推测出来；否则必须指定其容量大小。 . 当指明了数组的容量大小时，初始化该数组的初始值数量不能超出指定的大小。如果指明的容量大小比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素执行值初始化。 . const unsigned sz = 3; int ial[sz] ={0, 1, 2}; //含有3个元素的数组，元素值分别是0,1,2 int a2[] = {0, 1, 2}; //维度是3的数组 int a3[5]= {0, 1, 2}; // 等价于 a3[] = {0, 1, 2, 0, 0} string a4[3] ={ \"hi\", \"bye\"}; // 等价于 a4[] = {\"hi\", \"bye\", \"\"} int a5[2]= {0, 1 ,2}; //错误：初始值过多 . 对于大多数非内置类型(包括类类型，除了共用体类型)的数组来说，我们允许每个初始化值是由花括号括起来的一组值的列表来初始化该数组中的每个类类型元素(也包括类类型元素中的类类型成员中的成员，以此类推)，也就是支持初始化列表的嵌套，嵌套的初始化列表中的初始值数量不能超过对应类类型元素的非静态数据成员(也包括类类型元素中的类类型成员中的成员，以此类推)的数量，且其中的初始值类型要一一对应才行。 . 不过我们也可以直接提供对应的非静态数据成员类型的初始值而不使用初始化列表的嵌套来初始化该非内置类型的数组(也就是不用花括号括起来)，这种初始化的初始值数量不能超过数组的容量大小乘以这些成员的数量，且如果初始值数量小于该值，则用提供的初始值初始化靠前的元素中的非静态数据成员(也包括类类型元素中的类类型成员中的成员，以此类推)，剩下的所有元素的所有非静态数据成员执行值初始化。 . struct Base { double dou; int ins; }; struct Bases { double dou2; std::string strs; Base ba; int ins2; }; // 数组arr和arr2的初始化方式等价，其初始值相同 Bases arr[3] = {{6.6, \"str1\", {3.5, 3}, 20}, {7.8, \"str2\", {5.5, -1}, -7}, {1.62, \"str3\", {-3.3, 10}, 45}}; Bases arr2[3] = {6.6, \"str1\", 3.5, 3, 20, 7.8, \"str2\", 5.5, -1, -7, 1.62, \"str3\", -3.3, 10, 45}; // 数组arr3中的第一个元素中的dou2成员被初始化为1.3，其他成员以及其他元素的成员都被值初始化。 Bases arr3[3] = {1.3}; // 错误，数组arr4中的第一个元素中的第二个非静态数据成员为std::string类型，不能用int类型来为其赋值 Bases arr4[3] = {1.3, 6}; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2412-%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2412-数组的初始化"
  },"193": {
    "doc": "复合类型",
    "title": "2.4121 字符数组的初始化",
    "content": "字符数组有一种额外的初始化语句形式，我们可以用字符串字面值对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去： . char al[] = {'C', '+', '+'}; //列表初始化，没有空字符 char a2[] = {'C', '+', '+', '\\0'}; //列表初始化，含有显式的空字符 char a3[] = \"C++\"; // 自动添加表示字符串结束的空字符，等价于a3[] = {'C', '+', '+', '\\0'}; char a4[6] = \"Daniel\"; //错误：没有空间可存放空字符！ . 数组不支持拷贝，赋值和被赋值，所以不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组或其他容器为其他数组赋值，同时，数组也不能作为函数的返回类型与形参类型： . int a[] = {0, 1, 2}; //含有3个整数的数组 int a2[] = a; //错误：不允许使用一个数组初始化另一个数组 a2 = a; //错误：不能把一个数组直接赋值给另一个数组 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24121-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24121-字符数组的初始化"
  },"194": {
    "doc": "复合类型",
    "title": "2.413 数组元素的访问",
    "content": "数组和其他容器一样，可以用下标运算符或者指向数组元素的指针来访问元素。数组的索引也是从0开始的。 . int a[] = {3, 4, 2}; //含有3个整数的数组 cout &lt;&lt; a[0]; //输出首元素(索引为0的元素)的值，为3。 a[0] = 8; cout &lt;&lt; a[0]; //首元素的值被改为8，所以输出8。 . 在使用数组下标访问的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版。 . // 建立一个5个元素为int的数组array，一个指针指向数组array的首元素，一个指向数组array的尾元素。 int array[5] = {3,5,8,9,0}; int *p_head = array; int *p_tail = &amp;array[4]; // 输出4，指p_tail和p_head之间间隔4个元素。 cout &lt;&lt; p_tail - p_head &lt;&lt; \"\\n\"; // 输出3 8，分别指向数组array的第1和第3个元素。 cout &lt;&lt; *p_head &lt;&lt; \" \" &lt;&lt; *(p_head+2) &lt;&lt; \"\\n\"; // 输出0 8，分别指向数组array的第5和第3个元素。 cout &lt;&lt; *p_tail &lt;&lt; \" \" &lt;&lt; *(p_tail-2) &lt;&lt; \"\\n\"; // 输出5 5，指向数组array的第2个元素。 cout &lt;&lt; *++p_head &lt;&lt; \" \"; cout &lt;&lt; *p_head++ &lt;&lt; \"\\n\"; // 输出9 9，指向数组array的第4个元素 cout &lt;&lt; *--p_tail &lt;&lt; \" \"; cout &lt;&lt; *p_tail-- &lt;&lt; \"\\n\"; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2413-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2413-数组元素的访问"
  },"195": {
    "doc": "复合类型",
    "title": "2.414 多维数组",
    "content": "严格来说，C++语言中没有多维数组，多维数组其实是数组的数组，也可以说成是嵌套数组，当定义一个多维数组时，外层数组的每个元素也是一个数组。 . 一般我们常用的是二维数组，二维数组是指其元素也是数组的数组；三维数组是指其元素是二维数组的数组，以此类推。 . 对于二维数组来说，常把第一个维度称作行，第二个维度称作列。 . 当我们定义一个多维数组时，通常使用两个维度來定义它：一个维度表示数组本身的大小，另外一个维度表示其元素（也是数组）的大小： . 实际上，定义数组时对数组类型修饰符的数量并没有限制，因此只要愿意就可以定义这样一个数组：它的元素还是数组，下一级数组的元素还是数组，再下一级数组的元素还是数组，以此类推。 . int ia[3][4]; //大小为3的数组，每个元素是含有4个整数的数组 //大小为10的数组，它的每个元素都是大小为20的数组， //这些数组的元素是含有30个整数的数组 //将这个数组的所有元素初始化为0 int arr[10][20] [30] = {0}; . 在第一条语句中，我们定义的名字是ia,显然ia是一个含有3个元素的数组。接着观察右边发现，ia的元素也有自己的维度，所以ia的元素本身又都是含有4个元素的数组。再观察左边知道，真正存储的元素是整数。因此最后可以明确第一条语句的含义：它定义了一个大小为3的数组，该数组的每个元素都是含有4个整数的数组。 使用同样的方式理解arr的定义。首先arr是一个大小为10的数组，它的每个元素都是大小为20的数组，这些数组的元素又都是含有30个整数的数组。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2414-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2414-多维数组"
  },"196": {
    "doc": "复合类型",
    "title": "2.4141 多维数组的初始化",
    "content": "多维数组的初始化与普通数组类似，只能用列表初始化形式，但多维数组允许每个初始化值是由花括号括起来的一组值的列表，也就是支持初始化列表的嵌套，和普通初始化列表一样，嵌套的初始化列表的初始值数量不能超过对应的容量大小。 . 初始化列表的嵌套并非必需，只要满足数组初始化规则就行 . int ia[3][4] = { {0, 1, 2, 3}，//第1行的初始值 {4, 5, 6, 7}，//第2行的初始值 {8, 9, 10, 11} //第3行的初始值 }; //三个元素，每个元素都是大小为4的数组 //没有标识每行的花括号，与ia的初始化语句是等价的 int ia2[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11}; . 和普通数组一样，如果多维数组没有被显式初始化，则元素被默认初始化。 . 当多维数组被显式初始化时，可以省略其第一维的容量大小，后面维度的容量大小不能省略。 . 编译器自动推断第一维的大小视通过后面维度的大小以及所给初始值的多少来决定的，公式为： f_size = ceil(n/sum(s_size)); f_size为第一维的大小，sum(s_size)为后面维度大小的总和，n为对应的初始值数量，ceil为向上取整函数。 . 当指明了多维数组的维度的容量大小时，初始化某维度的初始值数量不能超出该维度指定的大小。如果指明的容量大小比提供的初始值数量大，则用提供的初始值初始化该维度靠前的元素，该维度剩下的元素执行值初始化。 . //显式地初始化每行的首元素，其他元素执行值初始化 int ia[3][4] = {{ 0 }, { 4 }, { 8 }}; //显式地初始化第1行，其他元素执行值初始化 int ix[3][4] = {0, 3, 6, 9}; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24141-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24141-多维数组的初始化"
  },"197": {
    "doc": "复合类型",
    "title": "2.4142 多维数组的元素的访问",
    "content": "和普通数组一样，可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。 如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组 . //用arr的首元素为ia最后一行的最后一个元素賦值 ia[2][3] = arr[0][0][0]; int (&amp;row)[4] = ia[1] ; //把row绑定到ia的第二个容量为4的数组上 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24142-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24142-多维数组的元素的访问"
  },"198": {
    "doc": "复合类型",
    "title": "2.43 引用类型",
    "content": "引用(reference)类型可以看作为某个对象起了另外一个名字。 一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义变量引用时，程序会把用来初始化该引用变量的对象与该变量绑定(bind)在一起，而不是将初始值拷贝给引用变量。 . 一旦初始化完成，引用将和它的初始值对象一直绑定在一起，无法解绑。 该引用也就相当于其初始值对象的别名，所以之后所有对引用的操作也就是对其初始值对象的操作。 . 注意当右值引用绑定到字面值时，编译器是根据该字面值的数据创建一个含有该数据的临时对象并绑定到该右值引用上的。所以对该右值引用的操作并不是对其绑定的字面值的操作，而是对这个临时对象的操作。 . 所以非常量的右值引用绑定后，也能进行正常的赋值等操作。 更广泛的说，所有非常量的左值和右值都能进行赋值等操作。 . int ins = 50; int &amp;rint = ins; int &amp;&amp;rrint = 10; // 正确：rint绑定到ins，ins的值被改为15 rint = 15; // 正确：rrint绑定到一个值为10的临时对象上，\\ 该对象的值被改为35 rrint = 35; . 因为无法令引用重新绑定到另外一个对象，因此==定义的引用必须显式初始化==。 . 可以用extern只声明而不定义引用。 . 引用操作如int &amp;i = p; 的原理其实就是将i这个变量的内存地址改为p变量名的内存地址值，这两个变量的地址是一样的，指向同一个实体。 . 引用类型修饰符只作用于变量，且放置在变量的左边。 . 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字，所以不能定义引用的引用。 . 无特殊说明的情况下，所有引用的类型都要和与之绑定的对象严格匹配(也就是两个变量的类型要一模一样，就算是两个能隐式转换的类型都不行) . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#243-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#243-引用类型"
  },"199": {
    "doc": "复合类型",
    "title": "2.431 左值引用",
    "content": "左值引用顾名思义，也就是只能绑定在左值表达式的引用，所以我们不能将一个左值非常量引用直接绑定到一个右值上。 . 左值引用因为是绑定到左值上的别名，所以绑定后的左值引用也就是一个左值。 . 定义左值引用的语句形式为： . 基本类型(类型说明符) &amp;变量名 (可选: 初始化); . 如： . int ival = 1024; int &amp;refVal = ival; // refVal指向ival (是ival的另一个名字) int &amp;refVal2; //报错：引用必须被初始化 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2431-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2431-左值引用"
  },"200": {
    "doc": "复合类型",
    "title": "2.432 右值引用",
    "content": "右值引用顾名思义，也就是只能绑定在右值表达式的引用，所以我们不能将一个右值引用直接绑定到一个左值上。 . 一般来说，右值是以下几种表达式： . | 临时对象 . | 类型转换完毕的表达式 | 返回右值的表达式 | 非引用返回类型的函数的返回值 | . | 字面值常量 | . 通过右值的特性可以看出，右值引用所绑定的对象都是即将要被销毁的，它们都没有其他的用户。 所以右值引用就直接将这些对象的内存地址变为右值引用的地址，也就接管了所引用对象的资源。 . 右值引用绑定到右值上之后，该右值引用就接管了其右值，所以该右值就不再是临时对象了，它就有了和其他变量一样的生存期了，所以该对象就不再是右值了，而是左值。因此绑定后的右值引用也是一个左值。 . 定义右值引用的语句形式为： . 基本类型(类型说明符) &amp;&amp;变量名 (可选: 初始化); . 如： . int i = 42; int &amp;r = i; // 正确：r引用i int &amp;&amp;rr = i; // 错误：不能将一个右值引用绑定到一个左值上 int &amp;r2 = i * 42; // 错误：i*42是一个右值 const int &amp;r3 = i * 42; // 正确：我们可以将一个const的引用绑定到一个右值上 int &amp;&amp;rr2 = i * 42; // 正确：将rr2绑定到乘法结果上 . 注意当右值引用绑定到字面值时，编译器是根据该字面值的数据创建一个含有该数据的临时对象并绑定到该右值引用上的。所以对该右值引用的操作并不是对其绑定的字面值的操作，而是对这个临时对象的操作。 . 变量可以看作只有一个运算对象而没有运算符的表达式，所以变量表达式是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个，变量是右值引用类型或者const左值引用也不行。 . int &amp;&amp;rrl = 42; //正确：字面常量是右值 int &amp;&amp;rr2 = rrl; //错误：表达式rrl是左值 . 标准库move函数 . 因为右值引用的规定，我们不能直接将左值绑定在右值变量上。但是我们可以通过一些操作，使左值变为右值临时对象，这样就能绑定在右值引用上。 在头文件utility中，我们可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用。 . /* move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。 我们必须认识到，调用move就意味着承诺： 除了对rrl赋值或销毁它外，我们将不再使用它。在调用move之后，我们不能对移后源对象的值做任何假设。 */ int &amp;&amp;rr3 = std::move(rrl); // ok . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2432-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2432-右值引用"
  },"201": {
    "doc": "复合类型",
    "title": "2.44 指针类型",
    "content": "指针（pointer）是另外一种类型的复合类型。 之前也说过，每个对象在定义时，编译器会在程序运行时为其分配存储空间，也就是内存地址，里面存储着其对象的数据，而对象存储空间的大小则由其数据类型的尺寸所决定。每个对象的内存地址一般都由一个16进制的数字来表示。 指针所存储的，也就是初始化或赋值该指针的对象的内存地址值。所以通过指针，可以对其指向的对象进行一些操作。 . 与引用类似，指针也实现了对其他对象的间接访问。 所以一个指针变量可以近似等价于一个引用。 但指针可以只声明，也可以被赋值。 . int or = 8; // 以下的定义语句近似等价 int &amp;r = or; int *ptr = &amp;or; . 根据指针指向的对象的类型的不同，指针的分类一般为以下这几种 . | 指针类型(*) . | 普通指针 . | 空指针 | 空类型指针 | 指向指针的指针 | . | 数组指针 | 函数指针 | 类成员指针 | . | . 指针类型修饰符只作用于变量，且放置在变量的左边。 . 无特殊说明的情况下，所有指针类型变量都要和与之绑定的对象严格匹配(也就是两个变量的类型要一模一样，就算是两个能隐式转换的类型都不行) . 对于C语言来说，任何变量实体的地址都能赋值给任何其他类型的指针，且任何指针类型的相互强制类型转换都合法且能通过编译。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#244-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#244-指针类型"
  },"202": {
    "doc": "复合类型",
    "title": "2.441 普通指针",
    "content": "一般定义指针类型变量的语句形式为： . 基本类型(类型说明符) *变量名 (可选: 初始化); . int *ipl, *ip2; // ipl和ip2都是指向int型对象的指针 double dp, *dp2; // dp2是指向double型对象的指针，dp是double型对象 . 因为指针存放的是某个对象的地址，不能直接用其他非地址值来为其初始化或赋值。(在64位机器上，所有类型的指针的尺寸一般为8字节，且内存地址是以16进制的整型字面值来表示的。但指针与整型没有隐式转换，所以都是可以用显式转换将整型值作为地址值赋值给指针，但不推荐这样做) . double dval; double *pd = &amp;dval; //正确：初始值是double型对象的地址 //错误，不能直接用非地址值初始化指针 double *pd2 = dval; double *pd3 = 3.6; double *pd4 = pd; //正确：初始值是pd指针所指向的对象的地址 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2441-%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2441-普通指针"
  },"203": {
    "doc": "复合类型",
    "title": "2.4411 获取对象地址",
    "content": "所以我们必须要获取该对象的地址，获取其地址需要使用取地址符（操作符&amp;）: 形式为 . &amp;对象名 . 取地址符(&amp;)为一元运算符，运算对象在右侧。 运算对象为左值，运算结果为右值。 返回一个指向该运算对象的指针。 . double dval; double *pd = &amp;dval; //正确：初始值是double型对象的地址 double *pd2 = pd; //正确：初始值是指向double对象的指针 int *pi = pd; //错误：指针pi的类型和pd的类型不匹配 pi = &amp;dval; //错误：试图把double型对象的地址赋给int型指针 . 指针和引用不一样：任何指针，包括底层const指针，都不能指向任何字面值或者临时对象，指针只能指向各种变量(也就是指针只能指向左值)。 . const int ins = 8; // 正确：底层const指针能够指向const变量。 const int *pi = &amp;ins; // 错误：指针不能指向临时对象。 const int *pi = &amp;(ins + 2); // 错误：指针不能指向字面值。 const int *pi = &amp;10; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24411-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%9C%B0%E5%9D%80",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24411-获取对象地址"
  },"204": {
    "doc": "复合类型",
    "title": "2.4412 访问指针指向的对象",
    "content": "如果指针指向了一个对象，则允许使用解引用符（操作符*）来访问该对象: 形式为 . *对象名 . 解引用符(*)为一元运算符，运算对象在右侧。 运算对象为右值，运算结果为左值。 返回一个运算对象所指向的对象的引用。 . 对指针使用解引用符时必须注意该指针确实指向了某个可见的存在的对象，否则就会出现未定义行为 . int ival = 42; int *p = &amp;ival; // p存放着变量ival的地址，或者说p是指向变量ival的指针 cout « *p; //由符号*得到指针p所指的对象，输出42 *p = 0; //由符号*得到指针p所指的对象，即可经由p为变量ival赋值 cout « *p; // 输出0 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24412-%E8%AE%BF%E9%97%AE%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%AF%B9%E8%B1%A1",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24412-访问指针指向的对象"
  },"205": {
    "doc": "复合类型",
    "title": "2.4413 指向指针的引用",
    "content": "引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用： . int i = 42; int *p; // p是一个int型指针 int *&amp;r = p; // r是一个对指针p的引用 r = &amp;i; // r引用了一个指针，因此给r賦值&amp;i就是令p指向i *r = 0; // 解引用r得到i，也就是p指向的对象，将i的值改为0 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24413-%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24413-指向指针的引用"
  },"206": {
    "doc": "复合类型",
    "title": "2.4414 空指针",
    "content": "空指针（null pointer）是指不指向任何对象的指针。 在试图使用一个指针之前代码可以首先检查它是否为空。 以下列出几个生成空指针的方法： . int *pl = nullptr; // 等价于 int *pl = 0; int *p2 = 0; //直接将p2初始化为字面值常量0 // 需要首先#include cstdlib int *p3 = NULL; // 等价于 int *p3 = 0; . 把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。 . int zero = 0; pi = zero; //错误：不能把int变量直接赋给指针 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24414-%E7%A9%BA%E6%8C%87%E9%92%88",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24414-空指针"
  },"207": {
    "doc": "复合类型",
    "title": "2.4415 空类型指针",
    "content": "空类型指针(void*)是一种特殊的指针类型，可用于存放任意对象的地址。 一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。 因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作，所以不能直接操作void*指针所指的对象。 . double obj = 3.14, *pd = &amp;obj; //正确：void*能存放任意类型对象的地址 void *pv = &amp;obj ; // obj可以是任意类型的对象 pv = pd; // pv可以存放任意类型的指针 cout &lt;&lt; *pd; // 正确：可以解引用double指针 cout &lt;&lt; *pv; // 错误：不能解引用void*指针 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24415-%E7%A9%BA%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24415-空类型指针"
  },"208": {
    "doc": "复合类型",
    "title": "2.4416 指向指针的指针",
    "content": "因为指针类型修饰符作用于变量，且指针类型不像引用类型，是对象，所以像其他对象一样，也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。 . 指向指针的指针的定义 . 通过*的个数可以区分指针的级別。也就是说，**表示指向指针的指针，***表示指向指针的指针的指针，以此类推： . int ival = 1024; int *pi = &amp;ival; // pi指向一个int型的数 int **ppi = &amp;pi; // ppi指向一个int型的指针 . 下图描述了它们之间的关系。 . 指向指针的指针有严格的级别限制，不能用不是该级别的指针来指向某指针或者实体 . 但对于C语言的指针来说，没有严格的级别限制，用不是该级别的指针来指向某指针或者实体只会警告，但仍会通过编译。 . int ival = 1024; int *pi = &amp;ival; // 正确，pi指向一个int型的数 int **ppi = &amp;ival; // 错误，int**类型的指针不能用int*类型的指针来赋值。 . 指向指针的指针的解引用 . 解引用int型指针会得到一个int型的数，同样，解引用指向指针的指针会得到一个指针。此时为了访问最原始的那个对象，需要对指针的指针做两次解引用： . int ival = 1024; int *pi = &amp;ival; int **ppi = &amp;pi; cout &lt;&lt; \"The value of ival\\n\" &lt;&lt; \"direct value: \" &lt;&lt; ival &lt;&lt; \"\\n\" &lt;&lt; \"indirect value: \" &lt;&lt; *pi &lt;&lt; \"\\n\" &lt;&lt; \"doubly indirect value: \" &lt;&lt; **ppi &lt;&lt; endl; // 该程序使用三种不同的方式输出了变量ival的值：第一种直接输出；第二种通过int型指针pi输出；第三种两次解引用ppi,取得ival的值。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24416-%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24416-指向指针的指针"
  },"209": {
    "doc": "复合类型",
    "title": "2.442 有关数组的指针",
    "content": "以下是有关数组的指针分类： . | 指向数组元素的指针 | 指向数组的指针 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2442-%E6%9C%89%E5%85%B3%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2442-有关数组的指针"
  },"210": {
    "doc": "复合类型",
    "title": "2.4421 指向数组元素的指针",
    "content": "通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针: . string nums [] = {\"one\", \"two\", \"three\" }; // 数组的元素是 string 对象 string *p = &amp;nums[0] ; // p 指向 nums 的第一个 . 然而，数组还有一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针。 要注意，在c++中，直接使用数组名字和对数组使用取地址符是不一样的，对数组使用取地址符是取得一个指向该数组的指针，而不是指向数组首元素的指针。 . 但对于C语言来说，数组(包括多维数组)使用取地址符的效果和直接使用数组名字的效果是一样的，对数组(包括多维数组)使用取地址符也是得到指向数组首元素的指针。 . string nums[] = {\"one\", \"two\", \"three\"}; string *p2 = nums; // 等价于 p2 = &amp;nums[0]; string *p3 = &amp;nums; // 错误：string(*)[3]指针不能赋值给string*类型指针。 . 不能用临时数组的地址来初始化或赋值指向数组元素的指针 . int *ap; ap = (int[3]){6,8,1}; // 错误，不能临时数组赋值 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24421-%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24421-指向数组元素的指针"
  },"211": {
    "doc": "复合类型",
    "title": "2.4422 指向数组的指针",
    "content": "指向数组的指针所存储的并不是普通变量的地址，而是某个数组的地址，因此指向数组的指针的类型必须也是数组类型。 . 但对于C语言来说，多维数组的首元素仍是一个数组的元素而不是数组，所以指向多维数组的指针可以是普通的一维指针，且C语言的多维指针的维度可以被不一样维度的数组赋值。 . int two_arr[][3] = {3,6,8,4,2,5,3,7,8}; // 定义二维int数组 // 正确：两种指向二维int数组的指针定义等价 int (*p)[3] = two_arr; int (*p2)[3] = &amp;two_arr[0]; int (*p3)[3] = two_arr[0]; // 错误：二维int数组指针不能用int赋值 int (*p4)[] = two_arr; // 错误：定义指向数组的指针不能省略数组的维度 int *p4[3] = two_arr; // 错误：指针数组不能用二维int数组初始化 . 和普通数组一样，多维数组名默认转换为指向该数组首元素的指针，但其首元素是数组，所以此时不能用指向数组元素的指针来保存其地址，必须要用指向该数组的指针来保存。 . 和普通数组一样，不能用临时数组的地址来初始化或赋值指向数组的指针 . 定义指向数组的指针时不能省略数组的维度，且维度的数量与容量大小必须与初始化或赋值该指针的对象维度一一对应 . 定义指向数组的指针时不能缺少括号，否则就变成定义指针数组了 . 当我们访问指向数组的指针的最里层的元素时，需要逐层访问。所以使用指向数组的指针时也需要逐层解引用来访问 . int two_arr[][3] = {3,6,8,4,2,5,3,7,8}; // 定义二维int数组 int (*p)[3] = two_arr; cout &lt;&lt; **p; // 正确：输出第一行数组的首元素3 cout &lt;&lt; *p; // 错误：不能输出指针所存的内存值 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24422-%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24422-指向数组的指针"
  },"212": {
    "doc": "复合类型",
    "title": "2.443 函数指针",
    "content": "函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定的函数类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。 . //比较两个string对象的长度，该函数类型为 // bool (const string&amp;, const string&amp;); bool lengthCompare(const string &amp;, const string &amp;); . 函数指针的定义 . 定义一个指向某函数的指针，只需要先写出该函数的声明(函数形参名不要写)，然后用指针来替换掉函数声明中的函数名即可。 语句形式为： . 返回类型 (*指针变量名) (形参类型1, 形参类型2, …) (可选: 初始化); . 指针两端的括号必不可少，如果不写这对括号，则定义的是一个返回值为指针的函数 . //比较两个string对象的长度，该函数类型为 // bool (const string&amp;, const string&amp;); bool lengthCompare(const string &amp;, const string &amp;); // pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型 bool (*pf) (const string &amp;, const string &amp;); //未初始化 //声明一个名为pf2的函数，该函数返回bool* bool *pf2(const string &amp;, const string &amp;); . 因为函数的类型由它的返回类型和形参类型共同决定，所以当我们定义指向重载函数的指针时，必须清晰地指明到底应该定义哪个函数，也就是指针类型必须与其精确匹配(但是可以忽略顶层const)。 . 所以定义指向重载函数的指针时，不能使用auto类型和decltype(函数名)形式。 . void ff(int*); void ff(unsigned int); void (*pf1)(unsigned int) = ff; // pf1指向ff (unsigned) void (*pf2) (int) = ff; //错误：没有任何一个ff与该形参列表匹配 double (*pf3) (int*) = ff; //错误：ff和pf3的返回类型不匹配 // 以下都为错误：无法判断是哪个ff auto pf4 = ff; decltype(ff) (*pf5) = ff; . 函数指针的初始化和赋值 . 和数组名一样，当我们把函数名作为一个值使用时，该函数会自动地转换成指针。 . pf = lengthCompare; // pf 指向名为 lengthCompare 的函数 pf = &amp;lengthCompare; //等价的赋值语句：取地址符是可选的 . 初始化和赋值某函数指针的对象的类型必须与该函数指针精确匹配，也就是返回类型和参数表类型一模一样(但是可以忽略顶层const) . 可以用运算符函数来初始化和赋值函数指针，只要与该指针的类型精确匹配就行 . // Tef和Te4是两个类类型，假设Tef永远比Te4大，定义了一个关系运算符 bool operator==(Tef tef, Te4 te4) { return true; } bool (*p) (Tef, Te4) = operator==; // 正确：类型精确匹配 . 在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何一个函数。 . string::size_type sumLength(const strings, const strings); bool cstringCompare(const char*, const char*); pf = 0; //正确：pf不指向任何函数 pf = sumLength; //错误：返回类型不匹配 pf = cstringCompare; //错误：形参类型不匹配 pf = lengthCompare; //正确：函数和指针的类型精确匹配 . 函数指针的使用 . 函数指针是指向某函数的指针，所以可以通过函数指针来调用该函数。 当我们使用函数指针时，可以像调用函数的形式一样，直接调用该函数，而无须提前解引用。 语句形式为 . (*指针变量名)/指针变量名 实参表; . pf = lengthCompare; // pf指向名为lengthCompare的函数 pf = &amp;lengthCompare; //等价的赋值语句：取地址符是可选的 bool bl = pf(\"hello\", \"goodbye\"); //调用 lengthCompare函数 bool b2 = (*pf) (\"hello\", \"goodbye\"); // 一个等价的调用 bool b3 = lengthCompare (\"hello\", \"goodbye\"); // 另一个等价的调用 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2443-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2443-函数指针"
  },"213": {
    "doc": "复合类型",
    "title": "2.444 类成员指针",
    "content": "成员指针(pointer to member)是指可以指向类的非静态成员的指针。 . 其他指针一般情况下是指向一个对象，但是成员指针指示的是类的成员，而非类的对象。所以当初始化一个这样的指针时，我们令其指向类的某个成员，但不要指定该成员所属的对象。直到使用成员指针时，才提供成员所属的对象。 . 类的静态成员不属于任何对象，因此无须特殊的指向静态成员的指针，指向静态成员的指针与普通指针没有什么区别。 . 成员指针的类型不仅要指明指向的成员的类型，还需指明包含该成员的类。 . 根据成员的类型，成员指针分为两种 . | 数据成员指针 | 函数成员指针 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2444-%E7%B1%BB%E6%88%90%E5%91%98%E6%8C%87%E9%92%88",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#2444-类成员指针"
  },"214": {
    "doc": "复合类型",
    "title": "2.4441 成员指针的定义",
    "content": "和其他指针一样，在声明成员指针时我们也使用*来表示当前声明的名字是一个指针。与普通指针不同的是，成员指针还必须包含成员所属的类，该类不能是不完全类型。因此定义成员指针的语句形式为： . 数据成员指针定义： . 数据成员类型说明符(可含类型修饰符) 包含该成员的类名::*指针名(可含类型修饰符) (可选: 初始化); . // pdata是一个常量指针，可以指向一个常量（非常量）Screen对象的string成员 const string Screen::*const pdata; . 函数成员指针定义： . 函数成员的返回类型 (包含该成员的类名::*指针名(可含类型修饰符)) 函数成员的形参表 (可选 类型修饰符) (可选: 初始化); . 如果成员函数是const成员或者引用成员函数，则我们必须将const限定符或引用限定符包含进来。 . 函数成员指针也是函数指针，指针名两端的括号必不可少 . char (Screen::*pmf2)(Screen::pos, Screen::pos) const; //错误：非成员函数p不能使用const限定符 char Screen::*p(Screen::pos, Screen::pos) const; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24441-%E6%88%90%E5%91%98%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24441-成员指针的定义"
  },"215": {
    "doc": "复合类型",
    "title": "2.4442 成员指针的初始化或赋值",
    "content": "当我们初始化一个成员指针（或者向它赋值）时，必须指定它所指的成员，而非指定一个特定的该类对象的成员。且指定的成员不能是不可访问的。 . 初始化或赋值成员指针的语句形式为： . &amp;类名::成员名; . 通常来说，初始化或赋值一个数据成员指针时，成员的类型、包含该成员的类名之间都要严格匹配(但是可以忽略顶层const)。 . 但当成员指针所指向成员的所属的类存在继承关系时: . | 对于数据成员指针： 可以用该成员指针所指向成员的所属类的基类或派生类对该成员指针初始化或赋值，前提是指定的成员的类型严格匹配且该成员也存在并可见于指向成员的所属类中(注意派生类同名成员覆盖的问题)。 . | 对于函数成员指针： 可以用该成员指针所指向成员的所属类的基类对该成员指针初始化或赋值，前提是指定的成员的类型严格匹配且该成员也存在并可见于指向成员的所属类中(注意派生类同名成员覆盖的问题)。 . | . 数据成员指针的初始化或赋值 . // pdata可以指向一个常量（非常量）Screen对象的string成员 const string Screen::*pdata; Screen scr; pdata = &amp;Screen::contents; // 正确：指定了它所指的成员 const string Screen::*pdata2 = &amp;scr.contents; // 错误：不能指定特定的该类对象的成员 // pdat可以指向一个常量（非常量）Te2对象的int成员。 // Te是Te2的公有基类，且Te有int成员tins。 // Te3，Te4是Te2的公有派生类，Te4定义了自己的int成员tins const int Te2::*pdat; // 两个都正确：Te，Te3分别是Te2的基类和派生类，且这三类都有从Te继承的int成员tins。 pdata = &amp;Te3::tins; pdata = &amp;Te::tins; // 错误：Te4是Te2的派生类，虽然Te4有从Te继承的int成员tins // 但Te4定义了自己的同名成员tins，隐藏了继承的int成员tins // 所以编译器判断Te4的tins为Te4自己定义的那个版本 // Te2中不存在Te4定义的tins版本，因此出错 pdata = &amp;Te4::tins; . 函数成员指针的初始化或赋值 . 和函数指针一样： . | 函数成员指针的类型要严格匹配(但是可以忽略顶层const)。 | 成员函数名也可以隐式转换为指向该函数的指针。 | 可以用auto类型和decltype(函数名)形式自动判断类型，但是不能用于有重载的成员函数。 | . 函数成员指针是否指向const成员要与其初始化或赋值一致。 . 函数成员指针所指的成员必须是非构造和析构函数，可以是虚函数和运算符函数。 . 和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则 . char (Screen::*pmf2)(Screen::pos, Screen::pos) const; pmf2 = &amp;Screen::get; . // pmf指向一个Screen成员，该成员不接受任何实参且返回类型是char pmf = &amp;Screen::get; //必须显式地使用取地址运算符 pmf = Screen::get; //错误：在成员函数和指针之间不存在自动转换规则 . // pfun可以指向一个Te2对象的成员，该成员不接受任何实参且返回类型是void。 // Te是Te2的公有基类。 // Te3，Te4是Te2的公有派生类，这四个类都定义了自己的void prr()虚函数和非虚函数void no_vir() void (Te2::*pfun) (); // 三个都正确，Te是Te2的公有基类。 pfun = &amp;Te2::prr; pfun = &amp;Te::prr; pfun = &amp;Te::no_vir; // 错误：Te3和Te4是Te2的派生类 pfun = &amp;Te3::prr; pfun = &amp;Te4::no_vir; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24442-%E6%88%90%E5%91%98%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%96%E8%B5%8B%E5%80%BC",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24442-成员指针的初始化或赋值"
  },"216": {
    "doc": "复合类型",
    "title": "2.4443 成员指针的使用",
    "content": "必须清楚的一点是，当我们初始化一个成员指针或为成员指针赋时，该指针并没有指向任何数据。成员指针指定了成员而非该成员所属的对象，只有当需要使用成员指针时我们才提供类对象的信息。 . 和普通指针一样，成员指针必须要初始化后才能使用。 . 因为是类成员指针，所以我们使用成员指针时必须要先使用成员访问运算符，再使用解引用才能获得该对象的成员。 . 我们提供的类对象必须存在之前成员指针所指定的成员，并且该成员还能被访问。 . 成员指针解引用所得的成员，一般来说是该指针初始化或赋值阶段时指定的类中的指定成员(静态类型的对应成员)。 但当成员指针所指向成员的所属的类存在继承关系时。对于所属的类有虚函数的函数成员指针来说，如果函数成员指针之前指定的是虚函数，那么成员指针解引用所得的成员函数到底是哪个版本，(动态类型的对应成员)则要根据提供对象的类型来决定(也就是动态绑定) . 和初始化或赋值阶段一样。通常来说，提供对象的类型要与定义成员指针指明的所属类严格匹配。 . 但当成员指针所指向成员的所属的类存在继承关系时。 提供对象的类可以是成员指针所指向成员的所属类的派生类。 . 数据成员指针的使用： . 使用数据成员指针的语句形式为(这两种都返回该对象成员的引用): . 类对象名.成员指针名; 或 指向类对象的指针名-&gt;成员指针名; . Screen myScreen, *pScreen = &amp;myScreen; // .*解引用pdata以获得myScreen对象的contents成员 auto s = myScreen.*pdata; // -&gt;*解引用pdata以获得pScreen所指对象的contents成员 s = pScreen-&gt;*pdata; . 函数成员指针的使用： . 使用函数成员指针的语句形式为: . (类对象名.成员指针名) 实参表; 或 (指向类对象的指针名-&gt;成员指针名) 实参表; . 因为是调用运算符的优先级要高于指针指向成员运算符的优先级，所以的括号必不可少 . Screen myScreen, *pScreen = &amp;myScreen; //通过pScreen所指的对象调用pmf所指的函数 char cl = (pScreen-&gt;*pmf)(); //通过myScreen对象将实参0, 0传给含有两个形参的get函数 char c2 = (myScreen.*pmf2) (0, 0); // 错误示范：以下这两个等价，这行代码的意思是调用一个名为pmf的函数，然后使用该函数的返回值作为指针指向成员运算符(.*)的运算对象。然而pmf并不是一个函数，因此代码将发生错误 myScreen.*pmf(); myScreen.*(pmf()); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24443-%E6%88%90%E5%91%98%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24443-成员指针的使用"
  },"217": {
    "doc": "复合类型",
    "title": "2.4443 成员函数指针与可调用对象",
    "content": "可调用对象就是指某一个对象或者表达式，如果可以对其使用调用运算符，则称它为可调用对象，我们之后会详细介绍。 . 调用形式是由可调用对象的返回类型以及所有形参类型所组成，一种调用形式对应一个函数类型。 例如：int(int, int) 是一个函数类型，它接受两个int，返回一个int。 . 与普通的函数指针不同，成员函数指针不是一个可调用对象，这样的指针不支持函数调用运算符。 所以为了能够让成员函数指针向可调用对象一样可以通过函数调用符来进行调用，我们可以有三种方法(这几种方法都定义在functional头文件中)： . | function类 | bind函数 | mem_fn函数 | . 要知道非静态的成员函数都有一个隐式的this形参，该形参为指向所属类对象的常量指针，当该成员函数为const成员时，该形参指向的就是常量版本。 所以要将成员函数指针转换为可调用对象时，必须要显式指出该成员函数指针的第一个形参。 . 但是显式指出的第一个形参不一定非要和this形参的类型一样，该形参类型可以是所属类的类型以及所属类类型的指针和引用。 . function类需要显式指定成员的调用形式，且生成的可调用对象只有一种调用方式；bind函数和mem_fn函数不需要显式指定成员的调用形式，且这两种生成的可调用对象的第一个形参既能接受该成员所属类的对象，也能接受该成员所属类的对象的地址。 . function类 . 之后我们会讲到function类的具体使用，现在只需知道function类是一个模板，该模板需要显式提供一个有着返回类型和形参表的调用形式，该形式指定所创建的对象能够保存哪些可调用对象的数据。 . function类对象需要用一个调用形式匹配的可调用对象来初始化才能使用，该对象也能被匹配的可调用对象赋值。 function类对象的调用形式和其显式声明的一样。 . struct Cls { void prints() { cout &lt;&lt; \"print\\n\"; } }; Cls obj; // 生成一个函数成员指针，指向Cls类的prints函数 void (Cls::*ptr) () = Cls::prints; // 这三种形式都正确 // f1调用形式为void (Cls) function&lt;void (Cls)&gt; f1 = ptr; // f1调用形式为void (Cls&amp;) function&lt;void (Cls&amp;)&gt; f2 = ptr; // f1调用形式为void (Cls*) function&lt;void (Cls*)&gt; f2 = ptr; . bind函数 . 之后我们也会讲到bind函数的具体使用，现在只需知道bind函数可以根据给定对象来生成一个与给定对象的形参表不一样的可调用对象。 bind函数的使用形式为： . bind(原始可调用对象, 调用原始可调用对象的实参表) . struct Cls { void prints() { cout &lt;&lt; \"print\\n\"; } }; Cls obj; void (Cls::*pf) () = Cls::prints; // 根据函数成员指针生成的可调用对象func auto func = bind(pf, std::placeholders::_1); // 正确：接受Cls的对象obj，输出print func(obj); // 正确：接受Cls的对象obj的地址，输出print func(&amp;obj); . mem_fn函数 . mem_fn函数接受一个函数成员的地址，可以根据该函数成员的类型自动推断可调用对象的类型，而无须用户显式地指定。 mem_fn函数的使用形式为： . mem_fn(函数成员的地址) . 和auto等一样，当直接将函数成员的地址赋给mem_fn函数时，该函数成员不能有重载。 . struct Cls { void prints() { cout &lt;&lt; \"print\\n\"; } }; Cls obj; void (Cls::*pf) () = Cls::prints; // 根据函数成员指针生成的可调用对象func auto func = mem_fn(pf); // 正确：接受Cls的对象obj，输出print func(obj); // 正确：接受Cls的对象obj的地址，输出print func(&amp;obj); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24443-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html#24443-成员函数指针与可调用对象"
  },"218": {
    "doc": "复合类型",
    "title": "复合类型",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html"
  },"219": {
    "doc": "限定符与说明符",
    "title": "2.5 常量限定符",
    "content": "有时我们希望定义这样一种变量，它的值不能被改变。此时可以用常量类型修饰符对变量的类型加以限定。 . 对于常量类型修饰符，有两种 . | const | constexpr | . 这两种虽然都能定义常量类型，但是还是有很大的区别的。 . 虽然没有意义，但是const和constexpr可以作用于同一个定义或声明语句中，修饰同一个类型，此时变量以类型修饰符constexpr的规则为主。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#25-%E5%B8%B8%E9%87%8F%E9%99%90%E5%AE%9A%E7%AC%A6",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#25-常量限定符"
  },"220": {
    "doc": "限定符与说明符",
    "title": "2.51 const限定符",
    "content": "例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。 另一方面，也应随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以用关键字const对变量的类型加以限定 . 一般定义const对象的语句形式为 . const 类型说明符 变量名 (初始化); 或 类型说明符 const 变量名 (初始化); . 任何const对象一旦创建后其值就不能再改变，任何试图为其赋值的行为都将引发错误。 . const int bufSize = 512; // 输入缓冲区大小 buf Size = 512; //错误：试图向const对象写值 . 类型修饰符const既可作用于类型，也可作用于变量。当无其他类型修饰符修饰变量时，默认作用于其类型。 . 作用于类型时，放置在类型的左边右边都可以。 作用于变量时，只能放置在变量的左边。 . // 这两个定义语句形式等价，都是定义了3个const int型变量，const此时修饰的是int类型 const int j = 8, k = 9, l = 10; int const j = 8, k = 9, l = 10; // 定义了一个指向int的常量指针p和一个int变量ins，const此时修饰的是变量p int *const p = nullptr, ins = 6; . 因为const对象一旦创建后其值就不能再改变，所以==定义的const对象必须显式初始化==。一如既往，初始值可以是任意复杂的表达式。 . 但是const变量可以用extern只声明而不定义。 . const int i = get_size () ; //正确：运行时初始化 const int j = 42; //正确：编译时初始化 const int k; //错误：k是一个未经初始化的 . 默认状态下，const对象仅在当前文件内有效，要想多文件内都有效要用之前说的extern存储修饰符。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#251-const%E9%99%90%E5%AE%9A%E7%AC%A6",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#251-const限定符"
  },"221": {
    "doc": "限定符与说明符",
    "title": "2.511 非引用或指针类型的const变量",
    "content": "const对于非引用或指针类型的变量来说，用const修饰后的变量，其变量无法被赋值。 . 对于容器类来说，const的对象不仅无法被赋值，其元素也无法类赋值。 . 对于派生类类型来说，const的对象不仅无法被赋值，其非mutable的非静态成员也无法被赋值，且const对象无法使用非const的函数成员。 . 支持拷贝初始化的非引用或指针类型的const变量与对应类型的非const变量之间能够相互初始化对方。 支持赋值的非引用或指针类型的非const变量能够被对应类型的const变量赋值。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#2511-%E9%9D%9E%E5%BC%95%E7%94%A8%E6%88%96%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84const%E5%8F%98%E9%87%8F",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#2511-非引用或指针类型的const变量"
  },"222": {
    "doc": "限定符与说明符",
    "title": "2.512 引用类型的const变量",
    "content": "可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量 的引用(reference to const)。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象 . 要注意引用本身并不是对象，所以const只能修饰引用所绑定的对象的类型 . const int ci = 1024; const int &amp;rl = ci; //正确：引用及其对应的对象都是常量 rl = 42; //错误：rl是对常量的引用 int &amp;r2 = ci; //错误：试图让一个非常量引用指向一个常量对象 . 之前说过，引用的类型必须与其所引用对象的类型一致，不能用常量引用来初始化非常量引用。 . 右值常量引用同样遵循这个规则，不能用常量引用来初始化右值非常量引用。 . 要注意，不管是右值引用还是右值常量引用都能绑定到对应类型的字面值常量上。 . const int &amp;&amp;r1 = 84; const int &amp;&amp;r2 = std::move(r1); // 正确：右值常量引用来初始化右值常量引用。 int &amp;&amp;r3 = std::move(r1); // 错误：不能用右值常量引用来初始化右值非常量引用。 int &amp;&amp;r4 = 53; // 正确：右值引用可以由字面值常量来初始化。 . 左值常量引用能够用任意表达式作为初始值，尤其，允许为一个常量引用绑定对应类型的常量或非常量引用、非常量的对象、字面值，甚至是个一般表达式(也就是左值常量引用能够绑定到右值上了)： . int i = 42;- const int &amp;rl = i; //允许将const int&amp;绑定到一个普通int对象上 const int &amp;r2 = 42; //正确：rl是一个常量引用 const int &amp;r3 = rl * 2; //正确：r3是一个常量引用 int &amp;r4 = rl * 2; //错误：r4是一个普通的非常量引用 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#2512-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84const%E5%8F%98%E9%87%8F",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#2512-引用类型的const变量"
  },"223": {
    "doc": "限定符与说明符",
    "title": "2.513 指针类型const变量",
    "content": "根据const在指针对象所处的不同位置，const指针可以分为两种 . | 顶层const(top-level const) | 底层const (low-level const) | . 顶层const表示该指针本身是个常量，更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等(引用本身就是不可被修改赋值的)。 . 而底层const一般用于表示指针所指的对象是一个常量，多用于与指针和引用类型 . 指针类型既可以是顶层const也可以是底层const，或者两者都是 . int i = 0; int *const pl = &amp;i; //不能改变pl的值，这是一个顶层const const int ci = 42; //不能改变ci的值，这是一个顶层const const int *p2 = &amp;ci; //允许改变p2的值，这是一个底层const const int *const p3 = p2; // 靠右的 const 是顶层 const,靠左的是底层 const const int &amp;r = ci; //用于声明引用的const都是底层const . 顶层const和底层顶层const的区别为 . | 顶层const能初始化或赋值对应类型的非const变量，非const变量也能初始化顶层const . | 非const变量能初始化底层const，但底层const却不能初始化或赋值对应类型的非const变量。 . | . 也就是所有的非常量都能转换为常量，而反过来，只有顶层const才能转成非常量，底层const不行。 . i = ci; //正确：拷贝ci的值，ci是一个顶层const,对此操作无影响 p2 = p3; //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响 int *p = p3; //错误：p3包含底层const的定义，而p没有 p2 = p3; //正确：p2和p3都是底层 const p2 = &amp;i; // 正确：int*能转换成 const int*int &amp;r = ci; //错误：普通的int&amp;不能绑定到int常量上 const int &amp;r2 = i; //正确：const int&amp;可以绑定到一个普通in . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#2513-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8Bconst%E5%8F%98%E9%87%8F",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#2513-指针类型const变量"
  },"224": {
    "doc": "限定符与说明符",
    "title": "2.52 constexpr限定符",
    "content": "在讲解constexpr限定符之前，我们需要先弄清楚常量表达式的概念。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#252-constexpr%E9%99%90%E5%AE%9A%E7%AC%A6",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#252-constexpr限定符"
  },"225": {
    "doc": "限定符与说明符",
    "title": "2.521 常量表达式",
    "content": "常量表达式，是指值不会改变并且在编译过程中就能得到计算结果的表达式。显然，字面值属于常量表达式。 . 常量表达式不能是任何的声明或定义形式的表达式。 . 常量表达式的值要在编译过程中就能得到结果，指的是以下几种情况： . | 常量表达式中参与常量表达式结果运算的子表达式必须要能在编译过程中就能得到结果，而不能要在程序运行时才能获得。 | 常量表达式中不参与常量表达式结果运算的子表达式要在该常量表达式所对应的语句执行之前就能得到结果。 | . // 非常量的int变量 int ins = 85; // 正确：\"literals\"是字面值，不需要在该表达式运行时才能有结果。cstexpr_ins值为8。 constexpr int cstexpr_ins = (\"literals\", 8); // 正确：ins是非常量的int变量，ins的值在该定义语句之前就已经获得。cstexpr_ins2值为15。 constexpr int cstexpr_ins2 = (ins, 15); // 错误：表达式ins = 18需要在该定义语句运行时才能得到结果。 constexpr int cstexpr_ins3 = (ins = 18, 3); // 错误：表达式ins + 18需要在该定义语句运行时才能得到结果。 constexpr int cstexpr_ins4 = (ins + 15, 6); . 常量和常量表达式的概念不一样： . | 常量是指字面值或者由const或constexpr类型说明符修饰的变量。 | 满足以下任意一种情况才为常量表达式： . | 满足常量表达式情况的式子。 | 字面值。 | 由const类型说明符修饰的变量，且该变量的初始值也是常量表达式。 | 由constexpr类型说明符修饰的已初始化的变量。 | . | . 所以可知==常量不一定是常量表达式，但常量表达式一定是常量==。 . 一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定的。 . const int max_files = 20; // max_files 是常量表达式 const int limit = max_files + 1; // limit 是常量表达式 int staff_size = 27; // staff_size 不是常量表达式，由于它的数据类型只是一个普通int而非const，所以它不属于常量表达式 const int sz = get_size(); // sz 不是常量表达式。尽管sz本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#2521-%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#2521-常量表达式"
  },"226": {
    "doc": "限定符与说明符",
    "title": "2.522 constexpr变量",
    "content": "C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。 . 类型修饰符constexpr只作用于变量，但是是放置在类型的左边或右边。constexpr修饰的是该定义语句的所有定义的变量而不是某一个，所以一个语句中只需在开头标注就行。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#2522-constexpr%E5%8F%98%E9%87%8F",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#2522-constexpr变量"
  },"227": {
    "doc": "限定符与说明符",
    "title": "2.5221 constexpr变量的定义和初始化",
    "content": "声明为constexpr的变量的类型一定要是字面值类型，而且必须用常量表达式初始化，所以==constexpr变量一定是常量表达式==。 . 和const变量一样，==定义的constexpr变量也必须显式初始化==，且constexpr变量不能用extern只声明而不定义。 . constexpr int mf = 20; // 20 是常量表达式 constexpr int limit = mf + 1; // mf + 1 是常量表达式 constexpr int sz = size(); // 只有当 size 是一个constexpr 函数时，才是一条正确的声明 . 对于类型修饰符constexpr来说，不存在像const一样有着顶层底层之分，constexpr修饰指针和引用时，只会作用于它们本身，不会影响到它们所指的对象 . const int *p = nullptr; // p是一个指向整型常量的指针 constexpr int *q = nullptr; // q是一个指向整数的常量指针 . 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。 一个constexpr指针的初始值必须是空指针，或者是非栈区的对象。 constexpr引用也是一样，只能绑定非栈区的对象。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#25221-constexpr%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#25221-constexpr变量的定义和初始化"
  },"228": {
    "doc": "限定符与说明符",
    "title": "2.5222 字面值类型简述",
    "content": "常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”。 . 之前所说的算术类型、引用、指针和枚举类型都属于字面值类型，除此之外，类类型中的字面值常量类也属于字面值类型，其他的类型都不是字面值类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#25222-%E5%AD%97%E9%9D%A2%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%AE%80%E8%BF%B0",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#25222-字面值类型简述"
  },"229": {
    "doc": "限定符与说明符",
    "title": "2.5223 constexpr函数简述",
    "content": "尽管不能使用普通函数作为constexpr变量的初始值，但新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#25223-constexpr%E5%87%BD%E6%95%B0%E7%AE%80%E8%BF%B0",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#25223-constexpr函数简述"
  },"230": {
    "doc": "限定符与说明符",
    "title": "2.6 类型别名",
    "content": "当有时候我们所要声明或定义的类型比较长或者复杂时，为了使用时简单明了、易于理解和使用，我们可以定义类型别名。 . 类型别名(type alias)是一个名字，它是某种类型的同义词。 . 类型别名可用于单一类型，也可用于类型加多个类型修饰符的复杂类型。 . 不能定义auto和decltype的类型别名 . 有两种方法可用于定义类型别名： . | 使用关键字 typedef | 使用关键字 using (该方法也叫做别名声明(alias declaration)) | . typedef定义类型别名 . 使用关键字typedef的语句形式为 . typedef (可选 类型修饰符) 类型说明符 (可选 类型修饰符)别名1, (可选 类型修饰符)别名2, …; . typedef double wages; //wages是double的同义词 typedef wages base, *p; //base是double的同义词，p是double*的同义词 . 和普通声明语句一样，关键字typedef的语句可看做为一种声明语句，关键字typedef看作为数据类型的一部分，但此声明语句中的定义的是类型别名而不是变量。 . 类型修饰符放置的位置和用于普通声明语句一样，放在该放的位置。typedef可以放在声明语句最前面，也可以紧跟在类型说明符的前面。 . // 这两个语句等价，rt1，rt2是const int&amp;的同义词。 // pt1，pt2是const int *const的同义词。 const typedef int &amp;rt1, *const pt1; typedef const int &amp;rt2, *const pt2; . 别名声明定义类型别名 . 使用关键字using的语句形式为 . using 别名 = 类型说明符(可选 类型修饰符); . using SI = Sales_item; // SI是Sales_item的同义词 using ciptr = const int *const; // ciptr是const int *const的同义词 . 类型修饰符放置的位置和用于普通声明语句一样，放在该放的位置。 . 别名声明和typedef的形式不一样，一个别名声明语句只能定义一个别名。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#26-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#26-类型别名"
  },"231": {
    "doc": "限定符与说明符",
    "title": "2.61 类型别名的使用",
    "content": "类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名: . wages hourly, weekly; // 等价于 double hourly、weekly。 SI item; // 等价于 Sales_item item。 . 当用类型别名声明语句定义了一个类型别名时，该类型别名里的所有东西组成了一个基本类型，类型别名里的类型修饰符也是这个基本类型的一部分。要注意当该类型别名用作的类型别名声明语句时的情况： . typedef char *pstring; const pstring cstr = 0; // cstr是指向char的常量指针 const pstring *ps; // ps是一个指针，它的对象是指向char的常量指针 const char *cstr = 0; // 是对const pstring cstr的错误理解 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#261-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#261-类型别名的使用"
  },"232": {
    "doc": "限定符与说明符",
    "title": "2.7 类型自动推断",
    "content": "当我们需要定义一个某表达式的类型的变量，但无法得知或很难得知其类型时，我们可以定义一种能让编译器自动分析表达式所属的类型的变量。 . 类型自动推断有两种方法 . | auto类型说明符 | decltype类型说明符 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#27-%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E6%8E%A8%E6%96%AD",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#27-类型自动推断"
  },"233": {
    "doc": "限定符与说明符",
    "title": "2.71 auto类型说明符",
    "content": "通过定义auto类型的变量，可以让编译器通过分析其变量的初始值所属的类型自动决定该变量的类型。显然，auto定义的变量必须显式初始化。 . auto类型的声明形式为： . auto(可含类型修饰符) 变量名 (可选 初始化) . //由vail和val2相加的结果可以推断出item的类型 auto item = vail + val2; // item初始化为vail和val2相加的结果 . 和普通定义语句一样，auto定义语句也能在一条语句中声明多个变量。auto以第一个变量的初始值类型来决定变量的类型。 因为一条声明语句只能有一个基本类型，因此该语句中所有变量的类型都一样。所以每个变量的初始值的类型必须严格一致(能隐式转换也不行)： . auto i = 0, *p = &amp;i; //正确：i是整数、p是整型指针 auto sz = 0, pi = 3.14; // 错误：sz 和 pi 的类型不一致 . 常量和auto的关系 . 当常量用来初始化auto类型的变量时，编译器推断出来的类型和初始值的类型并不完全一样。 . auto默认情况下会忽略掉顶层const，所以希望推断出的类型是一个顶层const，则需要明确指定为const。 . 当初始化的值为左值时，auto会保留底层const；为右值时，auto会忽略掉底层const。 . const int ci = i, &amp;cr = ci; auto b = ci; // b是一个整数（ci的顶层const特性被忽略掉了） auto c = cr; // c是一个整数（cr是ci的别名，ci本身是一个顶层const） auto d = &amp;i; // d是一个整型指针（整数的地址就是指向整数的指针） auto e = &amp;ci; // e是一个指向整数常量的指针（对常量对象取地址是一种底层const） const auto f = ci; // ci的推演类型是int, f是const int auto &amp;g = ci; // g是一个整型常量引用，绑定到ci auto &amp;h = 42; //错误：不能为非常量引用绑定字面值 const auto &amp;j = 42; //正确：可以为常量引用绑定字面值 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#271-auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#271-auto类型说明符"
  },"234": {
    "doc": "限定符与说明符",
    "title": "2.72 decltype类型说明符",
    "content": "有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。 此时可以用decltype类型说明符，它的作用是返回非声明或定义形式的表达式(右值)的操作数的数据类型 . decltype类型说明符的括号内只能放表达式，不能含有类型名，也不能含有auto，像``decltype(auto)是不行的。 . decltype类型的声明形式为： . (可含类型修饰符)decltype(表达式) 变量名 (可选 初始化) . decltype(f()) sum = x; // sum的类型就是函数f的返回类型。 . 当decltype的括号内是一个单一变量时，则decltype返回该变量的类型(包括顶层const和引用在内)： . const int ci = 0, &amp;cj = 1; // x的类型是const int decltype(ci) x = 0; // y的类型是const int&amp;, y绑定到变量x decltype(cj) y = x; // 错误：z是一个引用，必须初始化 decltype(cj) z; . 如果decltype的括号内是一个复杂表达式，那么decltype返回该表达式结果会有一些不同： . | 当==表达式==的结果==是右值==时==decltype返回==该表达式结果==对应的类型==。 | 如果==是左值==时，decltype返回该表达式结果==对应的类型的引用==。 | . // decltype的结果可以是引用类型 int i = 42, *p = &amp;i, &amp;r = i; decltype (r + 0) b; //正确：加法的结果是int，因此b是一个(未初始化的)int decltype (*p) c; //错误：c是int&amp;,必须初始化 . 当decltype的括号内是一个变量名加上了一对(或多对)括号时，该表达式的结果也是左值，所以decltype就会返回该变量类型的引用类型。 . // decltype的表达式如果是加上了括号的变量，结果将是引用 // 错误：d1，d2是int&amp;,必须初始化 decltype((i)) d1; decltype(((i))) d2; decltype(i) e; //正确：e是一个(未初始化的)int。 . 当类型修饰符与decltype类型说明符一起用时，这些类型修饰符都会视为修饰decltype所返回的类型。 . int ins = 15; int *p = &amp;ins; int &amp;lr = ins; // 等价于const int var1 const decltype(ins) var1; // 等价于int *const &amp;var2 const decltype(p) &amp;var2; // 因为引用不是对象，引用本身不能为const\\ 所以等价于int &amp;var3 const decltype(lr) var3; // 等价于const int &amp;var4 const decltype(ins) &amp;var4; . 因为函数是一种特殊的函数对象，也可以用在decltype中，且可以使用只声明未定义的函数(因为decltype说明符只会获取其数据类型) . #include &lt;iostream&gt; // 只声明未定义的函数 int prints(int); // 相同函数原型的定义函数 int getVal(int val) { return val*2; } int main() { // 正确：使用函数prints来定义func对象的变量类型 // decltype(prints)*等价于为int (*)(int) decltype(prints)* func = getVal; // 输出46 std::cout &lt;&lt; func(23) &lt;&lt; std::endl; return 0; } . 虽然引用类类型中的非静态数据成员需要与特定对象相对应，但是由于decltype只获取对象的类型，所以其也可以用于类类型中的非静态数据成员。和静态数据成员一样用作用域运算符来进行访问。 . #include &lt;iostream&gt; class Class { public: double dou_; }; int main() { // 正确：使用函数prints来定义dou_obj对象的变量类型 // decltype(Class::dou_)等价于为double decltype(Class::dou_) dou_obj = 3.1415; // 输出3.1415 std::cout &lt;&lt; dou_obj &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#272-decltype%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#272-decltype类型说明符"
  },"235": {
    "doc": "限定符与说明符",
    "title": "2.8 引用折叠",
    "content": "之前我们讲述过关于引用的各种规则。 . 尤其是以下这两个规则： . | 不能定义引用的引用。 | 左值非常量引用只能绑定到左值，而左值常量引用还能绑定到右值；右值引用只能绑定到右值。 | . 对于普通情况来说，这两个规则是适用的，但是，C++语言在该 绑定规则之外还定义了两个例外，这两种例外会允许某些特殊的绑定： . | 我们可以间接地定义一个引用的引用。 | 如果间接定义了一个引用的引用，则这些引用会进行折叠。 | . 以下是这两种例外的说明： . | 间接定义一个引用的引用有以下几种方法： . | 通过使用类型別名 | 通过使用类型自动推断 . | auto类型说明符 | decltype类型说明符 | 某些模板形参 | . | . | 引用折叠会将该对象的所有引用折叠成普通的引用，根据引用的类型，折叠情况分为两种(其中X代表类型说明符和其他的类型修饰符)： . | 以下这三种情况都会折叠成左值引用X&amp;： . | X&amp; &amp; | X&amp; &amp;&amp; | X&amp;&amp; &amp; | . | 以下这一种情况会折叠成右值引用X&amp;&amp;： . | X&amp;&amp; &amp;&amp; | . | . | . int ins = 15; typedef int&amp; int_r; using int_rr = int&amp;&amp;; // int_r_r等价于 // int&amp; &amp;，折叠成 // int&amp; typedef int_r&amp; int_r_r; // int_r_rr等价于 // int&amp; &amp;&amp;，折叠成 // int&amp; typedef int_r&amp;&amp; int_r_rr; // int_rr_r等价于 // int&amp;&amp; &amp;，折叠成 // int&amp; using int_rr_r = int_rr&amp;; // int_rr_rr等价于 // int&amp;&amp; &amp;&amp;，折叠成 // int&amp;&amp; using int_rr_rr = int_rr&amp;&amp;; // 等价于int &amp;var int_r_r var = ins; // 等价于int &amp;var1 int_r_rr var1 = ins; // 等价于int &amp;var2 int_rr_r var2 = ins; // 等价于int &amp;&amp;var3 int_rr_rr var3 = 15; . int ins = 15; int &amp;lr = ins; int &amp;&amp;rr = 15; // 等价于int&amp; &amp;&amp;var // 折叠成int&amp; var auto &amp;&amp;var = ins; // 等价于int&amp; &amp;var1 // 折叠成int&amp; var1 decltype(lr) &amp;var1 = ins; // 等价于int&amp; &amp;&amp;var2 // 折叠成int&amp; var2 decltype(lr) &amp;&amp;var2 = ins; // 等价于int&amp;&amp; &amp;var3 // 折叠成int&amp; var3 decltype(rr) &amp;var3 = ins; // 等价于int&amp;&amp; &amp;&amp;var4 // 折叠成int&amp;&amp; var4 decltype(rr) &amp;&amp;var4 = 15; . template &lt;class ty&gt; void prints(ty&amp;&amp; val) {} int ins = 15; // val的类型等价于int&amp; &amp;&amp; // 折叠成int&amp; prints(ins); . 这个规则能够得出一个重要的结论，也就是我们能够使用间接方式来使右值类型变量接受任意的左右值属性对象。 . // 该模板接受左值和右值，并把它们的类型和左右值属性原封不动再返回。 template &lt;class ty&gt; ty res(ty&amp;&amp; val) { return val; } int ins = 15; // 正确，ty类型为int&amp; int &amp;rin = res(ins); // 错误，ty类型为int&amp; int &amp;&amp;rrin = res(ins); // 正确，ty类型为int int &amp;&amp;rrin2 = res(15); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#28-%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html#28-引用折叠"
  },"236": {
    "doc": "限定符与说明符",
    "title": "限定符与说明符",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html",
    
    "relUrl": "/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html"
  },"237": {
    "doc": "第三章 表达式",
    "title": "第三章 表达式",
    "content": "第3章先介绍了表达式和左右值的概念，然后详细介绍各种表达式的运算符。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/index.html",
    
    "relUrl": "/guide_files/chap3/index.html"
  },"238": {
    "doc": "表达式概念详解",
    "title": "3.1 表达式有关的一些基础概念",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#31-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#31-表达式有关的一些基础概念"
  },"239": {
    "doc": "表达式概念详解",
    "title": "3.11 运算符和运算对象",
    "content": "运算符就是作用于某些对象，并根据作用对象来产生一个新的值或对象的标点符号。运算符的作用对象也叫做运算对象。 . 运算符有几元之称，几元指的是该运算符有几个运算对象： . | 一元运算符（unary operator） | 二元运算符（binary operator） | 三元运算符 | 多元运算符 | . 作用一个运算对象的运算符是一元运算符，如取地址符&amp;和解引用符*。 作用于两个运算对象的运算符是二元运算符，如相等运算符=和乘法运算符*。 除此之外，还有一个作用于三个运算对象的三元运算符? :。 函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。 . 一些符号既能作为一元运算符也能作为二元运算符。以符号*为例，作为一元运算符时执行解引用操作，作为二元运算符时执行乘法作。一个符号到底是一元运算符还是二元运算符由它的上下文决定。对于这类符号来说，它的两种用法互不相干，完全可以当成两个不同的符号。 . 当使用一个运算符时，提供的运算对象的数目必须要和其规定的几元数目一样，否则会出错。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#311-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#311-运算符和运算对象"
  },"240": {
    "doc": "表达式概念详解",
    "title": "3.12 表达式",
    "content": "表达式由一个或多个运算对象（operand）组成，对表达式求值通常将得到一个结果（result）。 . 表达式本身也可以作为运算对象。 . 字面值和变量是最简单的表达式（expression），其结果就是字面值和变量的值。 . 含有两个或多个运算符的表达式及其运算对象的表达式被称为复合表达式（compound expression） . 只要是没有包含分号的式子，都是表达式而不是语句。 比如包含多个逗号分隔开的表达式的复杂表达式，函数调用也是表达式，单一变量名也是表达式。 . int i, j, k; vector&lt;int&gt; v1{2,5,8,9,36,2,3,5}; // 以下都为表达式而不是语句 i = 250, j = i * 30, k = i + j - 15, int vsize = v1.size(), vhead = v1.front(), . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#312-%E8%A1%A8%E8%BE%BE%E5%BC%8F",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#312-表达式"
  },"241": {
    "doc": "表达式概念详解",
    "title": "3.13 组合运算",
    "content": "对于含有多个运算符的复杂表达式来说，它们的运算规则会按照每个运算符的特性来运行。 对于每个运算符，都有各自的属性，该属性分为三种： . | 运算符的优先级(precedence) | 运算符的结合律(associativity) | 运算对象的求值顺序(order of evaluation) | . 例如，下面这条表达式的求值结果依赖于表达式中运算符和运算对象的组合方式： . 5 + 10 * 20/2; // 乘法运算符（*）是一个二元运算符，\\ 它的运算对象有4种可能：\\ 10和20、10和20/2、 15和20、15和20/2。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#313-%E7%BB%84%E5%90%88%E8%BF%90%E7%AE%97",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#313-组合运算"
  },"242": {
    "doc": "表达式概念详解",
    "title": "3.14 运算对象转换和重载运算符",
    "content": "在表达式求值的过程中，运算对象常常由一种类型转换成另外一种类型。例如，尽管一般的二元运算符都要求两个运算对象的类型相同，但是很多吋候即使运算对象的类型不相同也没有关系，只要它们能被转换成同一种类型即可。 . C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为己存在的运算符赋予了另外一层含义，所以称之为重载运算符(overloaded operator)。 . 我们使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的：但是==运算对象的个数、运算符的优先级和结合律都是无法改变的==。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#314-%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E5%92%8C%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#314-运算对象转换和重载运算符"
  },"243": {
    "doc": "表达式概念详解",
    "title": "3.15 左值和右值",
    "content": "C++中的所有表达式要不然是右值（rvalue,读作“are-value”），要不然就是左值（lvalue,读作“ell-value”）。 . c++中的表达式左右值的区别是根据表达式求值结果的属性来决定的。 当一个表达式的求值结果只能被当作值使用时，该表达式就是右值；当一个表达式的求值结果不仅能被当作值使用，还能当做对象使用时，该表达式就是左值。 . 所以可以在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。 . 不管是左值还是右值，它们都是一个占有某空间的对象。所以对于所有左值和右值，它们都能像正常对象一样进行某些操作，比如所有类类型的左值或右值都能通过成员访问符访问其可访问的正常成员。 . 一般来说，左值和右值是以下几种表达式： . | 左值 . | 变量 | . | 右值 . | 临时对象 . | 要求转换的表达式 | 返回右值的表达式 | . | 字面值常量 | . | . 临时对象就是编译器在执行运算对象转换、拷贝或赋值时临时开辟的一个对象，此临时对象会在完成对应操作后自动销毁。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#315-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#315-左值和右值"
  },"244": {
    "doc": "表达式概念详解",
    "title": "3.16 运算符的优先级和结合律",
    "content": "求复合表达式的值需要首先将运算符和运算对象合理地组合在一起。优先级与结合律(结合顺序)决定了运算对象组合的方式。也就是说，它们决定了表达式中每个运算符对应的运算对象来自表达式的哪一部分。 . 运算对象组合方式为： . | 运算对象优先与优先级高的运算符结合 | 如果某运算对象左右的运算符优先级相同，则按照运算符的结合律来决定先与谁结合。 | . //这条表达式中的括号符合默认的优先级和结合律\\ ((6 + ( (3 * 4) / 2) ) + 2) 6 + 3*4/2; . 圆括号无视普通的组合规则，表达式中用圆括号括起来的部分被单独当成一个表达式来求值，然后再与其他部分一起按照组合方式来计算，程序员可以使用圆括号将表达式的某个局部括起来使其得到优先运算。 . 对于有多个圆括号以及嵌套圆括号的表达式，程序从左到右先计算最里面的圆括号的式子，再算外层的。 . //不同的括号组合导致不同的组合结果 cout « (6+3) * (4/2+2) « endl; cout « ((6 + 3) * 4) / 2 + 2 &lt;&lt; endl; cout &lt;&lt;6+3*4/ (2+2) « endl; //输出36 //输出20 //输出9 . 以下是c++各种运算符的优先级与结合律： . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#316-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E5%BE%8B",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#316-运算符的优先级和结合律"
  },"245": {
    "doc": "表达式概念详解",
    "title": "3.17 求值顺序",
    "content": "运算符还有一个重要的属性就是运算对象的求值顺序。 . 运算对象的求值顺序是指在一条表达式中，所有需要在运行时才能知道值的对象要按照对应运算符的运算对象求值顺序来逐个获取其值，对于没有规定求值顺序的运算符，则获取值的先后是未定义的。 . 运算对象的求值顺序与优先级和结合律无关，一条表达式中并不会出现优先级高的运算符的运算对象先求值，或者按结合律从左往右求值的。 运算对象的求值是在表达式进行组合运算之前进行的，对表达式中规定求值顺序的运算符先按照其求值顺序对其运算对象求值，再对其他运算符任意求值。 . 比如，在一条形如f()+g()*h()4-j()的表达式中，对于这些函数的调用顺序没有明确规定。 . /* 我们知道fl和f2一 定会在执行乘法之前被 调用，因为毕竟相乘的 是这两个函数的返回 值。但是我们无法知道 到底fl在f2之前调用 还是f2在fl之前调用 */ int i = fl () * f2 (); . /* 因为求值顺序是未定义 的，所以我们无法推断它的行为。编译器可能 先求++i的值再求i的值，此时输出结果是1 1; 也可能先求i的值再求的值，输出结果是0 1; 甚至编译器还可能做完全不同的操作。 */ int i = 0; std::cout &lt;&lt; \"before: \" &lt;&lt; i &lt;&lt; \", after: \" &lt;&lt; ++i « endl; // 未定义的 . c++的所有运算符中，有四种运算符明确规定了运算对象的求值顺序，后面的内容会详细介绍着四种运算符的求值顺序。 . | 逻辑与&amp;&amp;运算符 | 逻辑或||运算符 | 条件?:运算符 | 逗号,运算符 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#317-%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#317-求值顺序"
  },"246": {
    "doc": "表达式概念详解",
    "title": "3.2 运算符介绍",
    "content": "因为某些运算符可以重载，所以以下介绍的运算符的各种规则主要只适用于大部分系统自带的类型，如算术类型等。 . 对于某些类类型来说，因为重载了运算符，其规则可能会有一些变化，如标准库中的string类型支持其赋值运算符的左侧对象为右值。 . #include &lt;string&gt; std::string s1 = \"s1\", s2 = \"s2\"; // 向右值赋值。 s1 + s2 = \"combination\"; std::string() = \"temp_str\"; . c++的运算符有很多，接下来介绍的是几个常用的运算符： . | 算术运算符 | 逻辑运算符 | 关系运算符 | 赋值运算符 . | 复合赋值运算符 | . | 递增和递减运算符 | 成员访问运算符 | 条件运算符 | 位运算符 | 逗号运算符 | sizeof运算符 | . 在无明确指出的情况下，默认所有运算符与其运算对象之间可以有0个到多个空白符；两个运算对象之间可以有1个到多个空白符。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#32-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#32-运算符介绍"
  },"247": {
    "doc": "表达式概念详解",
    "title": "3.21 算术运算符",
    "content": ". 算术运算符大多数为二元运算符，运算对象在左右侧；一元正负号运算符的运算对象在右侧。 运算对象都为右值，运算结果为右值 . 除非另做特殊说明，算术运算符都能作用于任意算术类型以及任意能转换为算术类型的类型。 . 一元正号运算符、加法运算符和减法运算符都能作用于指针。 . 求余运算符%只能作用于整型。 除法运算符/右侧不能为0。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#321-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#321-算术运算符"
  },"248": {
    "doc": "表达式概念详解",
    "title": "3.22 逻辑和关系运算符",
    "content": ". 逻辑和关系运算符大多数为二元运算符，运算对象在左右侧；一元逻辑非运算符的运算对象在右侧。 运算对象都为右值，运算结果为右值 . 关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。 . 逻辑运算符和关系运算符的==返回值都是布尔类型==。值为0的运算对象(算术类型或指针类型)表示假，否则表示真。 . 逻辑与运算符和逻辑或运算符 . 对于逻辑与运算符&amp;&amp;来说，当且仅当两个运算对象都为真时结果为真；对于逻辑或运算符||来说，只要两个运算对象中的一个为真结果就为真。 . 逻辑与运算符和逻辑或运算符的求值顺序为： 逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为短路求值(short-circuit evaluation)： . | 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。 | 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。 | . 逻辑非运算符!将运算对象的真值取反后返回。 . 关系运算符比较运算对象的大小关系并返回布尔值。关系运算符都满足左结合律。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#322-%E9%80%BB%E8%BE%91%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#322-逻辑和关系运算符"
  },"249": {
    "doc": "表达式概念详解",
    "title": "3.23 赋值运算符",
    "content": "赋值运算符为二元运算符，运算对象在左右侧。 左侧运算对象为左值，右侧运算对象为右值。运算结果为左值。 . 赋值运算符的左侧运算对象必须是一个可修改的左值。 . int i = 0, j = 0, k. = 0; const int ci = i; //初始化而非賦值 //初始化而非賦值 1024 = k; //错误：字面值是右值 i + j = k； //错误：算术表达式是右值 ci = k; //错误：ci是常量（不可修改的） . 赋值运算的结果是它的左侧运算对象，并且是一个左值。如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型： . k = 0; //结果：类型是int,值是0 k = 3.14159; //结果：类型是int,值3 . 对于赋值运算符的左侧运算对象为某些类类型时，由于类类型可能重载了一些运算符，所以导致该赋值运算符可以为右值，此时的求值结果仍为左值，如： . // 合法操作 string a = \"str_a\", b = \"str_b\"; string *p = &amp;(a + b = \"str_c\"); . C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。 . 如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且该值即使转换的话其所占空间也不应该大于目标类型的空间；对于类类型来说，赋值运算的细节由类本身决定。 . 无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量并将其赋给左侧运算对象。 . k = {3.14}; //错误：窄化转换 vector&lt;int&gt; vi; // 初始为空 vi = {0,1,2,3,4,5,6,7,8,9}; // vi 现在含有 10 个元素了，值从 0 到 9 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#323-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#323-赋值运算符"
  },"250": {
    "doc": "表达式概念详解",
    "title": "3.231 复合赋值运算符",
    "content": "我们经常需要对对象施以某种运算，然后把计算的结果再赋给该对象。为了方便运算，所以就有了复合赋值形式。 一些算术运算符和位运算符有其相应的复合赋值形式： . | 算术运算符 . | += | -= | *= | /= | %= | . | 位运算符 . | &lt;&lt;= | &gt;&gt;= | &amp;= | ^= | |= | . | . 任意一种复合运算符都完全等价于： . a = a op b; . op为复合赋值运算符，a为该复合赋值运算符的左侧对象，b为该复合赋值运算符的右侧对象。 . 唯一的区别是左侧运算对象的求值次数： . | 使用复合运算符只求值一次。 | 使用普通的运算符则求值两次。这两次包括：一次是作为右边子表达式的一部分求值，另一次是作为赋值运算的左侧运算对象求值。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#3231-%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#3231-复合赋值运算符"
  },"251": {
    "doc": "表达式概念详解",
    "title": "3.24 递增和递减运算符",
    "content": "递增和递减运算符为一元运算符，前置版本的运算对象在右侧，后置版本的在左侧。 运算对象都为左值。前置版本的运算结果为左值，后置版本的为右值。 . 递增运算符(++)和递减运算符(–)为对象的加1和减1操作提供了一种简洁的书写形式。 . 这两个运算符还可应用于迭代器，因为很多迭代器本身不支持算术运算，所以此时递增和递减运算符除了书写简洁外还是必须的。 . 递增和递减运算符有两种形式： . | 前置版本 | 后置版本 | . 前置版本的运算符首先将运算对象加1(或减1)，然后将改变后的对象作为求值结果。 后置版本的也会将运算对象加1(或减1)，但是求值结果是运算对象改变之前那个值的副本(右值)。 . int i = 0, j; j = ++i； // j = 1, i = 1:前置版本得到递增之后的值 j = i++; // j = 1, i = 2:后置版本得到递增之前的值 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#324-%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#324-递增和递减运算符"
  },"252": {
    "doc": "表达式概念详解",
    "title": "3.25 成员访问运算符",
    "content": "成员访问运算符都为二元运算符，运算对象在左右侧。 运算对象都为右值。箭头运算符的运算结果为左值；点运算符右侧的对象为左值，则运算结果为左值，否则为右值。 . 点运算符.和箭头运算符-&gt;都可用于访问成员，都是用来获取类对象的一个成员的。 其中，点运算符作用于类对象；而箭头运算符只能作用于指针(该指针指向一个类对象)。 它们的使用形式为： . 类对象.成员名 指针-&gt;成员名 . 第二种形式等价于 . (*指针).成员名 . string si = \"a string\", *p = &amp;sl; auto n = si.size(); // 运行 string 对象 si 的 size 成员 n = (*p).size () ; //运行p所指对象的size成员 n = p-&gt;size () ; // 等价于(*p) . size () . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#325-%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#325-成员访问运算符"
  },"253": {
    "doc": "表达式概念详解",
    "title": "3.26 条件运算符",
    "content": "条件运算符都为三元运算符，运算对象在左中右侧。 运算对象都为右值。当中间和右侧的运算对象都为左值或者能转化成同一个左值类型时，运算结果为左值，否则为右值。 . 条件运算符?:允许我们把简单的if-else逻辑嵌入到单个表达式当中。 使用形式为： . cond ? expr1 : expr2 . exprl 和 expr2 都不能省略，缺一不可 . 其中cond是判断条件的表达式，而exprl和expr2是两个类型相同或可能转换为某个公共类型的表达式。 . 条件运算符的求值顺序为： 首先求cond的值，如果条件为真则对exprl求值并返回该值，否则对expr2求值并返回该值。 . 举个例子，我们可以使用条件运算符判断成 绩是否合格： . // 条件部分判断成绩是否小于60。\\ 如果小于，表达式的结果是”fail”，否则结果是\"pass\" string finalgrade = (grade &lt; 60) ? \"fail\" : \"pass\"; . 条件运算符支持嵌套 . /* 第一个条件检查成绩是否在90分以上， 如果是，执行符号？后面的表达式，得到”high pass”； 如果否，执行符号：后面的分支。 这个分支本身又是一个条件表达式，它检查成绩是否在60分以下， 如果是，得到\"fail\"；否则得到\"pass\" */ finalgrade = (grade &gt; 90) ? \"high pass1' :(grade &lt; 60) ? \"fail\" : \"pass\"; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#326-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#326-条件运算符"
  },"254": {
    "doc": "表达式概念详解",
    "title": "3.27 位运算符",
    "content": ". | 运算符名称 | 几元运算符 | 运算对象左右值 | 运算结果左右值 | . | IO类左移(«) | 二元 | 左侧左值，右侧右值 | 左值 | . | IO类右移(») | 二元 | 都为左值 | 左值 | . | 内置类左移(«) | 二元 | 都为右值 | 右值 | . | 内置类右移(») | 二元 | 都为右值 | 右值 | . | 位求反(~) | 一元 | 右侧右值 | 右值 | . | 位与(&amp;) | 二元 | 都为右值 | 右值 | . | 位或(|) | 二元 | 都为右值 | 右值 | . | 位异或(^) | 二元 | 都为右值 | 右值 | . 位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。 位运算符提供检查和设置二进制位的功能。 . 位运算符能用于bitset类型。 . 运算对象会进行整数提升，提升时运算对象原来的位保持不变，往髙位(high order position)添加0即可。 . 运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算符如何处理运算对象的“符号位”依赖于机器。而且，此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。 . 强烈建议仅将位运算符用于处理无符号类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#327-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#327-位运算符"
  },"255": {
    "doc": "表达式概念详解",
    "title": "3.271 左移右移运算符",
    "content": "左移右移这两种运算符的内置含义是对其运算对象执行基于二进制位的移动操作，首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。 . 其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。二进制位或者向左移&lt;&lt;或者向右移&gt;&gt;，移出边界之外的位就被舍弃掉了。 . 左移运算符&lt;&lt;会在右侧插入值为0的二进制位。 而右移运算符&gt;&gt;的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，则会在左侧插入值为0的二进制位; 如果该运算对象是带符号类型，则在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#3271-%E5%B7%A6%E7%A7%BB%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#3271-左移右移运算符"
  },"256": {
    "doc": "表达式概念详解",
    "title": "3.272 位求反运算符",
    "content": "位求反运算符~将运算对象逐位求反后生成一个新值，将1置为0、将0置为1。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#3272-%E4%BD%8D%E6%B1%82%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#3272-位求反运算符"
  },"257": {
    "doc": "表达式概念详解",
    "title": "3.273 位与、位或、位异或运算符",
    "content": "位与&amp;、位或|、位异或^运算符在两个运算对象上逐位执行相应的逻辑操作: . 位与、位或、位异或运算符都满足交换，结合和分配律。 . 对于位与运算符&amp;来说，如果两个运算对象的对应位置都是1，则运算结果中该位为1，否则为0。 . 对于位或运算符|来说，如果两个运算对象的对应位置至少有一个为1，则运算结果中该位为1，否则为0。 . 对于位异或运算符^来说，如果两个运算对象的对应位置有且只有一个为1，则运算结果中该位为1，否则为0。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#3273-%E4%BD%8D%E4%B8%8E%E4%BD%8D%E6%88%96%E4%BD%8D%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#3273-位与位或位异或运算符"
  },"258": {
    "doc": "表达式概念详解",
    "title": "3.28 sizeof运算符",
    "content": "sizeof运算符为一元运算符，运算对象在右侧。 运算对象为右值。运算结果为右值。 . sizeof运算符返回一条表达式或一个类型名所占的字节数。 sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。 sizeof运算符的使用形式为： . sizeof (type) sizeof expr . 第一种形式中，类型名一定要在圆括号内。 . 在第二种形式中，sizeof返回的是==表达式结果类型==的大小。sizeof并不实际计算其运算对象的值。 . sizeof运算符不能作用于函数对象、函数指针和引用。 sizeof运算符也不能作用于不完整类型。 . Sales_data data, *p;sizeof (Sales_data); //存储Sales_data类型的对象所占的空间大小 sizeof data; //data 的类型的大小，即sizeof (Sales_data) sizeof P; // 指针所占的空间大小 sizeof *P; // P所指类型的空间大小，即sizeof (Sales_data) sizeof data. revenue; // Sales_data的revenue成员对应类型的大小 sizeof Sales_data::revenue; //另一种获取revenue大小的 . C++11新标准允许我们使用作用域运算符来获取类成员(可访问的成员才行)的大小。 通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须我们提供一个具体的对象，因为要想知道类成员的大小无须真的获取该成员。 . 对一些特殊类型的对象执行sizeof运算会有一些不同： . | 对char或者类型为char的表达式执行sizeof运算，结果为1。 | 对引用类型执行sizeof运算得到被引用对象所占空间的大小。 | 对指针执行sizeof运算得到指针本身所占空间的大小。 | 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。 | 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。 | 对类类型或类类型对象执行sizeof运算时，所占的字节大小为： . | 该类类型==所有非静态数据成员==的字节大小的总和，如果该类型==有虚函数==(不管有多少个)，则==在该总和的基础上加8字节==。 | 如果该类类型没有非静态数据成员和虚函数，则其所占的字节大小为1。 | . | 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。 | 对union类型或union类型对象执行sizeof运算时，所占的字节大小为其==非静态数据成员中类型尺寸最大的成员所占的字节==；如果该类型没有非静态数据成员，则其所占的字节大小为1。 | 对枚举类型或枚举类型对象执行sizeof运算时，所占的字节大小为该枚举类型的枚举成员类型的字节大小。 | . // sizeof (ia) /sizeof (*ia)返回 ia 的元素数量 constexpr size_t sz = sizeof(ia)/sizeof(*ia); int arr2[sz]; //正确：sizeof返回一个常量表达式。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#328-sizeof%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#328-sizeof运算符"
  },"259": {
    "doc": "表达式概念详解",
    "title": "3.29 逗号运算符",
    "content": "逗号运算符为二元运算符，运算对象在左右侧。 运算对象都为右值。右侧运算对象为左值时，运算结果为左值，否则为右值。 . 逗号运算符的运算对象求值顺序是按照从左向右的顺序依次求值的。 . 对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#329-%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#329-逗号运算符"
  },"260": {
    "doc": "表达式概念详解",
    "title": "表达式概念详解",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",
    
    "relUrl": "/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"
  },"261": {
    "doc": "第四章 语句",
    "title": "第四章 语句",
    "content": "第4章介绍了语句的概念以及各种控制语句的用法。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/index.html",
    
    "relUrl": "/guide_files/chap4/index.html"
  },"262": {
    "doc": "语句概念详解",
    "title": "4.1 概念介绍",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#41-%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#41-概念介绍"
  },"263": {
    "doc": "语句概念详解",
    "title": "4.11 语句分类介绍",
    "content": "一条语句是指由0个或多个C++的关键字和表达式组成的，末尾是分号;的符号序列。 一条非复合简单语句末尾必须包含分号;。 . ival + 5； // 一条没什么实际用处的表达式语句 cout &lt;&lt; ival； // 一条有用的表达式语句 . c++所有的非预编译指令代码必须要以语句的形式存在，不能存在只有关键字或者表达式的序列，必须要将其变成语句形式才行，否则编译出错。 . 语句分为三种： . | 空语句 | 简单语句 | 复合语句 | . 一条简单语句有且只有一个分号，该分号必须在末尾。(在字符或字符串的中分号不算)。 . 一条简单语句可以跨多行，只要末尾为分号就行。 同样，多个语句(空，简单，复合)也可以在同一行。 . 空语句和简单语句都是末尾为分号的字符序列。 而空语句是指只有一个分号而不含其它符号的语句。 . ; //合法，空语句。 . 空语句可以用于所有能够存在语句的地方。 . 复合语句(compound statement)是指用花括号{}括起来的==0个或多个语句==序列，复合语句也被称作块(block)。 . 一个块就是一个作用域，块内定义的变量的作用域为局部作用域。 . 复合语句只能在函数中单独使用，其他情况下不能单独使用。 . 复合语句可以为空，也就是只有一对花括号而不含其它符号，与空语句等价。 要注意复合语句不以分号结束。 . 复合语句可以嵌套，要注意每个复合语句的作用域。 . 语句之间可以有0个或者多个空白符分隔 . {} //合法，空复合语句。 {其他代码}; // 这里是两个语句\\ 一个复合语句\\ 一个空语句。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#411-%E8%AF%AD%E5%8F%A5%E5%88%86%E7%B1%BB%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#411-语句分类介绍"
  },"264": {
    "doc": "语句概念详解",
    "title": "4.11 控制语句概念介绍",
    "content": "在c++中，默认情况下，语句是按顺序执行的。 也就是编译器会按照从上到下的，从左到右，一个一个==语句==的执行(一个语句为复合语句时，也是按照这个顺序执行该语句里的各个语句)。所以先执行的语句里的变量可以用于之后的语句。 . // 合法：按照顺序执行，最后输出28。 int in1 = 28; int in2 = in1; cout &lt;&lt; in2; . 但除非是最简单的程序，否则仅有顺序执行是远远不够。因此，C++语言提供了一组控制流(flow-of-control)语句以支持更复杂的执行路径。 . c++的所有控制语句只能在函数中单独使用，其他情况下不能单独使用。 . c++的控制语句有以下几种： . | 条件语句 . | if语句 | switch语句 | . | 循环语句 . | while语句 | do while语句 | for语句 . | 传统for语句 | 范围for语句 | . | . | 跳转语句 . | break | continue | goto | return | . | 异常处理语句 | . 这一章不讲return和异常处理语句，之后会详细介绍这两种语句 . 控制语句是可以改变某些语句执行的顺序的特殊语句，它们都是以其对应的关键字开头，之后跟着一个或多个语句，其中可能有一个圆括号包围的多个语句或表达式(也就是某些控制语句里的条件部分)。 . 所有含条件部分的控制语句里的条件部分可以是变量或者表达式，但条件部分不能为空。 . 除了switch语句，其他语句里的条件部分只要该变量或者表达式的运算结果能隐式转换为布尔类型就行，而switch语句是要能显式转换成整型类型。 . 除了do while语句，其他含条件部分的控制语句里的条件部分中可以定义变量。 条件部分进行变量定义时不能含有存储类说明符。 . 所有控制语句中每个后面能跟语句的控制关键字之后只能有一条语句。 但是，如果没有明确说明的情况，默认所有后面能跟语句的控制关键字之后可以是一条复合语句。 . | 控制语句中不带条件部分的关键字和之后跟的语句之间可以有1个或多个空白符。 | 控制语句中的关键字和其条件部分之间可以有0个或多个空白符。 | 控制语句的条件部分和之后跟的语句之间可以有0个或多个空白符。 | . int i = 0; // 错误：if之后只能有一条语句\\ cout &lt;&lt; \"good2\\n\";语句不是if语句中的。 if (i == 1) cout &lt;&lt; \"good\\n\"; cout &lt;&lt; \"good2\\n\"; // 正确：if之后是一条复合语句，\\ 复合语句中包含两个语句。 if (i == 1) { cout &lt;&lt; \"good\\n\"; cout &lt;&lt; \"good2\\n\"; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#411-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#411-控制语句概念介绍"
  },"265": {
    "doc": "语句概念详解",
    "title": "4.111 控制语句的作用域",
    "content": "以下这两种变量的作用域范围是从其定义的位置一直到该控制语句的最后一个语句的末尾。 . | 在控制语句内的非复合语句中定义的变量。 | 在控制语句的条件部分定义的变量。 | . 控制语句内的复合语句中定义的变量的作用域在包含其定义位置的最小块中才可见(也就是包含它的最小的复合语句中才可见)。 . if (int ju = 1) int ins = 55; // 错误：变量ju和ins只在if语句中可见 cout &lt;&lt; ju &lt;&lt; \" \" &lt;&lt; ins; if (int judge = 1) { // 正确：变量judge可见。 cout &lt;&lt; judge &lt;&lt; endl; int nest = 15; { int nest2 = 35; // 正确：变量nest可见。 cout &lt;&lt; nest &lt;&lt; endl; } // 错误：变量nest2不可见。 cout &lt;&lt; nest2 &lt;&lt; endl; } else { // 正确：变量judge可见。 cout &lt;&lt; judge &lt;&lt; endl; // 错误：变量nest和nest2都不可见。 cout &lt;&lt; nest &lt;&lt; \" \" &lt;&lt; nest &lt;&lt; endl; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4111-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4111-控制语句的作用域"
  },"266": {
    "doc": "语句概念详解",
    "title": "4.2 条件语句",
    "content": "C++语言提供了两种按条件执行的语句： . | if语句 | switch语句 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#42-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#42-条件语句"
  },"267": {
    "doc": "语句概念详解",
    "title": "4.21 if语句",
    "content": "if语句(if statement)的作用是： 判断一个指定的条件是否为真，根据判断结果决定是否执行另外一条语句。 . if语句包括两种形式，一种含有else分支，另外一种没有。 if语句的语法形式是： . if (条件表达式) 语句 . if else语句的语法形式是： . if (条件表达式) 语句 else 语句 . 在这两个版本的if语句中，每个关键字之后的语句可以是一条复合语句。 . 这两个版本的if语句的条件表达式都必须用圆括号包围起来。条件表达式可以是一个普通的表达式，也可以是定义表达式。不管是什么，其类型都必须能隐式转换成布尔类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#421-if%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#421-if语句"
  },"268": {
    "doc": "语句概念详解",
    "title": "4.211 if语句的执行过程",
    "content": "如果条件表达式为真： 则执行条件表达式后面的语句。当语句执行完成后，程序继续执行if语句后面的其他语句。 . 如果条件表达式为假： 则跳过条件表达式后面的语句。然后执行if语句匹配的else子句中的语句，如果没有该if语句没有匹配的else子句，则程序继续执行if语句后面的其他语句。 . if语句是可以包含其else子句的特殊语句。所以其else子句也是整个if语句中的一部分。 . 一个if语句最多只能有一个else子句。 . if语句可以嵌套，所以要注意else子句的匹配问题，这也叫做悬垂else(dangling else)。 c++规定：==else子句与离它最近的尚末匹配的if语句匹配==。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4211-if%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4211-if语句的执行过程"
  },"269": {
    "doc": "语句概念详解",
    "title": "4.22 switch语句",
    "content": "switch语句的使用形式为： . switch (条件表达式) 语句 . switch的条件表达式是一个表达式，且其值必须是整型类型，或者能显式转换成整型类型。 . 条件表达式后面的语句大部分是一个复合语句，该复合语句内可能含有多个case标签。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#422-switch%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#422-switch语句"
  },"270": {
    "doc": "语句概念详解",
    "title": "4.221 switch语句的执行过程",
    "content": "switch语句首先对条件部分求值，然后与其后面语句中的每个case标签的值比较。 . | 如果条件表达式的值和某个case标签的值相等(比较时可能会执行隐式转换)，则程序从该标签之后的第一条语句开始执行，直到到达了switch的结尾或者是遇到一条break语句为止。然后程序继续执行switch语句后面的其他语句。 | 如果没有任何case标签的值等于条件表达式的值且不存在default标签或者该语句中不存在任何case标签，那么程序跳转到switch语句后面的其他语句继续执行。 | . //为每个元音字母初始化其计数值 unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0； char ch； while (cin &gt;&gt; ch) { //如果ch是元音字母，将其对应的计数值加1 switch (ch) { case 'a': ++aCnt; break; case 'e': ++eCnt; break; case 'i': ++iCnt; break; case 'o': ++oCnt; break; case 'u': ++uCnt; break; } } //输出结果 cout « \"Number of vowel a: \\t\" « aCnt « ,\\n. « \"Number of vowel e: \\t\" « eCnt « r\\nr « \"Number of vowel i :\\t\" « iCnt « r \\nr « \"Number of vowel o: \\t\" « oCnt « r \\nf « \"Number of vowel u: \\t\" « uCnt « endl . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4221-switch%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4221-switch语句的执行过程"
  },"271": {
    "doc": "语句概念详解",
    "title": "4.222 switch语句中的标签",
    "content": "case标签和default标签都只能用在switch语句中，不能用于其他语句。 . 不管是什么类型的标签，每个标签都有以下的规则： 标签后面必须紧跟一个冒号（:），然后在冒号之后必须紧跟一条语句(可以是复合语句)或者一个标签(该标签也要遵循这个规则)。 . 形式为: . 标签 : 语句/标签 . 标签与冒号，冒号与语句之间可以有0个或多个空白符。 . case标签 . case标签(case label)是指case关键字和它对应的值这个整体，它对应的值叫做case标签值，这两个部分缺一不可。 形式为： . case 整型常量表达式 . case标签值必须是整型常量表达式，或者是能被显式转换成整型常量表达式。且任何两个case标签的值不能相同，否则就会引发错误。 . char ch = getVal()； int ival = 42； switch(ch) { case 3.14: //错误：case标签不是一个整数 case ival: //错误：case标签不是一个常量 //... default标签 . default标签是只有关键字default的标签，形式为： . default . default标签(default label)也遵循标签的规则。 default标签的作用是在switch语句中，如果没有任何一个case标签能匹配上switch表达式的值或者语句中没有case标签，则程序将执行紧跟在default标签后面的语句。 . default标签可以出现在语句中的任何位置，并不会影响switch的正常判断。 . 每个switch语句中最多只能出现一次default标签。 . //如果ch是一个元音字母，将相应的计数值加1 // 如果ch不是元音字母，\\ 就从default标签开始执行并把otherCnt加1. otherCnt 力卩 lo switch (ch) { default: ++otherCnt； break； case 'a':case 'e':case 'i':case 'o':case 'u': ++vowelCnt； break； } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4222-switch%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4222-switch语句中的标签"
  },"272": {
    "doc": "语句概念详解",
    "title": "4.223 switch语句中的变量定义",
    "content": "因为switch的执行流程有可能会跨过某些case标签。如果程序跳转到了某个特定的case，则switch语句中该case标签之前的部分会被忽略掉。 . 比如，如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为。 . 因此C++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。 . 也就是说当switch语句的条件部分后面跟的语句中含有两个及以上的case和default标签时，不允许在该语句内存在变量定义的简单语句(可以存在被默认初始化的基本类型变量的定义)，所以定义变量要在内嵌的复合语句内定义。 . 允许存在变量声明的简单语句。 . case true: //因为程序的执行流程\\ 可能绕开下面的初始化语句，\\ 所以该switch语句不合法 string file_name; //错误：控制流绕过一个隐式初始化的变量 int ival = 0; // 错误：控制流绕过一个显式初始化的变量 int jval; //正确：因为jval没有初始化 break; case false: //正确：jval虽然在作用域内，但是它没有被初始化 jval = next_num(); // 正确：给 jval 賦一个值 if (file_name.empty()) //file_name在作用域内，但是没有被初初始化 //... ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4223-switch%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4223-switch语句中的变量定义"
  },"273": {
    "doc": "语句概念详解",
    "title": "4.3 循环语句",
    "content": "循环语句通常称为迭代，它重复执行给定的操作直到满足某个条件才停下来。 . C++语言提供了三种循环执行的语句： . | while语句 | do while语句 | for语句 . | 传统for语句 | 范围for语句 | . | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#43-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#43-循环语句"
  },"274": {
    "doc": "语句概念详解",
    "title": "4.31 while语句",
    "content": "while语句的使用形式为： . while (条件表达式) 语句 . 在while结构中，只要其条件表达式的求值结果为真，就一直重复执行后面紧跟的语句，直到结果为假。 如果条件表达式的求值结果为假，则不再执行后面紧跟的语句。程序从while语句后的语句继续执行。 . vector&lt;int&gt; v； int i； //重复读入数据，直至到达文件末尾或者遇到其他输入问题 while (cin &gt;&gt; i) v.push_back(i)； //寻找第一冬负值元素 auto beg = v.beginO ； while (beg != v.end() &amp;&amp; *beg &gt;= 0) ++beg； if (beg == v.end()) //此时我们知道v中的所有元素都大于等于0 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#431-while%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#431-while语句"
  },"275": {
    "doc": "语句概念详解",
    "title": "4.32 do while语句",
    "content": "do while语句的使用形式为： . do 语句 while (条件表达式) ; . 和while结构的执行过程类似，不过是在求其条件表达式的结果前==先执行语句==，为真则重复执行，为假就不再执行，然后程序从do while语句后的语句继续执行。 . do while语句的条件表达式中不能定义变量，且该表达式使用的变量不能是do while语句中定义的变量。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#432-do-while%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#432-do-while语句"
  },"276": {
    "doc": "语句概念详解",
    "title": "4.33 for语句",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#433-for%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#433-for语句"
  },"277": {
    "doc": "语句概念详解",
    "title": "4.331 传统for语句",
    "content": "for语句的语法形式是： . for (初始化表达式; 条件表达式; 表达式) 语句 . 关键字for及括号里的部分称作for语句头。 . for语句头中的定义的所有变量的作用域和其他控制语句一样，一直到for语句的末尾为止，但是初始化表达式中声明或定义的变量就像定义在for语句外的变量，一直存在，直到for语句终止为止。 . 所以for语句等价于 . {初始化表达式语句 while (条件表达式) {语句 表达式;}} . for语句头中的初始化表达式可以是空，该初始化表达式可以是各种声明表达式(可以有存储类说明符)和普通表达式。 . for语句头中的条件表达式可以是空，和其他控制语句的条件表达式一样，可以定义变量，只要能隐式转化为布尔类型就行。条件表达式如果为空时，等价于条件为真。 . for语句头中最右边的那个表达式不能是声明或定义表达式，且该表达式可以为空。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4331-%E4%BC%A0%E7%BB%9Ffor%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4331-传统for语句"
  },"278": {
    "doc": "语句概念详解",
    "title": "4.3311 传统for语句的执行流程",
    "content": "循环开始时，首先执行一次初始化表达式，之后的循环不再执行初始化表达式。 . 接下来执行条件表达式并求出条件表达式的值： 如果为真，则执行语句头后面的语句，当语句头后面的语句执行完毕后，再执行语句头最右边的表达式，然后进行下一轮循环。 如果为假，则程序从for语句之后的语句继续执行。 . //重复处理s中的字符直至我们处理完全部字符或者遇到了一个表示空白的字符 for (decltype(s.size()) index = 0; index != s.size() &amp;&amp; !isspace(s[index]); ++index) s[index] = toupper (s[index]); //将当前字符改成大写 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#43311-%E4%BC%A0%E7%BB%9Ffor%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#43311-传统for语句的执行流程"
  },"279": {
    "doc": "语句概念详解",
    "title": "4.332 范围for语句",
    "content": "C++11新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。 . 范围for语句(range for statement)的语法形式是： . for (声明表达式 : 序列表达式) 语句 . 序列表达式表示的必须是一个确定元素数量的序列，比如数组或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。 所以可以用花括号括起来的初始值列表，只要其列表能转换成拥有迭代器的类型。 . 声明表达式中只能且必须声明一个变量，且不能用存储类说明符。该变量的类型必须是序列中的每个元素都得能隐式转换成该变量的类型。 . 因为范围for语句是用每个元素来初始化声明的局部变量的，所以我们需要修改或节省空间时，可以在声明表达式中声明引用类型来达到目的。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4332-%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#4332-范围for语句"
  },"280": {
    "doc": "语句概念详解",
    "title": "4.3321 范围for语句的执行流程",
    "content": "范围for语句的迭代刚开始时，首先会执行声明表达式，并将序列中的第一个元素来初始化刚声明的变量，接着执行for语句头后面的语句，执行完毕后在进行下一轮迭代，此时还是会先执行声明表达式，并将序列中的下一个元素来初始化该变量，然后就和之前的一样，一直迭代，直到遍历完序列中的所有元素。 遍历完序列中的所有元素后，程序从for语句之后的语句继续执行。 . 要注意不要在进行迭代的序列中增删元素，否则会出错。 . vector&lt;int&gt; v = {0,1,2,3,4,5,6,7,8,9}; //范围变量必须是引用类型，这样才能对元素执行写操作 for (auto &amp;r : v) //对于v中的每一个元素 r *= 2 ； //将v中每个元素的值翻倍 // 上面范围for语句的定义与下面传统for语句的定义等价 for (auto beg = v.begin(), end = v.end()； beg != end； ++beg) { auto &amp;r = *beg； // r必须是引用类型，这样才能对元素执行写操作 r *= 2； //将v中每个元素的值翻 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#43321-%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#43321-范围for语句的执行流程"
  },"281": {
    "doc": "语句概念详解",
    "title": "4.4 跳转语句",
    "content": "跳转语句主要的功能是中断当前的执行过程。 C++语言提供了四种跳转语句： . | 跳转语句 . | break | continue | goto | return | . | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#44-%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#44-跳转语句"
  },"282": {
    "doc": "语句概念详解",
    "title": "4.41 break语句",
    "content": "break语句(break statement)负责终止离它最近的且未结束的while、do while、for和switch语句，并从这些语句之后的第一条语句开始继续执行。 使用形式为： . break; . break语句中不能有除了关键字break和末尾分号的其他符号。 所以，break语句只能出现在循环语句或者switch语句内部(包括嵌套在此类循环里的语句或块的内部)。 . break语句的作用范围仅限于最近的循环或者switch。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#441-break%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#441-break语句"
  },"283": {
    "doc": "语句概念详解",
    "title": "4.42 continue语句",
    "content": "continue语句(continue statement)终止最近的循环语句中的当前迭代并立即开始下一次迭代。 使用形式为： . continue; . continue语句中不能有除了关键字continue和末尾分号的其他符号。 continue语句只能出现在for、while和do while循环的内部，或者嵌套在此类循环里的语句或块的内部。 . 和break语句类似的是，出现在嵌套循环中的continue语句也仅作用于离它最近的循环，但continue语句不能作用于switch语句。 . 要注意，对于传统的for循环来说，continue语句之后还是会继续执行for语句头最右边的表达式。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#442-continue%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#442-continue语句"
  },"284": {
    "doc": "语句概念详解",
    "title": "4.43 goto语句",
    "content": "goto语句(goto statement)的作用是从goto语句无条件跳转到同一函数内的另一条语句并从该语句开始执行。 . goto语句的语法形式是： . goto 标签; . goto语句中不能有除了关键字goto、标签和末尾分号的其他符号。 其中，该标签是用于标识一条语句的标识符，该标签不能是case和default标签。 . 带标签语句(labeled statement)是一种特殊的语句，在它之前有一个标识符以及一个冒号。 定义带标签语句的形式为： . 标签标识符 : 语句/其他标签标识符 . 标签标识符独立于变量或其他标识符的名字，因此，标签标识符可以和程序中其他实体的标识符使用同一个名字而不会相互干扰。但标签之间不能重名。 . 每个标签都有以下的规则： 标签后面必须紧跟一个冒号（:），然后在冒号之后必须紧跟一条语句(可以是复合语句)或者一个标签(该标签也要遵循这个规则)。 . 形式为: . 标签标识符 : 语句/其他标签标识符 . 标签与冒号，冒号与语句之间可以有0个或多个空白符。 . goto语句指向的带标签的语句必须要位于同一个函数之内。 . goto语句和switch语句类似，goto语句也不能将程序的控制权从变量的作用域之外转移到作用域之内(也就是跳过某变量的定义而直接使用)，但可以从变量的作用域之内转移到作用域之外。 . // ... goto end; int ix = 10; //错误：goto语句绕过了一个带初始化的变量定义 end： //错误：此处的代码需要使用ix,但是goto语句绕过了它的声明 ix = 42; //向后跳过一个带初始化的变量定义是合法的 begin：int sz = get_size(); if (sz &lt;= 0) {goto begin} . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#443-goto%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html#443-goto语句"
  },"285": {
    "doc": "语句概念详解",
    "title": "语句概念详解",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html",
    
    "relUrl": "/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html"
  },"286": {
    "doc": "第五章 函数",
    "title": "第五章 函数",
    "content": "第5章先介绍了函数的概念和用法，然后详细介绍了函数的重载，最后介绍了各种可调用对象以其用法。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/index.html",
    
    "relUrl": "/guide_files/chap5/index.html"
  },"287": {
    "doc": "函数概念详解",
    "title": "5.1 函数基本概念介绍",
    "content": "函数(function)是C++中派生类型中的一种，它是指一个有名字的代码块(复合语句)，我们可以通过调用该函数来执行相应的代码，所以函数是可调用对象中的一种。一个函数有0个或多个参数，而且通常会产生一个结果。函数可以重载，也就是说同一个名字可以对应几个不同的函数。 . 函数不是变量，它是一种特殊的对象，不能被初始化和赋值。 不同函数对象的函数首部是独一无二的。一个函数对象的类型是由它的返回类型和形参表所决定的。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#51-%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#51-函数基本概念介绍"
  },"288": {
    "doc": "函数概念详解",
    "title": "5.11 函数的结构",
    "content": "一个函数定义通常包括以下几个部分： . | 返回类型(return type) | 函数名字 | 形参表 | 函数体 | . 以下是函数各部分的简介： . | 返回类型是指该函数调用后所返回的结果类型。 | 函数名字是一个函数的标识符，调用函数必须明确该函数的名字。 在同一作用域中，函数名字能够和非可调用对象的对象名或者类型名重名 . | 形参表是指由0个或多个形参(parameter)组成的列表，每个形参都是由该形参类型与其形参名组成，形参之间要用逗号分隔。该列表必须是由圆括号括起的。 | 函数体是一个复合语句，函数中的具体代码都写在里面。 | . 函数的函数体中不能定义函数或函数模板，但是可以声明函数。 函数体中既可以声明，也可以定义类类型和类模板。 . 函数的返回类型和形参类型不能为auto和函数类型；除此之外，函数的返回类型还不能是数组类型(但可以是数组指针类型)。 . 形参是指函数在形参表里所声明的非静态局部变量，所有形参的作用域是从该形参声明表达式开始到所属函数的声明或定义的末尾。 所以一个函数的形参与其函数体的作用域中的局部变量之间，函数的形参与形参之间都不能重名。 形参的作用是能够在调用函数时向该函数传递数据。 . 形参名是可选的，但是由于我们无法使用未命名的形参，所以函数的形参一般都应该有个名字。 . 返回类型和形参类型都可以包含各种类型修饰符，如const等，但是都不能包含存储类说明符。 但是函数本身可以用存储类说明符来指定储存类型，比如static void prints() {}指的是一个文件内函数，文件外无法被引用。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#511-%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%93%E6%9E%84",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#511-函数的结构"
  },"289": {
    "doc": "函数概念详解",
    "title": "5.12 函数的声明",
    "content": "函数声明也称作函数原型（function prototype）。和其他名字一样，函数的名字也必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。 . 函数的声明无须函数体(有函数体就是定义了)，因为不含函数体，所以函数形参名不必与定义中相同，甚至还可以不用写形参名。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#512-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#512-函数的声明"
  },"290": {
    "doc": "函数概念详解",
    "title": "5.121 函数声明形式",
    "content": "以下是函数的声明： . | 返回类型 函数名字 形参表; | auto 函数名字 形参表 -&gt; 返回类型; | . 这两种声明形式都一样，只不过第二种形式是在C++11新标准中新增的，叫做用尾置返回类型(trailing return type)。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5121-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5121-函数声明形式"
  },"291": {
    "doc": "函数概念详解",
    "title": "5.122 尾置返回类型",
    "content": "尾置返回类型和普通返回类型的最大区别也就是: 尾置返回类型在形参声明之后，所以可以用函数形参来自动推断该函数的返回类型；而普通返回类型是在形参声明之前，所以就不能这样做。 . // 普通返回类型 // 错误：形参val和val2还未声明 decltype(val + val2) prints(double val, int val2); // 尾置返回类型 // 正确：形参val和val2在返回类型之前已声明 auto prints(double val, int val2) -&gt; decltype(val + val2); . 在尾置返回类型中，对于存储说明符和除了指针、引用、数组和const类型限定符的其他类型限定符(如constexpr，virtual等)，这些符号必须要放在auto之前，否则出错。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5122-%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5122-尾置返回类型"
  },"292": {
    "doc": "函数概念详解",
    "title": "5.123 函数首部",
    "content": "返回类型、函数名字和形参表共同形成了一个部分，叫做函数首部。 所以一个函数声明也就是声明了一个函数首部。一个函数首部说明了调用该函数所需的全部信息，不同的函数的函数首部都是独一无二的。 . 注意：函数首部的==形参不能用constexpr进行修饰==，constexpr只能用于函数或者非形参或静态数据成员变量的声明与定义。 . 要注意函数的声明要与其定义一致，就是函数首部要一致(包括函数声明或定义前的类型限定符也要一致)： . | 函数名要相同。 | 返回类型(可以忽略顶层const)要相同。 | 形参表中的形参数量，顺序和类型(可以忽略顶层const)都要相同。 | . 否则就变成了其他的函数的声明，无意义了。 . const int ret(const int val); // 错误定义：不是同一个函数 int ret(int val) { return val;}; // 正确定义 const int ret(const int val) { return val;}; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5123-%E5%87%BD%E6%95%B0%E9%A6%96%E9%83%A8",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5123-函数首部"
  },"293": {
    "doc": "函数概念详解",
    "title": "5.13 函数的定义",
    "content": "函数的定义和函数声明类似，只不过需要写上函数体。 . 函数不能在函数中定义，但是可以在函数中声明。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#513-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#513-函数的定义"
  },"294": {
    "doc": "函数概念详解",
    "title": "5.131 函数定义形式",
    "content": "函数的定义形式和声明形式一样，分两种： . | 返回类型 函数名字 形参表 函数体 | auto 函数名字 形参表 -&gt; 返回类型 函数体 | . // val 的阶乘是 val* (val - 1) * (val - 2) ..* ( (val - (val - 1) ) * 1) int fact(int val) { int ret = 1； //局部变量，用于保存计算结果 while (val &gt; 1) ret *= val--; //把ret和val的乘积賦给ret,然后将val减1 return ret； //返回结果 } . 函数的声明和定义中，函数形参表与函数名字、函数体和箭头符(-&gt;)之间可以有0个或多个空白符分隔。 函数的声明和定义中，返回类型与函数体之间可以有0个或多个空白符分隔。 函数形参表中每个形参与逗号或者圆括号之间可以有0个或多个空白符分隔。 . 不管是函数的声明还是定义，函数的形参列表可以为空，但是不能省略，也就是必须要有一对圆括号，空形参列表的声明形式为： . | 返回类型 函数名字 (); | 返回类型 函数名字 (void); | . 第二种形式是C语言形式，C++也继承了。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5131-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5131-函数定义形式"
  },"295": {
    "doc": "函数概念详解",
    "title": "5.132 已删除函数",
    "content": "所有函数都有一种特殊的定义形式，可以将其定义为删除的函数，这种形式就是在函数声明的后面加上赋值符=和关键字delete： . 函数的声明 = delete; . 当一个函数被定义成已删除时，是不能调用该函数的，否则会编译错误。 . 要注意已删除函数是已经定义的函数，所以不能为已删除函数再定义了，否则会重复定义。 . // 定义了一个已删除函数 void prints() = delete; // 错误：不能重复定义 void prints() { cout &lt;&lt; \"print\\n\"; } // 错误：不能调用已删除函数。 prints(); . 以上述形式定义的已删除函数会参与到函数重载中，因此函数重载时需要考虑这些已删除函数。 . // 定义了一个已删除函数，该函数将会参与prints的重载 void prints(int) = delete; // 定义了prints的重载函数 void prints(double dou) { cout &lt;&lt; dou &lt;&lt; \"\\n\"; } // 正确，输出25.78 prints(25.78); // 错误：不能调用已删除函数。 prints(3); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5132-%E5%B7%B2%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5132-已删除函数"
  },"296": {
    "doc": "函数概念详解",
    "title": "5.14 函数的使用",
    "content": "我们可以通过调用运算符(call operator)来执行函数。形式为： . 函数名 (实参表) . 调用运算符()内是实参(argument)列表(实参表最外边不能有圆括号)，实参是我们用来初始化函数形参的对象(包括临时对象)，实参可以是任何非声明或定义表达式。 . 调用运算符和函数、其他表达式之间可以有0个或多个空白符分隔。 函数实参表中每个实参与逗号或者圆括号之间可以有0个或多个空白符分隔。 函数形参表中每个形参与逗号或者圆括号之间可以有0个或多个空白符分隔。 . 调用函数时，该函数一般会返回一个对象(包括临时对象)，该对象的类型就是此函数的返回类型。 . int main() { int j = fact (5) ; // j 等于 120，即 fact (5)的结果 cout « \"5! is \" « j « endl; return 0; } . 实参可以是函数调用。 如果想传一个实参但是又不想先建立对应类型的对象，可以在实参表里隐式或者显式调用(用圆括号或者花括号加参数调用)对应类型的构造函数来创建一个临时对象来进行传递。 . 实参的数目通常要与其调用函数的形参数目一致，而且每个实参的位置要与形参的位置一致。也就是第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。 . 实参的类型必须与对应的形参类型一样或者能隐式转换成对应形参的类型。 . 尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序。 . fact(\"hello\"); //错误：实参类型不正确 fact(); //错误：实参数量不足 fact(42, 10, 0); //错误：实参数量过多 fact(3.14); //正确：该实参能转换成int . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#514-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#514-函数的使用"
  },"297": {
    "doc": "函数概念详解",
    "title": "5.15 函数调用的执行过程",
    "content": ". | 用实参初始化函数对应的形参。 | 将控制权转移给被调用函数。此时，主调函数(calling function)的执行被暂时中断，被调函数(called function)开始执行。 | 被调函数执行的第一步是（隐式地）定义并初始化它的形参。 | 然后执行被调函数函数体中的代码，直到遇到return语句或者到达函数体末尾。 | 当遇到一条return语句或者到达函数体末尾时，函数结束执行过程，并将控制权从被调函数转移回主调函数，继续执行调用点以及调用点之后的代码。 | 如果是遇到return语句才结束的，那么还会返回return语句中的值（如果有的话），该返回值用于初始化调用表达式的结果。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#515-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#515-函数调用的执行过程"
  },"298": {
    "doc": "函数概念详解",
    "title": "5.2 函数分类",
    "content": "函数按照作用分，可分为： . | 普通函数 | 递归函数 | 内联函数 . | constexpr函数 | . | . 内联函数、constexpr函数和普通函数一样都可以只声明不定义，只要不用就行。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#52-%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#52-函数分类"
  },"299": {
    "doc": "函数概念详解",
    "title": "5.21 递归函数",
    "content": "如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数(recursive function)。 . //计算val的阶乘，即1*2*3...* val /* 我们递归地调用factorial函数 以求得从val中减去1后 新数字的阶乘。 当val递减到1时，递归终止，返回1。 */ int factorial(int val) { if (val &gt; 1) return factorial(val-1) * val; return 1; } . 当某递归函数运行时，每次都递归调用却没有终止条件时，这种函数就被说明其含有递归循环(recursion loop)。 . 所以当定义一条正常的递归函数时，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去。换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#521-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#521-递归函数"
  },"300": {
    "doc": "函数概念详解",
    "title": "5.22 内联函数",
    "content": "函数调用的执行过程中，每次调用一个函数，都是要在内存空间上开辟一个临时空间(栈区)来存放该函数的数据，调用结束后释放其临时空间。所以函数调用一般比求等价表达式的值要慢一些。 . 所以当我们定义一个简单的函数时，为了节省程序运行时间和空间，可以将其指定为内联函数(inline)。 内联函数的定义形式为： . inline 函数定义 . 内联函数是指将函数在它在每个调用点上“内联地”展开： . inline const string SshorterString(const string &amp;s1, const string &amp;s2) {return s1.size() &lt;= s2.size() ? s1 : s2} // 在编译过程中展开成类似于下面的形式:\\ cout &lt;&lt; (s1.size() &lt;= s2.size() ? s1 : s2) &lt;&lt; endl; cout &lt;&lt; shorterString (s1, s2) &lt;&lt; endl; . 内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。而且不要定义内联递归函数，很多编译器都不支持内联递归函数。 . 同一文件的同一个函数的声明和定义语句中是否含有关键字inline可以不一致，==以函数的定义语句为主==。 . 内联函数因为其性质，所以可以在将要链接的各个不同文件中都定义其函数（不能在同一个文件定义多个首部相同或不满足重载的内联函数，会出现重定义错误）。 . 调用该内联函数的调用点所使用的函数，是调用点对应文件里的该函数的定义版本，如果调用点对应文件里只有该函数的声明而没有定义，则会出错。 所以对于内联函数来说，要在每个文件中都有其定义。 . 同一个内联函数在不同文件的定义应保持一致，尤其是函数首部一致，防止定义成了其他的内联函数，无意义了。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#522-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#522-内联函数"
  },"301": {
    "doc": "函数概念详解",
    "title": "5.23 constexpr函数",
    "content": "constexpr函数之前也谈过，是指能用于初始化或赋值常量表达式的函数。 . 定义constexpr函数的形式与其他函数一样，不过要遵循以下约定： . | 函数的返回类型及所有形参的类型都得是字面值类型(所以该函数的返回类型不能为void)。 | 函数体中必须有且只能有一条return语句。 | . 定义形式为： . constexpr 函数定义 . constexpr int new_sz() { return 42; } constexpr int foo = new_sz (); // 正确：foo 是一个常量表达式 . 编译器一般是把对constexpr函数的调用转换成其结果值。 为了能在编译过程中随时展开，==constexpr函数被隐式地指定为内联函数==，所以和内联函数一样，要在多个不同文件中都定义其函数。 . 同一文件的同一个constexpr函数的声明和定义语句都必须含有关键字constexpr，否则会编译出错。 . constexpr函数体内也可以包含其他语句，不过必须为以下几种： . | 空语句、空复合语句和只含有空语句的复合语句。 | 类型别名定义。 | 命名空间别名定义以及命名空间相关的using操作等。 | . constexpr函数的返回值可以不是一个常量表达式，当constexpr函数的所有实参都是常量表达式时，且它的return语句里的表达式也是常量表达式时，该函数的返回值才是常量表达式，否则返回值就不是常量表达式。 . int no_c1 = 88; // 非constexpr函数 int get_no_c(int num) {return num;} constexpr int get_cstex1(int num1, int num2) { return num1; } // return语句总为非常量表达式的constexpr函数get_cstex2 constexpr int get_cstex2(int num1, int num2) { return no_c1; } // 定义两个非常量表达式。 int nc_num1 = 5; const int cc1 = get_no_c(5); // 错误：nc_num1为非常量表达式，所以返回的不是常量表达式。 constexpr int cst_num1 = get_cstex1(5, nc_num1); // 错误：return语句的表达式为非常量表达式，所以返回的不是常量表达式。 constexpr int cst_num2 = get_cstex2(5, 6); // 错误：cc1是常量，但不是常量表达式，所以返回的不是常量表达式。 constexpr int cst_num3 = get_cstex1(cc1, 6); // 正确：cst_num4初始化为5。 constexpr int cst_num4 = get_cstex1(5, 6); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#523-constexpr%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#523-constexpr函数"
  },"302": {
    "doc": "函数概念详解",
    "title": "5.3 函数参数详解",
    "content": "如前所述，每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。 . 形参初始化的机制与变量初始化一样。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53-函数参数详解"
  },"303": {
    "doc": "函数概念详解",
    "title": "5.31 参数传递分类",
    "content": "和其他变量一样，形参的类型决定了形参和实参交互的方式，一般来说，参数的传递可以分为两种： . | 值传递 | 引用传递 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#531-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%88%86%E7%B1%BB",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#531-参数传递分类"
  },"304": {
    "doc": "函数概念详解",
    "title": "5.311 值传递",
    "content": "当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递(passed by value)或者函数被传值调用(called by value)；也就是说，形参和实参的内存地址不一样，只是两个值一样。 . //该函数接受一个指针，然后将指针所指的值置为0 void reset(int *ip) { *ip = 0; //改变指针ip所指对象的值 ip = 0; //只改变了ip的局部拷贝，实参未被改。 } int i = 42; reset (&amp;i); //改变i的值而非i的地址 cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; // 输出 i = 0。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5311-%E5%80%BC%E4%BC%A0%E9%80%92",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5311-值传递"
  },"305": {
    "doc": "函数概念详解",
    "title": "5.312 引用传递",
    "content": "当形参是引用类型时，我们说它对应的实参被引用传递(passed by reference)或者函数被传引用调用(called by reference)。和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应的实参的别名(形参和实参的内存地址一样)。 . //该函数接受一个引用，然后将指针所指的值置为0 void reset(int &amp;i) { i = 0; //改变了 i所引对象的值 } int j = 42; reset (j); // j采用传引用方式，它的值被改变 cout &lt;&lt; \"j = \" &lt;&lt; j &lt;&lt; endl; // 输出 j = 0。 . 要改变所传的实参值、或者有些大的类类型对象以及容器对象在拷贝时比较低效，甚至有的类类型(比如IO类)根本就不支持拷贝操作。此时用引用传递是最好的。 . 如果函数无须改变引用形参的值，最好将其声明为常量引用。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5312-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5312-引用传递"
  },"306": {
    "doc": "函数概念详解",
    "title": "5.32 默认实参",
    "content": "当函数的某个形参经常会被用同一个值初始化，我们又不想每次调用都要自己传递这个常用值时，我们就可以对该形参设置默认实参。 所以默认实参的作用就像上面说的，简化调用操作。 . 默认实参作为形参的初始值，可以是任意非声明定义的表达式。 默认实参必须要出现在形参列表中。 我们可以为一个或多个形参定义默认实参(传值和传引用形参都能有)。 . 不过需要注意的是，一旦某个形参被赋予了默认实参，它后面的所有形参都必须有默认实参，也就是有默认实参的形参要放在形参表末尾。 . 默认实参不能是使用该默认实参的函数本身的调用，否则会出错。 但是可以是该函数名相同的函数的调用(也就是可以调用该函数的重载)，此时该默认实参是不会匹配到自己所属的那一个函数。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#532-%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#532-默认实参"
  },"307": {
    "doc": "函数概念详解",
    "title": "5.321 默认实参的形参表形式",
    "content": "有默认实参的形参表的形式为： . (形参类型1 形参名1 = 默认实参1, 形参类型2 形参名2 = 默认实参2, 形参类型3 形参名3 = 默认实参3, …) . typedef string::size_type sz; string screen(sz ht = 24, sz wid = 80, char backgrnd = ''); . 函数形参只能用拷贝初始化来设定默认实参(也就是必须要有赋值符=)，用不了直接初始化。 . 当形参为类类型时，如果想用此形参类型的默认构造函数来生成一个临时对象来当做该形参的默认实参，则应该在赋值符=后加空花括号来调用默认构造函数(注意不能用空圆括号)。 . 函数的==局部变量，包括其他形参都不能作为该函数的默认实参==，除此以外，只要表达式的类型能隐式转换成形参所需的类型，就能作为该形参的默认实参。 . 对于函数声明来说，和函数定义一样，默认实参可以用在函数声明中，在同一个的作用域中同一个函数的一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，此时该后续声明的默认实参可以不在形参表末尾。 . typedef string::size_type sz; string screen(sz ht, sz wid, char backgrnd); // 正确，表示高度和宽度的形参没有默认值 string screen(sz, sz, char = '' ); // 错误，我们不能修改一个已经存在的默认值 string screen(sz, sz, char = '' ); // 错误：重复声明。 // 正确，可以按照如下形式添加默认实参： string screen (sz = 24, sz = 80, char); // 正确：添加默认 . 和普通函数声明一样，有默认实参的函数声明也可以不用写形参名字。 . 每个调用点调用的函数的默认实参是按照当前调用点所有可见的该函数的声明和定义的默认实参的组合(包含其他文件中该函数的声明或定义)。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5321-%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82%E7%9A%84%E5%BD%A2%E5%8F%82%E8%A1%A8%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5321-默认实参的形参表形式"
  },"308": {
    "doc": "函数概念详解",
    "title": "5.322 含默认实参函数的使用",
    "content": "如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了，不使用时就按正常方式的调用写上实参就行。 . 我们只能省略有默认实参的形参的实参，没有默认实参的一律不能省略，否则出错。 . 函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参(靠右侧位置)。 . typedef string::size_type sz; string screen(sz ht = 24, sz wid = 80, char backgrnd = ''); string window; // 等价于 screen(24,80,'') window = screen(); // 等价于 screen(66, 80,'') window = screen (66); // screen(66,256,'') window = screen(66, 256); // screen(66,256,'#') window = screen(66, 256, '#'); //错误：只能省略尾部的实参 window = screen(, , '?'); window = screen('?'); // 调用 screen ('?', 80, '') . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5322-%E5%90%AB%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5322-含默认实参函数的使用"
  },"309": {
    "doc": "函数概念详解",
    "title": "5.33 可变形参的函数",
    "content": "有时我们无法提前预知应该向函数传递几个实参。 为了编写能处理不同数量实参的函数，一共有三种方法： . | 如果所有的实参类型相同，可以用一个名为initializer_list的标准库类型 | 如果实参的类型不同，我们可以 . | 用一种特殊的形参类型（即省略符），不过这种功能一般只用于与C函数交互的接口程序。 | 用可变参数模板来进行传递 | . | . 可变参数模板将在之后的模板一章中介绍。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#533-%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#533-可变形参的函数"
  },"310": {
    "doc": "函数概念详解",
    "title": "5.331 initializer_list形参",
    "content": "如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。 initializer_list类型定义在同名的头文件中，它是一种标准库类型，用于表示某种特定类型的值的数组。 . initializer_list类型是类模板类型，initializer_list类型的对象中的元素是const类型，所以无法被赋值。 . 一个函数的形参表可以有多个initializer_list形参，在含有initializer_list形参的函数也可以同时拥有其他形参。 initializer_list形参可以放在形参表的任何位置，也能有默认实参。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5331-initializer_list%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5331-initializer_list形参"
  },"311": {
    "doc": "函数概念详解",
    "title": "5.3311 initializer_list形参的形参表形式",
    "content": "有initializer_list形参的形参表的形式示例： . (initializer_list 形参1, 形参类型2 形参2, initializer_list 形参3, ···) . void error_msg(initializer_list&lt;string&gt; il, string ex_msg) { for (auto beg = il.begin(); beg != il.end(); ++beg) cout &lt;&lt; *beg &lt;&lt; \" \"; cout &lt;&lt; \"\\n\" &lt;&lt; ex_msg &lt;&lt; endl; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53311-initializer_list%E5%BD%A2%E5%8F%82%E7%9A%84%E5%BD%A2%E5%8F%82%E8%A1%A8%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53311-initializer_list形参的形参表形式"
  },"312": {
    "doc": "函数概念详解",
    "title": "5.3312 含initializer_list形参的使用",
    "content": "当要传递实参到initializer_list形参时，该实参必须是由==花括号括起来的0个或多个值的序列==，这些值的类型要与initializer_list形参的基本类型一致或者能隐式转换成该基本类型。 . void error_msg(initializer_list&lt;string&gt; il, string ex_msg) { for (auto beg = il.begin(); beg != il.end(); ++beg) cout &lt;&lt; *beg &lt;&lt; \" \"; cout &lt;&lt; \"\\n\" &lt;&lt; ex_msg &lt;&lt; endl; } // 错误：没有花括号，实参不匹配 error_msg(\"error\",\"function\", \"undefined\", \"line_58\"); // 正确：输出： // error function undefined // line_58 error_msg({\"error\",\"function\", \"undefined\"}, \"line_58\"); . initializer_list形参对应的实参可以为空，但是必须要有花括号。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53312-%E5%90%ABinitializer_list%E5%BD%A2%E5%8F%82%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53312-含initializer_list形参的使用"
  },"313": {
    "doc": "函数概念详解",
    "title": "5.332 省略符形参",
    "content": "省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。 . 省略符形参应该仅仅用于C和C++通用的类型，特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5332-%E7%9C%81%E7%95%A5%E7%AC%A6%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5332-省略符形参"
  },"314": {
    "doc": "函数概念详解",
    "title": "5.3321 省略符形参的形参表形式",
    "content": "省略符形参只能出现在形参列表的最后一个位置，且该位置的这一项只能有一个省略符...，不能含有形参类型与形参名。 . 有省略符形参的形参表的形式为： . (形参类型1 形参名1, 形参类型2 形参名2(可选,)…) . 省略符形参与前一个形参名之间的逗号,可有可不有，等价。 . /*以下都为正确的声明*/ void test(int, double, ...); void test(int, double ...); void test(int...); void test(...); . initializer_list形参可以和省略符形参一起使用，只要遵守各自的规则就行。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53321-%E7%9C%81%E7%95%A5%E7%AC%A6%E5%BD%A2%E5%8F%82%E7%9A%84%E5%BD%A2%E5%8F%82%E8%A1%A8%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53321-省略符形参的形参表形式"
  },"315": {
    "doc": "函数概念详解",
    "title": "5.3322 含省略符形参的使用",
    "content": "省略符形参接受0个或多个实参，当调用一个含有省略符形参的函数时，实参的数目必须要大于等于减去了省略符形参的形参数目。多余的实参都传递给了省略符形参，因为编译器不对省略符对应的实参进行类型检查，因此省略符对应的实参类型可以是任意不同类型的。 . 省略符符号不能当做函数的实参。 . void test(int, double, ...) {} void test2(...); int main() { char ins = 'g'; // 调用错误，实参数目不能小于减去了省略符形参的形参数目 test(2); // 调用错误， 省略符符号不能当做函数的实参 test(2, 3.55, ...); // 调用正确，省略符对应的实参类型可以是任意不同类型的 test(-8, 4.15, 6, &amp;ins, \"string\"); // 调用正确，省略符形参可以接受0个实参。 test2(); } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53322-%E5%90%AB%E7%9C%81%E7%95%A5%E7%AC%A6%E5%BD%A2%E5%8F%82%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53322-含省略符形参的使用"
  },"316": {
    "doc": "函数概念详解",
    "title": "5.34 特殊类型形参分析",
    "content": "函数形参的类型可以是各种类型，但是有几种类型比较特殊，接下来就来讲解这几种特殊类型的形参： . | const形参 | 数组形参 | 函数形参 | main函数形参 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#534-%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E5%BD%A2%E5%8F%82%E5%88%86%E6%9E%90",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#534-特殊类型形参分析"
  },"317": {
    "doc": "函数概念详解",
    "title": "5.341 const形参",
    "content": "当某个形参的类型为const时，它的初始化规则和普通的const变量一样： . (顶层const/非顶层const)实参能初始化(非顶层const/顶层const)形参；而底层const实参不能为非底层const形参初始化。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5341-const%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5341-const形参"
  },"318": {
    "doc": "函数概念详解",
    "title": "5.342 数组形参",
    "content": "对于数组形参，我们可以写成三种形式： . | 数组形式 | 数组指针形式 | 数组引用形式 | . 因为数组会被转换成指针，所以当我们为函数传递一个数组名时，实际上传递的是指向数组首元素的指针。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5342-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5342-数组形参"
  },"319": {
    "doc": "函数概念详解",
    "title": "5.3421 数组形式和数组指针形式形参",
    "content": "我们可以将形参写成以下几种的形式： . | 数组形式 类型说明符 (可选 类型修饰符) (可选 形参名) 维度 . | 指向数组首元素的指针形式 类型说明符 (可选 类型修饰符) (可选 形参名) * 或 类型说明符 (可选 类型修饰符) *(可选 形参名) 维度 . | . 数组形式中第一维度的大小可以省略，但是符号[]不能省略。 . 数组形式的形参可以像数组一样用下标运算符来访问该形参的元素；而数组指针形式的不行。 . 当我们用数组形式定义多维数组形参时，编译器会一如既往地忽略掉第一个维度，所以最好不要把它包括在形参列表内。 . //matrix的声明看起来\\ 是一个二维数组，实际上形参是指向含有10个整数的数组的指针。 void print(int matrix[][10], int rowSize) { /* ... */} . //尽管形式不同，但这三个print函数是等价的//每个函数都有一个const int*类型的形参 void print(const int*); void print(const int[]); //可以看出来，函数的意图是作用于一个数组 void print(const int[10]); //这里的维度表示我们期望数组含有多少元素，实际不一定。 . int i = 0, j[2] = {0, 1}; print(&amp;i); //正确：&amp;i的类型是int*。 print(j); //正确：j转换成int*并指向j[0]。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53421-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%BD%A2%E5%BC%8F%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53421-数组形式和数组指针形式形参"
  },"320": {
    "doc": "函数概念详解",
    "title": "5.3422 数组引用形式形参",
    "content": "C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上。 形式为: . 类型说明符 (可选 类型修饰符) (&amp;(可选 形参名)) 维度 . 符号[]不能省略。 维度的大小也不能省略，因为省略维度的类型无法匹配到其他任何数组（因为其他的数组都有维度，维度不一样匹配不了）。 . //错误：虽然能编译通过，但是arr不能接收数组，因为没指定维度的大小 void print2(int (&amp;arr)[]) { for (auto elem : arr) cout &lt;&lt; elem &lt;&lt; endl; } int k[10] = {0,1,2,3,4,5,6,7,8,9}; int k2[] = {0,1,2}; /** 错误：print2接受的变量类型为int (&amp;)[]，而k的类型则为int (&amp;)[10]，维度不一样不能匹配。 */ print2(k); /** 错误：print2接受的变量类型为int (&amp;)[]，而k2的类型则为int (&amp;)[3]，维度不一样不能匹配。 */ print2(k2); . 和数组形式的形参一样，数组引用形参也可以像数组一样用下标运算符来访问该形参的元素。 . 形参名两端的括号必不可少，否则就成了引用的数组了。 . //正确：形参是数组的引用，维度是类型的一部分 void print(int (&amp;arr)[10]) { for (auto elem : arr)cout &lt;&lt; elem &lt;&lt; endl; } //错误：虽然能编译通过，但是arr不能接收数组，因为没指定维度的大小 void print2(int (&amp;arr)[]) { for (auto elem : arr)cout &lt;&lt; elem &lt;&lt; endl; } int i = 0, j[2] = {0, 1}; int k[10] = {0,1,2,3,4,5,6,7,8,9}; print(&amp;i); //错误：实参不是含有10个整數的数组。 print(j); //错误：实参不是含有10个整数的数组。 print(k); //正确：实参是含有10个整数的。 /** 以下都错误：因为print2不能接受数组。 */ print2(&amp;i); print2(j); print2(k); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53422-%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%E5%BD%A2%E5%BC%8F%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#53422-数组引用形式形参"
  },"321": {
    "doc": "函数概念详解",
    "title": "5.343 函数形参",
    "content": "之前说过，函数形参不能为函数类型，但是可以是函数指针类型。 . 当我们把函数名作为一个值使用时，该函数名会自动地转换成指针，所以我们形参类型可以类似于函数。 . //第三个形参是函数类型，它会自动地转换成指向函数的指针 void useBigger(const string &amp;s1, const string &amp;s2,bool pf(const string, const string &amp;)); //等价的声明：显式地将形参定义成指向函数的指针 void useBigger(const string &amp;s1, const string &amp;s2,bool (*pf)(const string &amp;, const string &amp;)); //自动将函数lengthCompare转换成指向该函数的指针 useBigger(s1, s2, lengthCompare); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5343-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5343-函数形参"
  },"322": {
    "doc": "函数概念详解",
    "title": "5.344 main函数形参",
    "content": "main函数是c++里的主函数，每个程序必须要有这个程序，操作系统时通过调用该函数来运行程序的。 . main函数不能被其他函数或者是自己所调用。 . 一个程序中有且只有一个全局的main函数。 . 一般情况下main函数的形参表为空，但是有时我们确实需要给main传递实参。 . 所以main函数有两个可选的形参： . | 第一个形参必须是int型，表示的是第二个形参所表示的数组中元素的数量。 | 第二个形参必须是char (*)[]型或char **，表示的是一个元素都为指向字符串类型的指针的数组。 | . 所以main函数的定义形式为： . int main((可选 int 形参名1, char(*形参名2)[])) 函数体 . int main((可选 int 形参名1, char** 形参名2)) 函数体 . main函数形参表要么为空，要么有规定的这两个形参(缺一不可)，其他情况编译器一律警告。 . main函数形参可以有默认实参。 . 一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。 如在含有main函数的exe文件(prog.exe)的路径中向命令行输入\\prog -d -o ofile data0，就可以向文件(prog.exe)里的main函数传递所输入的参数了。 . 当实参传给main函数之后，第二个形参中的第一个元素是指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。 . // 向命令行输入 // \\prog -d -o ofile data0 int main(int argc, char *argv[]) { // 输出prog。或者也可以指向一个空字符串，为空。 cout &lt;&lt; argv[0]; // 输出-d cout &lt;&lt; argv[1]; // 输出-o cout &lt;&lt; argv[2]; // 输出ofile cout &lt;&lt; argv[3]; // 输出data0 cout &lt;&lt; argv[4]; // 输出0 cout &lt;&lt; argv[5]; return 0; } . 所以当使用argv中的实参时，一定要记得可选的实参从元素1开始，元素0保存程序的名字，而非用户输入。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5344-main%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5344-main函数形参"
  },"323": {
    "doc": "函数概念详解",
    "title": "5.4 函数返回过程详解",
    "content": "之前说过是指该函数调用后所返回的结果类型，所有函数都需要一个return语句来指定返回的值。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#54-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#54-函数返回过程详解"
  },"324": {
    "doc": "函数概念详解",
    "title": "5.41 return语句",
    "content": "return语句是专用于函数中的一种跳转语句。 return语句的作用是终止当前在执行的函数并将控制权返回到调用该函数的地方，有可能会返回一个值到调用点。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#541-return%E8%AF%AD%E5%8F%A5",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#541-return语句"
  },"325": {
    "doc": "函数概念详解",
    "title": "5.411 return语句的形式",
    "content": "return语句有两种形式： . return; return 表达式; . return语句的第一种形式只能用于返回类型为void的函数中，该形式不返回任何值。 . 但是返回类型为void的函数并不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return; 返回类型为void的函数也能使用第二种形式，不过此时return语句的表达式必须是返回void的函数的调用，否则出错。 . return语句的第二种形式可以用于所有返回类型不为void的函数中，该形式会返回所给的表达式的求值结果。 该求值结果要与其==对应函数的返回类型相同，或者能隐式地转换成对应函数的返回类型==，否则出错。 . return语句能出现在函数的任何位置，一个函数中的return语句数量没有限制，但所有的return语句都要符合上面的规则。 . 当非void函数的控制流有可能未返回任何值时就结束了运行，有些编译器会检测出来这种错误，并予以警告 . 除了constexpr函数，其他所有函数的函数体中都可以没有return语句，编译器会在函数结束时自动返回一个对应类型的未定义对象。 所以对于返回类型为非void的函数来说，如果没有return语句，编译器会警告。 . //因为含有不正确的返回值，所以这段代码无法通过编译 bool str_subrange(const string &amp;strl, const string &amp;str2) { //大小相同：此时用普通的相等性判断结果作为返回值 if (strl.size() == str2.size()) return strl == str2; //正确：==运算符返回布尔值 //得到较短string对象的大小 //检查两个string对象的对应字符是否相等，以较短的字符串长度为限 auto size = (strl.size() &lt; str2.size()) ? strl.size() : str2.size(); for (decltype(size) i = 0; i != size; ++i) { if (strl[i] != str2[i]) return; //错误#1:没有返回值，编译器将报告这一错误 //错误#2：控制流可能尚未返回任何值就结束了函数的执行 //编译器可能检查不出这一错 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5411-return%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5411-return语句的形式"
  },"326": {
    "doc": "函数概念详解",
    "title": "5.412 return语句的执行过程",
    "content": "当程序运行到一个return语句时，会算出该return语句后的结果并进行类型检查，无误后被调函数终止，并返回这个结果值。程序返回到调用点，此时调用函数的表达式的结果就是该结果值。 . 被调函数返回的结果会根据其函数的返回类型而不同，一般返回形式和参数传递一样，分为两种： . | 返回值 | 返回引用 | . 根据函数的返回形式，其返回过程分为以下两种： . | 返回值 . | 如果return语句的表达式的结果是一个临时对象或者是该函数自己定义的非静态局部变量，则将该对象直接返回到调用点(不再生成其他临时对象)，作为函数调用的结果。 | 如果return语句的表达式的结果是既不是临时对象也不是该函数自己定义的非静态局部变量，则调用点生成一个临时的与被调函数的返回类型一样的对象，然后这个return语句的表达式结果用于初始化该临时对象，该临时对象就作为函数调用的结果。 | . | 返回引用 . | 直接将return语句的表达式结果返回(不管结果是局部变量、临时对象还是非局部变量等，都一律直接返回)到调用点(不再生成其他临时对象)，作为函数调用的结果。 | . | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5412-return%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5412-return语句的执行过程"
  },"327": {
    "doc": "函数概念详解",
    "title": "5.4121 返回值",
    "content": "函数的返回类型不是引用类型时，该函数的返回就是返回值，所以该函数调用的表达式的值为右值。 . 函数返回过程中，返回值的方式是在调用点生成一个临时的与被调函数的返回类型一样的==对象==。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#54121-%E8%BF%94%E5%9B%9E%E5%80%BC",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#54121-返回值"
  },"328": {
    "doc": "函数概念详解",
    "title": "5.4122 返回引用",
    "content": "当函数的返回类型是引用类型时，该函数的返回就是返回引用，所以该函数调用的表达式的值为左值。 . 函数返回过程中，返回引用的方式是在调用点生成一个临时的与被调函数的返回类型一样的==引用==。 . 当函数的返回类型为引用或指针时，return语句里的表达式的结果不能是非静态局部变量或者是非静态局部变量的地址。 因为函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着非静态局部变量不再存在。 . //严重错误：这个函数试图返回局部对象的引用 const string &amp;manip() { string ret; //以某种方式改变一下ret if (!ret.empty()) return ret; // 错误：返回局部对象的引用！ else return \"Empty\"; //错误：\"Empty\"是一个局部临时量 } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#54122-%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#54122-返回引用"
  },"329": {
    "doc": "函数概念详解",
    "title": "5.42 特殊返回类型分析",
    "content": "函数返回类型可以是各种类型，但是有几种类型比较特殊： . | 数组返回类型 | 函数返回类型 | main函数返回类型 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#542-%E7%89%B9%E6%AE%8A%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%88%86%E6%9E%90",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#542-特殊返回类型分析"
  },"330": {
    "doc": "函数概念详解",
    "title": "5.421 数组返回类型",
    "content": "之前说过，函数的返回类型不能为数组类型，但是可以为数组指针类型。 . 当数组作为函数的返回类型时，不会隐式转换成数组指针类型的，所以我们必须显式将返回类型指定为指针。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5421-%E6%95%B0%E7%BB%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5421-数组返回类型"
  },"331": {
    "doc": "函数概念详解",
    "title": "5.422 函数返回类型",
    "content": "之前说过，函数的返回类型不能为函数类型，但是可以为函数指针类型。 . 当函数作为函数的返回类型时，不会隐式转换成函数指针类型的，所以我们必须显式将返回类型指定为指针。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5422-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5422-函数返回类型"
  },"332": {
    "doc": "函数概念详解",
    "title": "5.423 main函数返回类型",
    "content": "main函数的返回类型必须为int。 . 虽然main函数的返回类型为int，但是我们允许main函数没有return语句直接结束。 如果程序到达了main函数的结尾处而且没有return语句，则编译器将隐式地插入一条返回值为0的return语句。 . 当然我们也可以自己手动加。一般该函数的return语句在该函数的最后一句，且return返回值为0。 . main函数的返回值可以看做是状态指示器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。 . 为了使返回值与机器无关，cstdlib头文件定义了两个顶处理变量(EXIT_SUCCESS, EXIT_FAILURE)，我们可以使用这两个变量分别表示成功与失败。 . int main() { if (some_failure) return EXIT_FAILURE; // 定义在cstdlib头文件中。 else return EXIT_SUCCESS; // 定义在cstdlib头文件。 } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5423-main%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5423-main函数返回类型"
  },"333": {
    "doc": "函数概念详解",
    "title": "5.5 函数重载",
    "content": "如果冋一作用域内的几个函数名字相同但形参表不同，我们称之为重载(overloaded)函数。这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。 . 形参表的不同有以下两点： . | 两个形参表中形参数量不同。 | 两个形参表中至少有一个形参的类型不同 | 如果两个形参表中的形参的数量，类型相同，但是至少有一个形参的相对顺序不同。 | . void print(const char *cp); void print(const int *beg, const int *end); void print(const int ia[], size_t size); int j[2] = {0, 1}; print(\"Hello World\"); // 调用 print(const char*) print(j, end(j)-begin(j)); // 调用print(const int*, size_t) print(begin(j), end(j)); // 调用print(const int*, const int*) . 名字不同的函数，就算其他部分完全相同，也不是同一个函数。 . main函数不能重载。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#55-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#55-函数重载"
  },"334": {
    "doc": "函数概念详解",
    "title": "5.51 函数重载与重复定义",
    "content": "函数重载不是重复定义，只要满足了函数重载的规则：形参表的不同。定义的函数就是名字相同的另一个函数。 . 以下这几种特征的不同不会满足函数重载的要求，所以会导致重复定义： . | 形参名不同 | 返回类型不同 | 类型别名形参 | 顶层const形参 | constexpr修饰符 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#551-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#551-函数重载与重复定义"
  },"335": {
    "doc": "函数概念详解",
    "title": "5.511 形参名不同",
    "content": "形参表的不同与形参名无关，形参名与函数重载无关。 . //每对声明的是同一个函数 Record lookup(const Account &amp;acct) {} Record lookup (const Accounts) {} // 省略了形参的名字 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5511-%E5%BD%A2%E5%8F%82%E5%90%8D%E4%B8%8D%E5%90%8C",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5511-形参名不同"
  },"336": {
    "doc": "函数概念详解",
    "title": "5.512 返回类型不同",
    "content": "要注意如果两个函数除了返回类型外，其他所有的要素都相同的，那么是属于同一个函数，会导致重复定义。 . Record lookup(const Accounts) {} bool lookup (const Account&amp;) {} //错误：与上一个函数相比只有返回类型不同 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5512-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5512-返回类型不同"
  },"337": {
    "doc": "函数概念详解",
    "title": "5.513 类型别名形参",
    "content": "用类型别名的类型和源类型算同一个类型。 . typedef Phone Telno; Record lookup(const Phone&amp;) {} Record lookup (const Telno&amp;) {} // Telno和Phone的类型相同。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5513-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5513-类型别名形参"
  },"338": {
    "doc": "函数概念详解",
    "title": "5.514 顶层const形参",
    "content": "一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。 . Record lookup(Phone) {} Record lookup (const Phone) {} // 重复声明了Record lookup(Phone) Record lookup(Phone*) {} Record lookup (Phone* const) {} // 重复声明了Record lookup(Phone*) . 但是如果形参是底层const，则可以实现函数重载。 . //对于接受引用或指针的函数来说，\\ 对象是常量还是非常量对应的形参不同 //定义了4个独立的重载函数 Record lookup (Account&amp;) {} //函数作用于Account的引用。 Record lookup (const Account&amp;) {} // 新函数，作用于常量引用 Record lookup (Account*) {} // 新函数，作用于指向Account的指针。 Record lookup (const Account*) {} //新函数，作用于指向常量的指针。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5514-%E9%A1%B6%E5%B1%82const%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5514-顶层const形参"
  },"339": {
    "doc": "函数概念详解",
    "title": "5.515 constexpr修饰符",
    "content": "两个函数的定义只有constexpr修饰符不同会被认定为重复定义。 . // constexpr函数 constexpr int GetInt(int obj) {} // 普通函数，但constexpr函数与其重复定义 // 会编译错误 int GetInt(int obj) {} . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5515-constexpr%E4%BF%AE%E9%A5%B0%E7%AC%A6",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5515-constexpr修饰符"
  },"340": {
    "doc": "函数概念详解",
    "title": "5.52 函数匹配",
    "content": "定义了一组重载函数后，我们需要以合理的实参调用它们。 . 函数匹配(function matching)是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起來，函数匹配也叫做重载确定(overload resolution)。 . 编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。 . 根据重载集合中每一个函数形参的匹配度，调用重载函数时有三种可能的结果： . | 最佳匹配(best match) | 无匹配(no match) | 二义性调用(ambiguous call) | . 最佳匹配：编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。 . 无匹配：找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。 . 二义性调用：有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时编译器发出二义性调用的错误信息。 . 要注意函数匹配是在编译阶段进行的，只要代码中出现了某个函数的调用，编译器在编译时就会开始对该函数进行函数匹配。只有找到了最佳匹配才会通过编译，否则终止编译，输出错误信息。 . #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;type_traits&gt; template&lt;class T&gt; std::string sprints(const T&amp; arg) { std::string str; // T类型与char*相等时 if (std::is_same&lt;typename std::decay&lt;T&gt;::type, char*&gt;::value) str = arg; else str = std::to_string(arg); return str; } int main(int argc, char **argv) { /* 编译会出错，因为编译器在编译阶段进行sprints函数的函数匹配。 * 模板生成的sprints实例是std::string sprints(const char*(&amp;arg)); * ，而std::to_string函数没有std::to_string(const char*)的重载函数 * 因此会输出匹配不到的编译错误信息，正确方法是新建一个std::to_string(const char*)的重载函数，如下： namespace std { std::string to_string(const char*) { return std::string(\"error!\"); } } // End namespace std * 这样才会编译通过。终端输出strings */ const std::string &amp;str = sprints(\"strings\"); std::cout &lt;&lt; str &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#552-%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#552-函数匹配"
  },"341": {
    "doc": "函数概念详解",
    "title": "5.521 编译器寻找重载函数的过程",
    "content": "和变量一样，编译器寻找重载函数的顺序为： . | 先进行名字查找， | 再进行类型检查。 | . 以下是编译器在寻找重载函数过程： . | 从调用函数的位置向上查找与其名字一样的函数的声明或定义语句。 如果没找到，则终止程序并提示未定义函数的错误。 向上查找只会找该调用点所属的作用域以及包含该调用点作用域的外层作用域，不会找里层作用域。 . | 如果==在某作用域找到了一个同名函数的声明语句，则确定了所有重载函数集合的作用域就是在这个作用域中==(也就是外层的同名函数不算重载函数集合中的函数，外层函数被隐藏)。 将所有在这个作用域中找到的重载函数(包括只有声明，没有定义的)都当成重载函数集合的成员。 . | 然后查找在这个作用域中所有同名函数声明所对应的定义(可以向上查找对应的定义)。 | 如果一个对应的定义语句都没找到，则终止程序并提示未定义函数或声明不匹配的错误。 | . | 在查找函数声明对应定义的过程中，对每个找到对应定义的函数进行类型检查: . | 检查该定义语句所在的作用域内是否存在重复的定义语句。 如果存在，则终止程序并提示重复定义的错误；否则继续后面的操作。 | . | 根据调用点的实参，对重载函数集合进行匹配。 | . 因为编译器是先进行名字查找，再进行类型检查，所以在内外层都有同名的实体时，在非显式指定时某实体时，编译器是不会去查找外层的同名实体的，即使内层的同名实体类型不匹配也不会去查找外层的。 . void prints(const string&amp; str) { cout &lt;&lt; str; } void prints(int ins) { cout &lt;&lt; ins; } void prints(double dou) { cout &lt;&lt; dou; } int main() { void prints(int); // 隐藏了\\ void prints(const string&amp; str)和\\ void prints(double dou)。 prints(\"str\"); // 错误：void prints(const string&amp; str)被隐藏 prints(3.6); // void prints(double dou)被隐藏，所以调用void prints(int)，输出3。 prints(6); // 正确：调用void prints(int)，输出6。 } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5521-%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%BB%E6%89%BE%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5521-编译器寻找重载函数的过程"
  },"342": {
    "doc": "函数概念详解",
    "title": "5.522 重载函数匹配的过程",
    "content": "函数匹配的过程分为三步： . | 选定本次调用对应的候选函数。 | 考察本次调用提供的实参，然后从候选函数中选出可行函数。 | 从可行函数中选择与本次调用最匹配的函数。 | . 候选函数(candidate function)指的是重载函数集合中的函数。 . 候选函数有两个特征： . | 与被调用的函数同名。 | 其声明在调用点可见。 | . 可行函数(viable function)指的是从候选函数中选出能被本次提供的实参调用的函数。 如果没找到可行函数，编译器将报告无匹配函数的错误。 . 可行函数也有两个特征： . | 其形参的数量必须大于或等于本次调用所提供的实参数量。大于时，其多出来的形参必须都有默认实参。 | 每个实参的类型与对应的形参类型相同，或者能隐式转换成对应的形参的类型。 | . 最佳匹配函数是指本次提供的实参类型与该形参类型最接近的函数(比如int比double更接近int)，编译器依次检查每个函数的每个实参以确定哪个函数是最佳匹配。 如果没找到最佳匹配函数，编译器将报告二义性调用的错误。 . 最佳匹配函数也有两个特征： . | 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。 | 至少有一个实参的匹配优于其他可行函数提供的匹配。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5522-%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5522-重载函数匹配的过程"
  },"343": {
    "doc": "函数概念详解",
    "title": "5.523 最佳匹配的确定",
    "content": "为了确定最佳匹配，编译器将实参类型到可行函数的形参类型的接近程度划分成几个等级，以下是接近程度的具体排序，从上到下，接近程度依次降低: . | 精确匹配，包括： . | 实参类型和形参类型相同。 | 实参从数组类型或函数类型转换成对应的指针类型。 | 向实参添加顶层const或者从实参中删除顶层const。 | . | 非底层const实参转换成底层const实现的匹配。 | 通过整型提升实现的匹配。 | 通过算术类型转换或指针转换实现的匹配。 | 通过类类型转换实现的匹配(包括派生类向基类的转换)。 | . 如果一个可行函数的实参匹配同时满足多个等级，则该函数的接近程度按照低等级来。 . 对于含有省略符形参的函数来说，如果该函数并不只有一个形参，则该省略符形参不会对其匹配的优先级有任何影响；但是如果该函数只有省略符这一个形参，则它的优先级比任何可行函数的优先级都要低(除了空形参表函数，该函数与其优先级一样)。 . void prints(int, ...) { cout &lt;&lt; \"omission\"; } void prints(int) { cout &lt;&lt; \"common\"; } // 错误：调用二义性 prints(3); . void prints(...) { cout &lt;&lt; \"omission\"; } void prints(int) { cout &lt;&lt; \"common\"; } // 正确：输出common prints(3); . void prints(...) { cout &lt;&lt; \"omission\"; } void prints() { cout &lt;&lt; \"common\"; } // 错误：调用二义性 prints(); . 对于属于同一接近程度的各种类型的转换，其优先级别都一样，不存在某一种比另一种的更好。 例如算术类型的转换，从int向unsigned int的转换并不比从int向double的转换级别高。 . void manip(long);void manip(float);manip(3.14); //错误：二义性 . 如果两个重载函数的区别仅仅在于底层const，则当调用时，编译器通过实参是否是const类型來决定调用哪个函数。 . Record lookup (Account&amp;); // 函数的参数是Account的引用。 Record lookup (const Account&amp;); // 函数的参数是一个常量引用。 const Account a; Account b; lookup(a); // 调用lookup(const Account&amp;)。 lookup(b); // 调用lookup(Account&amp;)。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5523-%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D%E7%9A%84%E7%A1%AE%E5%AE%9A",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5523-最佳匹配的确定"
  },"344": {
    "doc": "函数概念详解",
    "title": "5.6 可调用对象",
    "content": "C++中的可调用对象分类如下，接下来我们会介绍其中几种： . | 函数 | 函数指针 | 重载函数调用运算符类的对象 | lambda表达式 | bind创建的对象 | function类创建的对象 | . 之前我们介绍了函数和函数指针。接下来，我们在介绍其他可调用对象之前，会介绍一下相关的概念。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#56-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#56-可调用对象"
  },"345": {
    "doc": "函数概念详解",
    "title": "5.61 可调用对象的相关概念",
    "content": "可调用对象(callable object)是指某一个对象或者表达式，如果可以对其使用调用运算符，则称它为可调用对象。 . 和其他对象一样，可调用的对象也有类型。例如，每个lambda有它自己唯一的(未命名)类类型；函数及函数指针的类型则由其返回值类型和所有形参类型决定，等等。 . 所有种类的可调用对象中，除了函数能够重载，其他的可调用对象都不能重载。 所以除了函数以外，同一作用域中的其他可调用对象之间不能有同样的对象名(其他可调用对象与函数之间也不能有重名)，否则调用时会出错。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#561-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#561-可调用对象的相关概念"
  },"346": {
    "doc": "函数概念详解",
    "title": "5.611 调用形式",
    "content": "但是不同类型的可调用对象之间可能是同一种调用形式。 . 调用形式(call signature)是由可调用对象的返回类型以及所有形参类型所组成，一种调用形式对应一个函数类型。 例如：int(int, int)是一个函数类型，它接受两个int，返回一个int。 . 调用形式的一部分是由可调用对象的所有形参类型所组成，所以也包括有默认实参的形参， . 每个非函数对象的可调用对象，有且仅有唯一的调用形式。 . 函数对象的调用形式有多个，调用形式的数量与其类中重载的调用运算符函数的数量一样。 . struct Add { int operator()(int val, int val2) { return val + val2; } double operator()(double val, double val2) { return val + val2; } }; // 函数对象add有两个调用形式，分别为\\ int(int,int)\\ double(double,double) Add add; . 几个可调用对象可能会共享同一种调用形式。 . //它们都是同一种调用形式：int(int, int) //普通函数 int add(int i, int j) { return i + j; } // lambda,其产生一个未命名的函数对象类 auto mod = [](int i, int j) { return i % j; }; //函数对象类 struct divide {int operator()(int denominator, int divisor) {return denominator/divisor;} }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5611-%E8%B0%83%E7%94%A8%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5611-调用形式"
  },"347": {
    "doc": "函数概念详解",
    "title": "5.612 可调用对象的使用",
    "content": "和函数一样，我们可以通过调用运算符(call operator)来执行可调用对象。形式为： . 可调用对象 (实参表) . 调用运算符()内是实参(argument)列表(实参表最外边不能有圆括号)，实参是我们用来初始化可调用对象形参的对象(包括临时对象)，实参可以是任何非声明或定义表达式。 . 调用运算符和可调用对象、其他表达式之间可以有0个或多个空白符分隔。 调用实参表中每个实参与逗号或者圆括号之间可以有0个或多个空白符分隔。 可调用对象形参表中每个形参与逗号或者圆括号之间可以有0个或多个空白符分隔。 . 调用可调用对象时，该可调用对象一般会返回一个对象(包括临时对象)，该对象的类型就是此可调用对象的返回类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5612-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5612-可调用对象的使用"
  },"348": {
    "doc": "函数概念详解",
    "title": "5.62 重载函数调用运算符类的对象",
    "content": "如果某个类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。 . 即使该类的对象只是一个对象而非函数，我们也能“调用”该对象。调用对象实际上是在运行重载的调用运算符。 . 重载的函数调用运算符operator()的形参表中可以有默认实参。 . 该类的对象就是一个可调用对象，也被称作函数对象(function object)因为可以调用这种对象，所以我们说这些对象的“行为像函数一样”。 这样的类对象同时也能存储状态，所以与普通函数相比它们更加灵活。 . struct abslnt { int operator()(int val) const { return val &lt; 0 ? -val : val; } }; int i = -42; abslnt absObj; //含有函数调用运算符的对象 int ui = absObj(i); // 将i传递给 absObj.operator() . 函数调用运算符函数必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别(也就是不能有相同的调用形式)。 . 和其他类一样，函数对象类的行为和普通类没什么区别。比如除了operator()之外也可以包含其他成员。 . // 该函数对象类还包含其他的成员 class Test { int ins; static string sta_str; public: Test(int ins = 88): ins(ins) {} void operator()(int val) { prints(val); } void prints(int val) {cout &lt;&lt; val &lt;&lt; \" \" &lt;&lt; sta_str &lt;&lt; \" \" &lt;&lt; ins &lt;&lt; endl;} }; string Test::sta_str = \"static_str\"; Test te; // 输出 55 static_str 88 te(55); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#562-%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#562-重载函数调用运算符类的对象"
  },"349": {
    "doc": "函数概念详解",
    "title": "5.63 lambda表达式",
    "content": "一个lambda表达式也是一个可调用对象，它也是一个函数对象。我们可以将其理解为一个未命名的内联函数。 . 当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象，在lambda表达式产生的类中含有一个重载的函数调用运算符。 . // func1类似于func2对象 auto func1 = [](const string &amp;a, const string &amp;b) { return a.size () &lt; b.size ();}; struct { bool operator() (const string &amp;a, const string &amp;b) const { return a.size () &lt; b.size (); } }func2; . 与函数类似，一个lambda表达式具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可以定义在函数内部。 lambda表达式返回一个该lambda表达式类型的可调用对象。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#563-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#563-lambda表达式"
  },"350": {
    "doc": "函数概念详解",
    "title": "5.631 lambda表达式的定义形式",
    "content": "一个lambda表达式具有如下形式: . [捕获列表] (可选 形参表/(形参表 -&gt; 返回类型)) 函数体 . // 一个标准的lambda表达式语句，\\ 返回可调用对象func。 auto func = [] (int val) -&gt; int { return val + 35; } . 捕获列表是一个含有lambda所在函数中定义的局部非静态变量的列表(可为空)。 因为lambda不能使用没有出现在捕获列表中的，在所在函数中定义的局部非静态变量，所以想要使用某局部非静态变量，则必须明确指明该变量。 . 捕获列表中的局部非静态变量顺序可以是任意的，不用与这些变量的定义顺序一致。 . 捕获列表只能用于捕获局部非static变量，不能用于其他的变量。但是lambda可以直接使用局部static变量和在它所在函数之外声明的名字。 . 捕获列表内可以是非声明或定义形式的表达式，比如含多个用逗号分隔的多个赋值符所组成的复杂表达式。 . // 函数内部的lambda表达式 void test() { static int ins = 8; string str = \"strs\"; double dou = 6.14; // 捕获了局部变量str和dou，并改变了其值。 auto func = [dou = 8.8, str = \"lambda\"] { cout &lt;&lt; ins &lt;&lt; \" \" &lt;&lt; str &lt;&lt; \" \" &lt;&lt; dou; }; // 输出8 lambda 8.8 p(); } . 形参表、返回类型和函数体的格式与普通函数一样，但是对于lambda表达式来说，形参不能有默认实参；且必须要用尾置返回类型。 . 我们可以忽略形参表和返冋类型，但必须永远包含捕获列表和函数体。 . | 忽略形参表等价于指定一个空形参列表。 | 如果忽略返回类型，lambda表达式根据函数体中的代码推断出返回类型： . | 如果函数体有return语句，则返回类型从该语句的表达式的类型推断而来；否则，返回类型为void。 | lambda表达式用于标准库的泛型算法时，如果该表达式的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。 当一个lambda表达式的函数体中有多个return语句时，所有的return语句返回的类型必须严格一致(能隐式转换也不行)。 . | . | . 如果lambda表达式显式指定了返冋类型，则必须包含形参表。 . // 合法：可调用对象func1的调用形式为\\ int() auto func1 = [] { return 35; }; // 合法：可调用对象func2的调用形式为\\ void() auto func2 = [] { cout &lt;&lt; \"good\"; }; // 合法：可调用对象func3的调用形式为\\ void(int) auto func3 = [] (int val){ cout &lt;&lt; val; }; // 合法：可调用对象func4的调用形式为\\ int(double) auto func4 = [] (double val) -&gt; int { cout &lt;&lt; val; return val+2;}; // 不合法：显式指定了返冋类型，则必须包含形参表。 auto func5 = [] -&gt; int { return 35; }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5631-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5631-lambda表达式的定义形式"
  },"351": {
    "doc": "函数概念详解",
    "title": "5.632 捕获列表",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5632-%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5632-捕获列表"
  },"352": {
    "doc": "函数概念详解",
    "title": "5.6321 捕获方式",
    "content": "类似参数传递，变量的捕获方式可以为 . | 值捕获 | 引用捕获 | . lambda表达式在捕获变量时是自动判断其变量类型的，与auto类型相似，所以想捕获右值对象，则不能用引用来捕获(比如this变量)。 . | 值捕获的前提是变量可以拷贝(是拷贝，不是赋值)，由于被捕获变量的值是拷贝使用的，因此随后对被捕获变量的值修改不会影响到lambda内对应的值。==默认情况下，显式指定用法所捕获的变量都是用值捕获的==。 | . // 函数内部的lambda表达式 void test() { int ins = 16; // ins为值捕获 auto func = [ins] { return ins;}; ins = 33; // 输出16 cout &lt;&lt; func(); } . | 引用捕获形式中捕获的变量与其他任何类型的引用的行为类似。当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定的对象。 | . 引用捕获的使用形式为： . &amp;捕获变量名 . 引用捕获要注意捕获的局部非静态变量的作用域问题。 . // 函数内部的lambda表达式 void test() { int ins = 16; // ins为引用捕获 auto func = [&amp;ins] { return ins;}; ins = 33; // 输出33 cout &lt;&lt; func(); } . 默认情况下，对于一个值被拷贝的变量，lambda表达式不能改变其值；然而引用捕获则可以改变其值。其原因在于： . | lambda表达式在生成未命名类时，对于所有值捕获的变量，都生成一个对应该变量类型的数据成员，同时生成一个构造函数，使其用该变量的值来初始化对应的数据成员。 | 而当lambda表达式通过引用捕获变量时，将由程序自己负责确保lambda执行的时候，引用所引的对象确实存在。因此，编译器就直接使用该引用而无须在lambda产生的类中将其存储为数据成员。 | . lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数；它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。 . 在默认情况下，由lambda产生的类当中的函数调用运算符是一个const成员函数。所以如果想改变被值捕获的变量，就必须将该lambda表达式声明为可变的(也就是在形参表后加上关键字mutable)，使该表达式的所有数据成员都变为mutable。 . 加上关键字mutable时不能省略形参表，必须要有(可以为空)。 . void fcn3() { size_t vl = 42; //局部变量 //f可以改变它所捕获的变量的值 auto f = [vl] () mutable { return ++vl; }; vl = 0; auto j = f(); //j为43 } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#56321-%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#56321-捕获方式"
  },"353": {
    "doc": "函数概念详解",
    "title": "5.6322 捕获列表用法",
    "content": "lambda表达式的捕获列表有三种用法： . | 显式捕获(显式指定某些局部非静态变量) | 隐式捕获 | 混合捕获 | . | 除了显式指定我们希望使用的局部非静态变量，还可以让编译器根据lambda体中的代码来推断我们要使用哪些局部非静态变量，这就是隐式捕获。此时也有对应的两种捕获方式，隐式捕获列表的使用形式为： 值捕获：[=] 引用捕获：[&amp;] . | 如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获。 . | 当我们混合使用时，捕获列表中的第一个元素必须是一个=或&amp;，此符号指定了隐式捕获方式为值或引用。 | 当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。 如果隐式捕获是引用方式(使用了&amp;)，则显式捕获命名变量必须采用值方式；类似的，如果隐式捕获采用的是值方式(使用了=)，则显式捕获命名变量必须采用引用方式。 | . | . 以下是各种捕获列表的用法： . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#56322-%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8%E7%94%A8%E6%B3%95",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#56322-捕获列表用法"
  },"354": {
    "doc": "函数概念详解",
    "title": "5.64 bind创建的对象",
    "content": "当我们需要改变某个可调用对象形参类型的数量甚至是顺序，但是又不想直接修改或定义一个新的可调用对象时，我们就可以用一个标准库里的bind函数来根据该可调用对象快速生成一个新的可调用对象。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#564-bind%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#564-bind创建的对象"
  },"355": {
    "doc": "函数概念详解",
    "title": "5.641 可调用对象的创建",
    "content": "bind的标准库函数定义在头文件functioonal中。 bind函数的使用形式为： . bind(原始可调用对象, 调用原始可调用对象的实参表) . bind函数返回一个和原始可调用对象除了形参表可能不一样，其他都一样的新的可调用对象。 . 原始可调用对象就是需要修改其形参表的对象。 . 如果原始可调用对象有重载函数，那么我们不能直接在bind函数中用其对象名，因为会产生歧义，所以要将该对象转化成无歧义的函数指针才行。 . // 重载函数multiply int multiply(int val, int val2) { return val * val2; }; double multiply(double val, double val2) { return val * val2; }; // 错误：有歧义性 auto func = bind(multiply, std::placeholders::_1, std::placeholders::_2); int (*p)(int,int) = multiply; // 正确：原始可调用对象的是调用形式为int(int,int)的multiply auto func = bind(p, std::placeholders::_1, std::placeholders::_2); . 调用原始可调用对象的实参表是一个逗号分隔的实参列表(该实参表不能加圆括号)，对应原始可调用对象的形参。 . 调用原始可调用对象的实参表要与原始可调用对象的形参表严格一致，也就是不能忽略形参表中有默认实参的形参，每个形参都要给予对应的实参。 . void test(int ins, string str = \"str\") { cout &lt;&lt; str &lt;&lt; \" \" &lt;&lt; ins; } // 错误：不能忽略默认实参的形参。 auto func1 = bind(test, 8); // 正确：实参表与形参表严格一致 auto func2 = bind(test, 8, \"strF\"); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5641-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5641-可调用对象的创建"
  },"356": {
    "doc": "函数概念详解",
    "title": "5.642 bind中的实参表的参数",
    "content": "调用原始可调用对象的实参表可以包含两种参数： . | 普通实参 | 占位符 | . 新生成的可调用对象是一个没有默认实参的可调用对象，且该对象的形参表中==只含有那些占位符所对应的，原始可调用对象的形参==。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5642-bind%E4%B8%AD%E7%9A%84%E5%AE%9E%E5%8F%82%E8%A1%A8%E7%9A%84%E5%8F%82%E6%95%B0",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5642-bind中的实参表的参数"
  },"357": {
    "doc": "函数概念详解",
    "title": "5.6421 普通实参",
    "content": "普通实参就是和普通函数调用一样，调用时所传递的实参。当我们对新生成的可调用对象进行调用时，新生成的可调用对象会自动调用原始可调用对象并对其传递这些普通实参。 所以新的可调用对象中不会包含普通实参所对应的形参。 . 普通实参的传递方式 . 默认情况下，在bind函数被调用时，普通实参是被值传递到新生成的可调用对象中，供其进行传递使用。 . void test(int ins, string str) { cout &lt;&lt; str &lt;&lt; \" \" &lt;&lt; ins; } int ins2 = 5; string str2 = \"strA\"; // 普通实参ins2和str2被拷贝到func对象中 auto func = bind(test, ins2, str2); // 由于是值传递，所以不会影响func ins2 = 19; str2 = \"strB\"; // 输出 strA 5 func(); . 当我们需要引用传递普通实参时，就可以用定义在头文件functional中的ref和cref函数。 . ref和cref函数只能接受一个左值，返回一个该值的临时右值引用或者临时const右值引用(cref函数是返回const版本)，此引用能被拷贝。 . void test(int ins, string str) { cout &lt;&lt; str &lt;&lt; \" \" &lt;&lt; ins; } int ins2 = 5; string str2 = \"strA\"; // 普通实参ins2被拷贝到func对象，但str2是引用传递到func中 auto func = bind(test, ins2, ref(str2)); // 由于是值传递，所以不会影响func ins2 = 19; // str2是引用传递，会改变func中的值 str2 = \"strB\"; // 输出 strB 5 func(); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#56421-%E6%99%AE%E9%80%9A%E5%AE%9E%E5%8F%82",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#56421-普通实参"
  },"358": {
    "doc": "函数概念详解",
    "title": "5.6422 占位符",
    "content": "占位符是标识符形如_n的标准库所定义的一组常量表达式。 它们都定义在头文件functional中的一个名为placeholders的命名空间中，而这个命名空间本身定义在std空间中。 它们占据了传递给新可调用对象的参数的“位置”，用以表示新可调用对象的形参。 占位符标识符中的数值n表示该占位符所对应的原始可调用对象形参在新可调用对象的形参表中的位置。如_1为新可调用对象形参表中的第一个参数，_2为第二个参数，以此类推。 . 在一个bind函数中，实参表的所有占位符标识符中的数值不能有相同的，且其数值都不能超过bind函数中占位符的数量。否则新生成的可调用对象的调用就会出错。 . void test(int ins, string str, double dou = 6.7) { cout &lt;&lt; str &lt;&lt; \" \" &lt;&lt; ins &lt;&lt; \" \" &lt;&lt; dou; } // 错误：占位符数值4超过了占位符数量3 auto func1 = bind(test, std::placeholders::_1, std::placeholders::_2, std::placeholders::_4); // 错误：占位符数值2有相同的 auto func2 = bind(test, std::placeholders::_1, std::placeholders::_1, std::placeholders::_3); // 正确：func3的形参表为(int, string, double) auto func3 = bind(test, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); // 正确：func4的形参表为(string, double, int) auto func4 = bind(test, std::placeholders::_3, std::placeholders::_1, std::placeholders::_2); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#56422-%E5%8D%A0%E4%BD%8D%E7%AC%A6",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#56422-占位符"
  },"359": {
    "doc": "函数概念详解",
    "title": "5.643 可调用对象的使用",
    "content": "bind生成的可调用对象的使用形式和普通的可调用对象一样，用函数调用符加实参表就能调用该对象。 . 但要注意，调用bind生成的可调用对象时： . | 传递实参的顺序要与bind函数中的各占位符标识符的数值位置一致。 | 传递实参的类型也要与各占位符对应的参数类型一致或者能隐式转换。 | 传递实参的数量必须不小于占位符的数量，多于占位符数量的实参将会被编译器忽略(所以与等于占位符数量的实参的调用效果一样)。 | . void test(int ins, string str, double dou = 6.7, char ch = 's') { cout &lt;&lt; str &lt;&lt; \" \" &lt;&lt; ins &lt;&lt; \" \" &lt;&lt; dou &lt;&lt; \" \" &lt;&lt; ch; } // 生成一个有3个形参的可调用对象，其形参为(double, string, char) auto func = bind(test, 8, std::placeholders::_2, std::placeholders::_1, std::placeholders::_3); // 错误：与各占位符的数值位置不一致。 func(\"str\", 3.6, 'k'); // 错误：占位符_3对应的类型是char，而\"k\"不能隐式转换为char类型。 func(3.6, \"str\", \"k\"); // 错误：实参数量小于占位符数量。 func(3.6, \"str\"); // 正确：实参数量等于占位符数量，输出str 8 3.6 k func(3.6, \"str\", 'k'); // 正确：实参数量不小于占位符数量，该调用与\\ func(3.6, \"str\", 'k');\\ 效果一样，输出str 8 3.6 k func(3.6, \"str\", 'k', 18, \"str2\", 'p'); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5643-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5643-可调用对象的使用"
  },"360": {
    "doc": "函数概念详解",
    "title": "5.65 不同类型的可调用对象的统一",
    "content": "之前我们讲过，每一个可调用对象都有自己的类型和调用形式。 对于某些可调用对象来说，它们的类型可能大不相同，但是它们的调用形式可能是一样，所以当我们需要用这些可调用对象时，最好能够将它们统一起来，方便调用，比如用函数表。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#565-%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%9F%E4%B8%80",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#565-不同类型的可调用对象的统一"
  },"361": {
    "doc": "函数概念详解",
    "title": "5.651 函数表介绍",
    "content": "函数表(function table)是指一种能够保存各种可调用对象的数据结构，该结构能够方便我们对保存的对象进行查询或者调用。 . 我们有时候希望使用这些可调用对象构建一些复杂的操作。为了实现这一目的，需要定义一个函数表用于存储指向这些可调用对象的“指针”。当程序需要执行某个特定的操作时，从表中查找该调用的函数。 . 我们可以使用容器来作为函数表进行可调用对象的保存。 但是一个容器只能容纳同一种类型的可调用对象，虽然某些可调用对象的调用形式一样，但是它们的类型却不一样(比如每个lambda的类型都是唯一的，函数对象的类型是它们对应的类)。 . 为了统一这些可调用对象，我们可以用定 义在functional头文件中的function类来将它们转化成同一个类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5651-%E5%87%BD%E6%95%B0%E8%A1%A8%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5651-函数表介绍"
  },"362": {
    "doc": "函数概念详解",
    "title": "5.652 function类",
    "content": "function是一个类模板，和我们使用过的其他模板一样，当创建一个具体的function类型时，我们必须指定一个调用形式，表示该function类型的对象能够保存具有指定调用形式的可调用对象的数据。 . // f1是一个调用形式为int(int,int)的空可调用对象 function&lt;int (int, int)&gt; f1 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5652-function%E7%B1%BB",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#5652-function类"
  },"363": {
    "doc": "函数概念详解",
    "title": "5.6521 function类的操作",
    "content": "以下是function类所具有的操作： . 支持的操作|解释 . |- function&lt;T&gt; f function&lt;T&gt; f(nptr)|T指的是调用形式，nptr指的是空指针 创建一个调用形式T的空的可调用对象f。f能够保存调用形式T的可调用对象的数据。 function&lt;T&gt; f initiate|initiate指的是初始化，initiate可以是直接或拷贝初始化。初始值必须是一个调用形式T的可调用对象。 创建一个调用形式T的可调用对象f，f是其初始值的副本。 f = obj|obj是一个调用形式T的可调用对象。 f变为obj的副本。 f|将f作为条件：当f是一个可调用对象的副本时为真；否则为假。 f(arg)|调用f，参数是arg。 | . function&lt;T&gt;类中的成员|解释 . | result_type | 该function类型的可调用对象返回的类型 | . | argument_type first_argument_type second_argument_type | 当T只有一个或两个实参时才有的成员。如果T只有一个实参，则argument_type是该实参类型的同义词；如果T有两个实参，则first_argument_type 和 second_argument_type 分别代表这两个实参的类型。 | . | . 每种function类型的对象就是一个具有其指定调用形式的可调用对象。该对象默认为空，必须要用其他具有相同调用形式的可调用对象来初始化或者赋值该对象后才能正常使用。 . 用于初始化或赋值的可调用对象的调用形式可以与function对象不相同，只要function对象的对应类型能够隐式转换为所保存的可调用对象的对应类型就行。不过function对象调用时是按function对象的调用形式为主。 . int ret(bool jud, string str) {} // 正确：\\ double (long, const char*)中的\\ 各种类型都能隐式转换成int (bool, str)里的对应类型。\\ func的调用形式还是为double (long, const char*) function&lt;double (long, const char*)&gt; func = ret; . 如果某函数名有重载函数，那么我们不能直接用其函数名为function对象初始化或赋值，因为会产生歧义，所以要将该函数转化成无歧义的函数指针才行。 . // 重载函数multiply int multiply(int val, int val2) { return val * val2; }; double multiply(double val, double val2) { return val * val2; }; // 错误：有歧义性 function&lt;int(int, int)&gt; f = multiply; int (*p)(int,int) = multiply; // 正确：保存的是调用形式为int(int,int)的multiply function&lt;int(int, int)&gt; f = p; . 因为函数对象有多个调用形式，所以同一个函数对象能对不同调用形式的function类型的对象初始化或赋值，只要该函数对象具有某个相同调用形式的调用运算符函数就行。 . function类型的对象是一个没有默认实参的可调用对象，它会忽略掉初始化或赋值给自己的可调用对象的所有默认实参。 所以调用function类型的对象所传递的实参数量要与用于初始化或赋值的对象的形参数量一致。 . // 函数对象类Add struct Add { int operator()(int val, int val2) { return val + val2; } double operator()(double val, double val2) { return val + val2; } }; // lambda表达式minuss auto minuss = [] (int val, int val2) { return val - val2; }; // 普通函数multiply int multiply(int val, int val2) { return val * val2; }; // 函数对象add Add add; // 直接初始化，保存add的数据 function&lt;int(int, int)&gt; f1(add); // 拷贝初始化，保存minuss的数据 function&lt;int(int, int)&gt; f2 = minuss; // 定义一个空的f3 function&lt;int(int, int)&gt; f3; // 用multiply赋值给f3 f3 = multiply; // 输出11 cout &lt;&lt; f1(8,3) &lt;&lt; endl; // 输出5 cout &lt;&lt; f2(8,3) &lt;&lt; endl; // 输出24 cout &lt;&lt; f3(8,3) &lt;&lt; endl; // 直接初始化，add的数据可以初始化另一个不同调用形式的function对象。 function&lt;double(double, double)&gt; f4{add}; // 输出11.9 cout &lt;&lt; f4(8.6,3.3) &lt;&lt; endl; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#56521-function%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html#56521-function类的操作"
  },"364": {
    "doc": "函数概念详解",
    "title": "函数概念详解",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html",
    
    "relUrl": "/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html"
  },"365": {
    "doc": "第六章 动态内存管理",
    "title": "第六章 动态内存管理",
    "content": "第6章先介绍了动态内存管理的概念与结构，然后根据管理方法的不同依次介绍了各种动态内存管理的方法。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/index.html",
    
    "relUrl": "/guide_files/chap6/index.html"
  },"366": {
    "doc": "动态内存管理概念详解",
    "title": "6.1 动态内存管理概念",
    "content": "之前我们在介绍对象生命周期时谈到过了编译器在分配内存时根据不同策略将系统内存分为三种： . | 静态存储区(static) | 动态存储区/栈区(stack) | 自由空间区(free store)/堆区(heap) | . 前两个是由编译器自主控制分配和释放的，而最后一个堆区里的对象，是由我们自己的代码来控制其对象的生存期。自由空间区的对象也叫做动态内存对象，所以我们这章所介绍的就是对动态内存的管理。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#61-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#61-动态内存管理概念"
  },"367": {
    "doc": "动态内存管理概念详解",
    "title": "6.11 动态内存管理的基本操作",
    "content": "一般来说，动态内存的管理有两种基本操作： . | 内存分配 | 内存释放 | . 内存分配就是获取一块原始的，未被使用的动态内存空间。 内存释放就是将这块动态内存的使用权还给系统，表示不需要使用里面的数据了，以供系统作其他用途。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#611-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#611-动态内存管理的基本操作"
  },"368": {
    "doc": "动态内存管理概念详解",
    "title": "6.12 对象的基本操作",
    "content": "而大多数时候，动态内存的操作往往会跟着对象的某种基本操作： . | 对象创建(构造) | 对象销毁(析构) | . 对象创建是指在所给的动态内存中建立一个给定的对象，并对该对象进行初始化。 对象销毁是指释放该动态内存对象所使用的所有资源(也就是对该对象所使用的其他动态内存对象执行对象销毁和内存释放的操作)。 . 对象销毁不等于内存释放，一个动态内存对象的销毁并不会释放该对象本身的内存。 也就是调用某对象的析构函数只会销毁该对象，不会释放该对象的内存。 . 在一个动态内存对象没有被销毁时，最好不要直接释放该对象的内存，因为==释放该对象的内存仅仅是对该对象的内存的释放，而没有释放该对象所使用的其他对象的内存==，导致这些对象的内存无法被释放了。 所以对动态内存对象的管理，应该是先对该对象执行销毁，然后再是释放该对象的内存。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#612-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#612-对象的基本操作"
  },"369": {
    "doc": "动态内存管理概念详解",
    "title": "6.13 动态内存管理工作的步骤",
    "content": "所以，对于动态内存对象的构建以及用完后的对象清理工作，大多数管理工作是以以下这4个步骤进行的： . | 内存分配 | 对象构造 | 对象销毁 | 内存释放 | . 任何一个步骤如果有省略或者步骤顺序不对，都有可能会造成动态内存管理操作的失败以及出现未定义行为。 . 在堆区分配的内存是无名的，因此无法为其中创建的对象命名。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#613-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%AD%A5%E9%AA%A4",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#613-动态内存管理工作的步骤"
  },"370": {
    "doc": "动态内存管理概念详解",
    "title": "6.14 动态内存管理方法分类",
    "content": "根据动态内存操作与对象操作的组合，动态内存管理的方法可以分为三种： . | 内存与对象操作分离 . | malloc, calloc等函数 | allocator类 | . | 内存与对象操作组合 . | new, delete运算符 | . | RAII . | 智能指针 . | shared_ptr . | weak_ptr | . | unique_ptr | . | . | . | 内存与对象操作分离的管理方法是指动态内存的分配与释放与对象的创建与销毁是分开的。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。 . | 内存与对象操作组合的管理方法是指在执行动态内存分配时就自动创建了对象，在执行内存释放时自动先执行了对象销毁。 . | RAII(Resource Acquisition Is Initialization)是指资源获取即初始化，也就是说：在内存分配时就自动创建了对象。但其实这还有一半意思是指：内存释放时执行对象的销毁操作。 所以运用RAII思想的动态内存管理的方法是将内存的操作和对象的操作一起结合起来，该方法创建的对象在创建时自动分配内存，不需要用时自动执行销毁和内存释放操作，而无需手动操作。 . | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#614-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#614-动态内存管理方法分类"
  },"371": {
    "doc": "动态内存管理概念详解",
    "title": "6.2 内存与对象操作分离的管理方法",
    "content": "内存与对象操作分离的管理方法是指动态内存的分配与释放与对象的创建与销毁是分开的。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。 . 内存与对象操作分离的管理方法可以分为两种，一种是从C语言继承的，第二种是C++标准库的： . | malloc, calloc等函数 | allocator类 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#62-%E5%86%85%E5%AD%98%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E5%88%86%E7%A6%BB%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#62-内存与对象操作分离的管理方法"
  },"372": {
    "doc": "动态内存管理概念详解",
    "title": "6.21 malloc等函数",
    "content": "接下来介绍的几个函数是从C语言中继承的，它们都定义在cstdlib头文件中。 . 这几个函数只负责内存的分配与释放，不负责对象的创建与销毁，所以我们必须自己来操作对象的创建与销毁。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#621-malloc%E7%AD%89%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#621-malloc等函数"
  },"373": {
    "doc": "动态内存管理概念详解",
    "title": "6.211 malloc函数",
    "content": "malloc函数接受一个表示待分配字节数的size_t(unsigned int)，返回一个指向分配空间的第一个字节的地址的空类型指针，如果分配失败(如内存不足)，则返回空指针。 . malloc函数的函数声明为: . void* malloc(size_t size); . malloc函数一般配合sizeof运算符来创建特定类型的某个对象。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6211-malloc%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6211-malloc函数"
  },"374": {
    "doc": "动态内存管理概念详解",
    "title": "6.212 calloc函数",
    "content": "和malloc函数类似，calloc函数接受一个表示分配内存空间数量size_t和表示每个内存空间所占的字节数的size_t，该函数分配的空间的地址是连续的。 返回一个指向分配空间的第一个字节的地址的空类型指针，如果分配失败(如内存不足)，则返回空指针。 . calloc函数的函数声明为: . void* calloc(size_t n, size_t size); . calloc函数一般配合sizeof运算符来创建以特定类型的对象为元素的类数组结构，所以该指针可以像指向容器元素的指针一样进行元素访问的操作。 . // 分配含有5个int类型字节大小的内存空间 int *ptr_arr = (int*)calloc(5,sizeof(int)); // 对这5个空间进行对象创建 for (int i = 0; i &lt; 5; ++i) *(ptr_arr+i) = i + 5; // 输出5 6 7 8 9 for (int i = 0; i &lt; 5; ++i) cout &lt;&lt; *(ptr_arr+i) &lt;&lt; \" \"; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6212-calloc%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6212-calloc函数"
  },"375": {
    "doc": "动态内存管理概念详解",
    "title": "6.213 realloc函数",
    "content": "realloc函数接受一个void*和表示分配字节数的size_t，该void*必须是malloc或者calloc返回的指针或者其指针的副本，否则会出错，如果是空指针则该函数直接新分配一个给定字节数的内存空间。 realloc函数将给定指针所指的所有分配内存的大小改为给定的分配字节数，并重新返回给定的指针(指向已修改大小的分配空间的第一个字节的地址的空类型指针)，如果修改失败(如内存不足)，则返回空指针。 . 对calloc返回的指针使用时，是将calloc所分配的n*size大小的空间修改为给定的分配字节数。 . realloc函数的函数声明为: . void* realloc(void* ptr, size_t size); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6213-realloc%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6213-realloc函数"
  },"376": {
    "doc": "动态内存管理概念详解",
    "title": "6.213 free函数",
    "content": "free函数接受一个void*，该空类型指针必须是malloc或者calloc返回的指针或者其指针的副本，否则会出错，如果是空指针则该函数不做任何操作。 free函数将给定指针所指的内存释放。 . free函数的函数声明为: . void free(void* ptr); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6213-free%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6213-free函数"
  },"377": {
    "doc": "动态内存管理概念详解",
    "title": "6.214 malloc等函数的使用",
    "content": "因为这几个函数只负责内存的分配与释放，所以我们要自己对其内存进行对象创建与销毁。 . 因为这几个函数都是返回指针，所以只能通过有关指针的操作来进行动态内存对象的创建： . | 用对应对象来赋值。 用对应对象来赋值需要该类型的拷贝赋值运算符不能是删除的。 | 调用对应类型的构造函数来赋值(临时对象)。 调用对应类型的构造函数来赋值需要该类型的拷贝或者移动赋值运算符不能是删除的。 | 用定位new表达式直接在内存中创建对象。 用定位new表达式直接在内存中创建对象是最好的方法，只要对应类型有构造函数就能创建对象，且该方法对对应类型没有前两个方法所需的限制。 | . #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; using namespace std; /* 使用定位new表达式的创建方法： 定义了一个含有 非静态的string类型的数据成员 的类型Te，该类型可以用定位new表达式创建对象 */ struct Te { int ins; static string sta_str; string str; Te(int ins = 18, string str = \"Te_str\"): ins(ins), str(str) { cout &lt;&lt; \"constructed!\\n\"; } Te&amp; operator=(const Te&amp; cls) = delete; ~Te() { cout &lt;&lt; \"deleted!\\n\"; } }; string Te::sta_str = \"Te_static_str\"; int main() { // 分配内存 void *vp = malloc(sizeof(Te)); // 创建对象 Te *tp = new(vp) Te(30,\"good_created\"); /* 两个指针保存同一个地址，输出 constructed! good_created good_created deleted! */ cout &lt;&lt; (*(Te*)vp).str &lt;&lt; \" \" &lt;&lt; (*tp).str &lt;&lt; endl; // 销毁对象 tp-&gt;~Te(); // 释放内存 free(vp); return 0; } . 要注意用1，2这两个方法时，malloc等函数不能创建含有非静态的类类型数据成员的类型的对象，否则会出错。 . #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; using namespace std; /* 使用第二种创建方法： 定义了一个含有 非静态的string类型的数据成员 的类型Te，此时 该类型不能用 malloc等函数创建对象*/ struct Te { int ins; string str; Te(int ins = 18, string str = \"Te_str\"): ins(ins), str(str) {} Te&amp; operator=(const Te&amp; cls) { this-&gt;ins = cls.ins; this-&gt;str = cls.str; return *this; }; }; Te *ptr = (Te*)malloc(sizeof(Te)); // 出错！ *ptr = Te(); cout &lt;&lt; ptr-&gt;str; free(ptr); . #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; /* 使用第二种创建方法： 定义了一个类类型Te， 该类型没有 非静态的类类型数据成员。 所以该类型可以用 malloc等函数创建对象。*/ struct Te { int ins; static string str; Te(int ins = 18): ins(ins) {} Te&amp; operator=(const Te&amp; cls) { this-&gt;ins = cls.ins; return *this; }; }; string Te::str = \"Te_static_str\"; Te *ptr = (Te*)malloc(sizeof(Te)); // 正确：用调用对应类型的构造函数来赋值 *ptr = Te(); // 输出Te_static_str cout &lt;&lt; ptr-&gt;str; free(ptr); . 要记住当分配的内存不需要再使用后要即使释放。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6214-malloc%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6214-malloc等函数的使用"
  },"378": {
    "doc": "动态内存管理概念详解",
    "title": "6.22 allocator类",
    "content": "标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。 . 和malloc等函数不一样。allocator类既提供内存分配和释放操作，也提供对象创建和销毁操作。 . allocator是一个类模板。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型來确定恰当的内存大小和对齐位置。 . 一个allocator对象只能分配其给定类型的对象。 . allocator&lt;string&gt; alloc; // 可以分配string的allocator对象 auto const p = alloc.allocate(n); //分配n个string类型大小的空间。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#622-allocator%E7%B1%BB",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#622-allocator类"
  },"379": {
    "doc": "动态内存管理概念详解",
    "title": "6.221 allocator类的操作",
    "content": "以下是allocator类所支持的操作： . | 内存分配 . | 指明可以分配的对象类型: allocator 对象名a . 定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存。 . | 指明分配对象的数量: 对象名a.allocate(数量n) . 分配一段原始的、未构造的内存，含有n个类型为T的对象的空间，并返回一个指向该内存开始地址的T*类型的指针。 . | . | 对象创建 对象名a.construct(指针p, 需要传递给指明类型构造函数的实参们args) . p必须是指向a所的分配的内存的类型为T*的指针(不能是指向其他allocator对象或其他对象的指针)；arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象。 . | 对象销毁 对象名a.destroy(指针p) . p必须是指向a所的分配的内存的类型为T*的指针(不能是指向其他allocator对象或其他对象的指针)，该函数对p指向的对象执行析构函数。 . | 内存释放 对象名a.deallocate(指针p, 数量n) . p必须是先前由a.allocate函数所返回的指针或者其副本；n必须是先前a.allocate函数所指定的数量。 释放从T*指针p中地址开始的内存，这块内存的大小为n\\*sizeof(T)。 . | . 和calloc函数类似，我们对于allocate函数返回的指针，可以像指向容器元素的指针一样进行元素访问的操作。 . 和之前提到的步骤一样，我们在使用allocator类构建动态内存对象时也需要按照这四个步骤进行。 . // 内存分配：分配一个能保存5个string类型大小的空间 allocator&lt;string&gt; strs; string* p = strs.allocate(5); // 对象创建：遍历每个string空间并在其中构造string对象 for (int i = 0; i &lt; 5; ++i) strs.construct(p+i, \"str\" + to_string(i+5)); // 遍历每个string空间并输出对应string对象的值 // 输出为str5 str6 str7 str8 str9 for (int i = 0; i &lt; 5; ++i) cout &lt;&lt; *(p+i) &lt;&lt; \" \"; // 对象销毁：遍历每个string空间并销毁在其中的string对象 for (int i = 0; i &lt; 5; ++i) strs.destroy(p+i); // 内存释放：释放之前分配的保存5个string类型大小的空间 strs.deallocate(p, 5); . 不能使用未构造对象的内存，其行为是未定义的。 . 我们只能对真正构造了对象的内存空间进行destroy操作，否则行为是未定义的。 . 当某空间的对象被销毁后，还可以重新使用这部分内存來保存其他同类型的对象。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6221-allocator%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6221-allocator类的操作"
  },"380": {
    "doc": "动态内存管理概念详解",
    "title": "6.222 allocator类的快捷对象构建操作",
    "content": "标准库还为allocator类定义了两种算法，可以在未构造对象的内存中创建对象，它们都定义在头文件memory中。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6222-allocator%E7%B1%BB%E7%9A%84%E5%BF%AB%E6%8D%B7%E5%AF%B9%E8%B1%A1%E6%9E%84%E5%BB%BA%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6222-allocator类的快捷对象构建操作"
  },"381": {
    "doc": "动态内存管理概念详解",
    "title": "6.3 内存与对象操作组合的管理方法",
    "content": "内存与对象操作组合的管理方法是指： . | 在执行动态内存分配操作后，该操作自动创建了给定类型的对象。 | 在执行内存释放操作时，该操作自动先执行了给定对象的销毁操作。 | . 所以我们在使用这些管理方法时，就不必考虑对象的构造与销毁了。 . 内存与对象操作组合的管理方法有一种，这种操作支持某部分的自定义，接下来会来介绍这种操作： . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#63-%E5%86%85%E5%AD%98%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E7%BB%84%E5%90%88%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#63-内存与对象操作组合的管理方法"
  },"382": {
    "doc": "动态内存管理概念详解",
    "title": "6.31 new和delete运算符",
    "content": "C++语言定义了两个运算符来分配和释放动态内存。 . 运算符new分配内存并创建对象。 delete销毁所给指针所指的对象并释放该对象的内存。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#631-new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#631-new和delete运算符"
  },"383": {
    "doc": "动态内存管理概念详解",
    "title": "6.311 new表达式",
    "content": "new表达式的使用形式为： . new 类型(包含类型修饰符) (可选 显式初始化) . new表达式一个所给类型尺寸大小的内存并在其中创建一个该类型的对象。 new表达式返回一个指向该类型对象的指针。 . int *pi = new int; // pi指向一个动态分配的、默认初始化的无名int对象。 . 和普通的声明或定义语句一样，new里的类型可以有各种类型修饰符。 . int ins = 8; int *pi = &amp;ins; // 分配并初始化一个int* int **ppi = new int*(pi); // 输出8 cout &lt;&lt; **ppi; // 分配并初始化一个const int const int *pci = new const int(1024); . 在没有给定显式初始化时，动态分配的对象是默认初始化的，所以对于默认构造函数的类型，必须要显示初始化。 . string *ps = new string; // 初始化为空string int *pi = new int; // pi指向一个未初始化的int . 对给定类型的显式初始化，只能用直接初始化的方式进行初始化。 所以调用类型的值初始化要在类型后面加圆括号()或花括号{}。 . 和一般变量的初始化一样，用列表初始化时，列表所给的初始值数量不能超过所给类型所规定的初始值数量。 . string *psl = new string; //默认初始化为空string string *ps = new string(); //值初始化为空string int *pil = new int; //默认初始化；*pil的值未定义 int *pi2 = new int(); //值初始化为0; *pi2为0 int *pi3 = new int{}; //值初始化为0; *pi3为0 int *pi4 = new int{3}; //初始化为3; *pi4为3 int *pi5 = new int{3,9}; //错误：初始化值数量过多。 . 我们可以用auto类型来让编译器来自动推断所要分配的内存以及创建对象的类型，和一般变量的初始化一样，要显式初始化动态对象才能使用auto。 . // 正确：初始化为36; *pi为36 int *pi = new auto{36}; // 正确：初始化为3.66; *pd为3.66 double *pd = new auto(3.66); // 正确：初始化为strs; **ps为strs const char **ps = new auto(\"strs\"); // 错误：用auto必须要显式初始化。 int *pi2 = new auto; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6311-new%E8%A1%A8%E8%BE%BE%E5%BC%8F",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6311-new表达式"
  },"384": {
    "doc": "动态内存管理概念详解",
    "title": "6.312 delete表达式",
    "content": "delete表达式是专门用于释放new表达式所分配的内存的。 delete销毁所给指针所指的对象并释放该对象的内存。 . delete表达式的形式为： . delete 指针 . 我们传递给delete的指针必须是指向new所分配的内存，或者是一个空指针。 释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的。 . int i, *pil = &amp;i, *pi2 = nullptr; double *pd = new double(33), *pd2 = pd; delete i; //错误：i不是一个指针 delete pil; //未定义：pil指向一个局部变量 delete pd; //正确 delete pd2; //未定义：pd2指向的内存已经被释放了 delete pi2; //正确：释放一个空指针总是没有错 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6312-delete%E8%A1%A8%E8%BE%BE%E5%BC%8F",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6312-delete表达式"
  },"385": {
    "doc": "动态内存管理概念详解",
    "title": "6.313 new[ ]表达式",
    "content": "之前我们说过new里的类型可以有各种类型修饰符，那么理所当然，我们可以通过将其类型写为数组类型来创建一个动态对象的数组。 所以，当我们想要一次性分配多个同类型的对象时，就可以使用new[ ]表达式。 . new[ ]的普通使用形式为： . new 类型(包含类型修饰符) [容量大小] (可选 显式初始化) . new[ ]表达式分配一个能包含所有所给容量大小数量的对象的内存并在其中创建所给容量大小数量的对象。 new[ ]表达式返回一个指向动态对象数组的首元素的指针。 . 和数组的初始化一样: 没有显式初始化时，其里面的元素都为默认初始化； auto不能用于数组类型。 . 和数组不一样的是： 类型修饰符[ ]内的==容量大小不能省略==。 . 和数组一样的是： 可以用空圆/花括号来值初始化。 . new[ ]表达式的初始化规则与new表达式一样。 . 和数组类似，可以将其返回的指针当做指向容器内元素的指针一样进行元素访问。 . // 正确：输出为2 6 8 1 3 int *p = new int[5]{2,6,8,1,3}; // 正确：值初始化，输出为0 0 0 0 0 int *p = new int[5](); for (int i = 0; i &lt; 5; ++i) cout &lt;&lt; *(p+i) &lt;&lt; \" \"; . 当定义一个动态对象的多维数组时，数组不一样的是，如果列表初始化的列表不为空，则初始值必须要嵌套才行，否则会出错。 . // 正确：初始值已嵌套，输出为6 9 8 4 5 3 6 2 -8 int(*a2p)[3] = new int[3][3]{{6,9,8},{4,5,3},{6,2,-8}}; // 正确：两种定义的列表都为空，输出为0 0 0 0 0 0 0 0 0 int(*a2p)[3] = new int[3][3]{}; int(*a2p)[3] = new int[3][3](); for (int i = 0; i &lt; 3; ++i) for (int j = 0; j &lt; 3; ++j) cout &lt;&lt; *(*(a2p+i)+j) &lt;&lt; \" \"; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6313-new-%E8%A1%A8%E8%BE%BE%E5%BC%8F",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6313-new-表达式"
  },"386": {
    "doc": "动态内存管理概念详解",
    "title": "6.314 delete[ ]表达式",
    "content": "delete[ ]表达式是专门用于释放new[ ]表达式所分配的内存的。 delete[ ]表达式先自动将所给指针中所保存的内存中的每个对象进行销毁(逆序销毁：即，最后一个元素首先被销毁，然后是倒数第二个，依此类推)，然后释放所给指针中所保存的所有内存。 . 和new[ ]表达式类似，delete[ ]表达式的普通形式为： . delete[ ] 指针 . 我们传递给delete[ ]的指针必须是指向new[ ]所分配的内存的第一个元素，或者是一个空指针。 释放一块并非new[ ]分配的内存，或者将相同的指针值释放多次，其行为是未定义的。 . 在释放一个数组指针时必须使用方括号，不能用普通的delete表达式，否则其行为是未定义的。 . type def int arrT [42] ; // arrT是42个int的数组的类型别名 int *p = new arrT; //分配一个42个int的数组；p指向第一个元素 delete [] p; //方括号是必需的，因为我们当初分配的是一个 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6314-delete-%E8%A1%A8%E8%BE%BE%E5%BC%8F",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6314-delete-表达式"
  },"387": {
    "doc": "动态内存管理概念详解",
    "title": "6.315 定位new表达式",
    "content": "有时候，我们为了一些操作，需要向new传递一些额外的参数，此时可以用new相关表达式的另一种形式，这种形式也叫做定位new(placement new)。 定位new表达式的形式为： . new (指针/nothrow对象) 类型(包含类型修饰符) (可选 [容量大小]) (可选 显式初始化) . 定位new表达式传递的实参为nothrow对象时，是用于阻止内存异常的。 . 定位new表达式传递的实参为指针时，是用于在指针所指的地址中创建给定类型的对象的。 . 定位new表达式只能额外传递最多一个参数，且必须是指针(或者能隐式转换成指针)或者nothrow对象。 . 接下来会详细介绍这两个用途。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6315-%E5%AE%9A%E4%BD%8Dnew%E8%A1%A8%E8%BE%BE%E5%BC%8F",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6315-定位new表达式"
  },"388": {
    "doc": "动态内存管理概念详解",
    "title": "6.3151 定位new用于阻止内存异常",
    "content": "badalloc和nothrow都定义在头文件new中。 . 虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。 一旦一个程序用光了它所有可用的自由空间内存，new相关表达式就会失败。 默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。 . 所以为了阻止new相关表达式的表达式发出异常，我们可以使用定位new表达式并传递一个由标准库定义的名为nothrow的对象。 如果将nothrow传递给new，则new相关表达式就不会再抛出异常了，如果这时的new不能分配所需内存，则它会返回一个空指针。 . //如果分配失败，new返回一个空指针 int *pl = new int; // 如果分配失败，new抛出std::bad_alloc int *p2 = new (nothrow) int; //如果分配失败，new返回一个空指针 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#63151-%E5%AE%9A%E4%BD%8Dnew%E7%94%A8%E4%BA%8E%E9%98%BB%E6%AD%A2%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#63151-定位new用于阻止内存异常"
  },"389": {
    "doc": "动态内存管理概念详解",
    "title": "6.3152 定位new用于构造对象",
    "content": "当我们希望在某个内存地址上构造一个对象时，就可以使用定位new表达式并传递一个保存该地址的指针来在该地址上构造并初始化一个给定类型的对象。 . 此时new==不分配任何内存==，它只是在指定的地址上构造对象并初始化，然后返回一个和实参指针相同地址的，指向给定类型的指针。 . 要注意此时的定位new是构造一个新的对象，就算之前的地址有对象，定位new也是==直接抹除该对象数据==(不进行对象销毁，所以也就不调用其析构函数)，然后在该地址上直接创建一个新的对象。 . 给定地址的字节大小必须不小于定位new所指定的类型的尺寸大小，否则会出错。 . 不管所给的地址中是否已经含有某对象的数据，定位new会从低位开始直接覆盖掉所需要的空间的所有数据，然后==调用所给类型的对应构造函数==来构造对象。 . 所以当给定地址的字节大小大于定位new所指定的类型的尺寸大小时，定位new所构造的对象地址只占低位所需要的字节，高位字节的数据仍然保留了下来。 . 要注意此时的定位new不分配任何内存，所以当定位new用于对动态内存中创建对象时，使用完毕的清理工作不应该由new对应的delete来做，应该由当初分配内存操作所对应的清理操作来进行清理工作。 . void* sp = malloc(sizeof(string)); // 正确：sp所保存的地址不小于string类型的尺寸。\\ 构造一个string对象，并初始化为strs1 string* p = new(sp) string(\"strs1\"); // 正确：两个指针保存同一个地址，所以输出strs1 strs1 cout &lt;&lt; *p &lt;&lt; \" \" &lt;&lt; *(string*)sp &lt;&lt; endl; // 正确：因为内存是由malloc函数分配的\\ ，所以要调用对应的free函数。 free(sp); void* sp2 = malloc(sizeof(100)); // 正确：sp2所保存的地址不小于string类型的尺寸。\\ 构造一个string对象，并初始化为strs2 string* p2 = new(sp2) string(\"strs2\"); // 正确：两个指针保存同一个地址，所以输出strs2 strs2 cout &lt;&lt; *p2 &lt;&lt; \" \" &lt;&lt; *(string*)sp2 &lt;&lt; endl; // 错误：内存是由malloc函数分配的\\ ，与new无关。 delete p2; void* sp3 = malloc(0); // 错误：sp3所保存的地址小于string类型的尺寸，会出错。 string* p3 = new(sp3) string(\"strs3\"); . 这种用法的定位new表达式所传递的地址甚至不需要是动态内存，此时定位new可以用来对该地址重新创建一个对象。 . // double对象dou被默认初始化，\\ 不能直接使用。 double dou; // 所以重新在该地址上创建了一个dou对象，值为3.48。 double *dp = new(&amp;dou) double(3.48); // 输出3.48 3.48 cout &lt;&lt; dou &lt;&lt; \" \" &lt;&lt; *dp; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#63152-%E5%AE%9A%E4%BD%8Dnew%E7%94%A8%E4%BA%8E%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#63152-定位new用于构造对象"
  },"390": {
    "doc": "动态内存管理概念详解",
    "title": "6.316 自定义运算符函数",
    "content": "某些应用程序对内存分配有特殊的需求，因此我们无法将标准内存管理机制直接应用于这些程序。它们常常需要自定义内存分配的细节，比如使用关键字new将对象放置在特定的内存空间中。为了实现这一目的，应用程序需要自定义某些部分以控制内存分配的过程。 . 之前我们也谈到过，new和delete相关表达式是将内存操作与对象操作组合起来的操作。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6316-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6316-自定义运算符函数"
  },"391": {
    "doc": "动态内存管理概念详解",
    "title": "6.3161 new和delete运算符工作原理",
    "content": "具体来说，对于new和new[ ]表达式，该操作有三个步骤： . | 调用一个名为operator new(或者operator new[ ])的标准库函数，分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象(或者对象的数组)。 | 编译器运行相应的构造函数以构造这些对象，并为其传入初始值。 | 对象被构造完成后，返回一个指向该对象的指针。 | . 对于delete和delete[ ]表达式，该操作有三个步骤： . | 对所给指针所指的对象或者数组中的元素执行对应的析构函数。 | 编译器调用名为operator delete(或者operator delete[ ])的标准库函数释放内存空间。 | . 所以我们可以看出来在使用new和delete相关表达式时，new和delete运算符函数在其中只是充当内存方面的操作，而其他操作是由编译器自动执行。 . 要注意new和delete运算符与new和delete运算符函数不是同一个操作： new和delete运算符函数只有内存方面的操作；而new和delete运算符既有内存方面的操作，又有对象方面的操作。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#63161-new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#63161-new和delete运算符工作原理"
  },"392": {
    "doc": "动态内存管理概念详解",
    "title": "6.3162 自定义new和delete运算符函数。",
    "content": "我们可以自定义new和delete的运算符函数。但是和其他运算符函数不同（比如operator=），这两个函数并没有重载new或delete运算符。实际上，我们根本无法自定义new或delete运算符的行为。 . 我们提供新的operator new函数和operator delete函数的目的在于改变内存分配的方式，但是不管怎样，我们都不能改变new运算符和delete运算符的基本含义。 . 当我们定义了new和delete的运算符函数时，编译器将使用我们自定义的版本替换标准库定义的版本。 . 可重载的运算符函数 . 不是所有的new和delete的运算符函数我们都可以重载，我们只能重载某些部分的运算符函数，以下是可重载的运算符函数的声明： . 标准库定义了operator new函数和operator delete函数的8个重载版本。其中前4个版本可能抛出bad_alloc异常，后4个版本则不会抛出异常。 . //这些版本可能抛出异常 void *operator new(size_t); void *operator new[](size_t); void operator delete(void*) noexcept; void operator delete[](void*) noexcept; //这些版本承诺不会抛出异常 void *operator new(size_t, nothrow_t&amp;) noexcept; void *operator new[](size_t, nothrow_t&amp;) noexcept; void operator delete(void*, nothrow_t&amp;) noexcept; void operator delete[](void*, nothrow_t&amp;) noexcept; . | 对于可重载的所有运算符函数来说： . | 类型nothrow_t是定义在new头文件中的一个struct,在这个类型中不包含任何成员。 new头文件还定义了一个类型为nothrow_t，名为nothrow的const对象，用户可以通过这个对象请求new的非抛出版本。 . | 当我们将上述运算符函数定义成类的成员时，它们是隐式静态的。我们无须显式地声明static，当然这么做也不会引发错误。 | . | 对于new运算符函数来说： . | 返回类型必须是void*，且第一个形参的类型必须是size_t且该形参不能含有默认实参。 当编译器调用operator new时，是把存储指定类型对象所需的字节数传给size_t形参；当调用operator new[]时，传给size_t形参的则是存储数组中所有元素所需的空间。 . | 我们可以为new运算符函数提供额外的多个形参，但是第一个额外的形参类型不能是void*。 此时，用到该函数的new表达式必须使用new的定位形式将实参传给额外形参。 . | . | 对于delete运算符函数来说： . | 返回类型必须是void，且第一个形参的类型必须是void*且该形参不能含有默认实参。 执行一条delete表达式将调用相应的operator函数，并用指向待释放内存的指针来初始化void*形参。 . | 我们可以为delete运算符函数提供额外的多个形参。 此时，用到该函数的delete表达式的形式和new的定位形式类似，用于将实参传给额外形参。 . | 当delete运算符函数定义成类的成员时，第一个额外的形参类型可以是size_t，此时，该形参的初始值是第一个形参所指对象的字节数，size_t形参可用于删除继承体系中的对象。 如果基类有一个虚析构函数，则传递给operator delete的字节数将因待删除指针所指对象的动态类型不同而有所区别。而且实际运行的operator delete函数版本也由对象的动态类型决定。 | 因为operator delete函数只是释放内存，基本不会抛出异常，所以当我们重载delete运算符函数时，需要使用noexcept异常说明符指定其不抛出异常。 | . | . 运算符函数的查找顺序 . 我们既可以在全局作用域和命名空间中定义operator new函数和operator delete函数，也可以将它们定义为成员函数。 . 当编译器发现一条new表达式或delete表达式后，将在程序中查找可供调用的operator函数，查找顺序为： . | 如果new和delete所指定的对象的类型及其该类型的基类里有成员函数版本的对应运算符函数，则优先调用成员函数版本。 | 如果没有成员函数版本，则比较其他可见版本的函数并匹配最优函数调用。 | . 我们可以使用作用域运算符显式指定new表达式或delete表达式中的运算符函数。例如，::new只在全局作用域中查找匹配的operator new函数， ::delete与之类似。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#63162-%E8%87%AA%E5%AE%9A%E4%B9%89new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#63162-自定义new和delete运算符函数"
  },"393": {
    "doc": "动态内存管理概念详解",
    "title": "6.4 RAII思想的管理方法",
    "content": "运用RAII思想的动态内存管理的方法是将内存的操作和对象的操作一起结合起来。 该方法模拟编译器在管理局部对象的操作。创建对象时自动分配内存，不需要用时自动执行销毁和内存释放操作，而无需手动操作。 . 运用RAII思想的动态内存管理的方法主要是运用智能指针。 . 接下来我们会主要介绍这几种智能指针： . | shared_ptr类 . | weak_ptr伴随类 | . | unique_ptr类 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#64-raii%E6%80%9D%E6%83%B3%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#64-raii思想的管理方法"
  },"394": {
    "doc": "动态内存管理概念详解",
    "title": "6.41 智能指针",
    "content": "智能指针类型都定义在memory头文件中。 . 标准库提供了叫做智能指针类型的类模板来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动销毁和释放所指向的对象。 . 其中提供了两大智能指针以及一个伴随类智能指针： . | shared_ptr类 . | weak_ptr伴随类 | . | unique_ptr类 | . 这两种智能指针的区别在于管理底层指针的方式： . | shared_ptr允许多个指针指向同一个对象。 | unique_ptr则“独占”所指向的对象。 | weak_ptr是一种弱引用，指向shared_ptr所管理的对象。 | . 除了weak_ptr类指针能被shared_ptr类指针拷贝和赋值以外，不同类型的智能指针之间不能拷贝和赋值。 但除了unique_ptr类指针以外，同类型的智能指针之间能拷贝和赋值。 . 所有智能指针都不能指向非动态分配的对象。 . 所有智能指针都不支持算术运算，但除了weak_ptr类指针，其他同类型的指针支持关系运算。 . 以下是shared_ptr和unique_ptr都支持的操作： . 支持的操作|解释 . |- shared_ptr&lt;T&gt; spunique_ptr&lt;T&gt; up | 空智能指针sp或up，可以指向类型为T的对象(当空智能指针为shared_ptr类时，该指针计数器为0) p|将智能指针p用作一个条件判断，若p指向一个对象，则为true p|解引用智能指针p,获得它指向的对象 p-&gt;mem|访问智能指针p所指向对象的成员等价于(p).mem p.get()|返回一个指向智能指针p所指对象的对应类型的指针。(不会引起p计数器的变化)要小心使用，因为此时智能指针仍有该对象的内存管理所有权。因此，若智能指针释放了其对象，返回的指针所指向的对象也就消失了。 swap(p,q) p.swap(q)|交换同类型的智能指针p和q中的保存的地址。(还会交换p和q中计数器的值、分配器以及删除器等) | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#641-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#641-智能指针"
  },"395": {
    "doc": "动态内存管理概念详解",
    "title": "6.411 shared_ptr类",
    "content": "因为智能指针也都是模板，所以当我们创建一个智能指针时，必须提供指针可以指向的类型。 . shared_ptr&lt;string&gt; pl; // shared_ptr，可以指向string shared_ptr&lt;list&lt;int&gt;&gt; p2; //shared_ptr,可以指向int的list . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6411-shared_ptr%E7%B1%BB",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6411-shared_ptr类"
  },"396": {
    "doc": "动态内存管理概念详解",
    "title": "6.4111 shared_ptr类的操作",
    "content": "以下是shared_ptr类独有的操作： . 支持的操作|解释 . |- make_shared&lt;T&gt; (args)|返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用实参表args初始化此对象。 如果args为空，则执行值初始化。 sharedptr&lt;T&gt; sp(sq/q) sharedptr&lt;T&gt; sp(q, d)|sq是非unique_ptr的智能指针；q只能是能够隐式转换为T类型的普通类型指针或空指针，且如果没有传递d，则必须保存的是动态内存；d是可调用对象。如果传递的是sq，则shared_ptr类型指针sp是sq的拷贝(先加1再拷贝，注意拷贝会将sp的分配器和删除器都设置为sq对应的)，且sq中的计数器会加1。 如果传递的是q，则指针sp保存q中的地址，并且sp的计数器设为1。 如果传递了d，则sp将用d来代替关联对象的清理工作。 sp.reset() sp.reset(q) sp.reset(q,d)|q只能是能够隐式转换为T类型的普通类型指针或空指针，且如果sp没有改变其清理方式，则必须保存的是动态内存；d是可调用对象。 不管调用的是哪种原型，首先，如果sp的计数器为0，则计数器不变；否则所有共享该指针所指的对象的指针(包括自己)的计数器都减1，如果减1后有任意一个共享该对象的指针的计数器为0，则对该对象执行清理工作。如果没有传递任何实参，则会将sp设为空智能指针。如果传递了q，则sp保存q中的地址，并且sp的计数器设为1。如果还传递了d，则sp将用d来代替关联对象的清理工作。 sp = sq|sp和sq必须都是shared_ptr，且其类型必须能相互隐式转换。 此操作会递减sp的引用计数(若sp的引用计数变为0, 则将对其管理的对象执行清理操作)，接着递増sq的引用计数，最后sp变为sq的拷贝（注意拷贝会将sp的分配器和删除器都设置为sq对应的）。 sp.use_count()|返回与shared_ptr指针sp共享对象的智能指针数量。 sp.unique()|若sp.use_count()为1，返回true；否则返回false。 | . 默认初始化的智能指针中保存着一个空指针，我们还可以用其他shared_ptr指针和保存动态内存的指针来初始化或重置shared_ptr指针。 . 默认情况下，shared_ptr假定它们指向的是动态内存，所以在没有自定义清理操作时，其他类型的指针必须保存的是动态内存的才行，否则出现未定义行为。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#64111-shared_ptr%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#64111-shared_ptr类的操作"
  },"397": {
    "doc": "动态内存管理概念详解",
    "title": "6.4112 计数器",
    "content": "我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数(reference count)。 . 引起shared_ptr的计数器变化的操作有两种： . | 当进行shared_ptr类之间的拷贝或赋值操作时。 | 当shared_ptr指针对象被销毁时。 . | 局部非静态shared_ptr指针对象离开其作用域时。 | 临时shared_ptr指针对象完成其表达式时。 | 动态分配的shared_ptr指针对象被销毁时。 | . | . 当进行shared_ptr类之间的拷贝或赋值操作时，计数器就会有变化，具体变化步骤为： 1. 对于拷贝或赋值到的指针来说：如果该指针的计数器为0，则计数器不变；否则所有共享该指针所指的对象的指针(包括自己)的计数器都减1，如果减1后有任意一个共享该对象的指针的计数器为0，则对该对象执行清理工作。 2. 对于用于拷贝或赋值的指针来说：将所有共享该指针所指的对象的指针(包括自己)的计数器都加1。 3. 最后将拷贝或赋值到的指针的地址和计数器的值修改为用于拷贝或赋值的指针的地址和计数器的值。 . 当shared_ptr指针对象被销毁时，和拷贝或赋值时一样： 如果该指针的计数器为0，则计数器不变；否则所有共享该指针所指的对象的指针(包括自己)的计数器都减1，如果减1后有任意一个共享该对象的指针的计数器为0，则对该对象执行清理工作。 . shared_ptr指针的清理操作只有在该指针的计数器为0时才执行。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#64112-%E8%AE%A1%E6%95%B0%E5%99%A8",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#64112-计数器"
  },"398": {
    "doc": "动态内存管理概念详解",
    "title": "6.412 智能指针的清理操作",
    "content": "清理操作是指先销毁对象，然后释放内存的组合操作。 . 对于shared_ptr类和unique_ptr类来说，它们都有着自己的清理其指向对象的操作。 shared_ptr指针和unique_ptr类的清理操作在默认情况下是都使用delete运算符来释放它所关联的对象。 . 我们也可以自定义一种可调用对象来修改某智能指针指针的清理操作，用于智能指针的清理操作的可调用对象也叫做删除器。 . 用于删除器的可调用对象必须要满足以下条件： . | 可调用对象的形参表的形参数量必须不小于1。 | 形参表的第一个形参必须为智能指针所指定类型的指针，或者能隐式转换成所指定类型的指针。 | 可调用对象的形参表如果还有其他形参，则这些形参必须都有默认实参。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6412-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E6%B8%85%E7%90%86%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6412-智能指针的清理操作"
  },"399": {
    "doc": "动态内存管理概念详解",
    "title": "6.413 weak_ptr伴随类",
    "content": "weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的计数器。 . 一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放，因此，weak_ptr的名字抓住了这种智能指针“弱”共享对象的特点。 . 以下是weak_ptr所支持的操作： . 我们只能用shared_ptr或者weak_ptr指针来拷贝和赋值weak_ptr的指针。 . 不能用除了shared_ptr和weak_ptr的其他类型指针来拷贝和赋值weak_ptr的指针，否则会出错。 . auto p = make_shared&lt;int&gt;(42); weak_ptr&lt;int&gt; wp (p) ; // wp弱共享p; p的引用计数未改变 . 由于对象可能不存在，我们不要使用weak_ptr直接访问对象，最好调用lock函数，此函数检查weak_ptr指向的对象是否仍存在。如果存在，lock函数返回一个指向共享对象的shared_ptr；否则返回一个空shared_ptr指针。 . // 在这段代码中，\\ 只有当lock调用返回true时\\ 我们才会进入if语句体。\\ 在if中，使用np访问共享对象是安全的。 if (shared_ptr&lt;int&gt; np = wp.lock()) //如果np不为空则条件成立 { //在if中，np与p共享对象 } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6413-weak_ptr%E4%BC%B4%E9%9A%8F%E7%B1%BB",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6413-weak_ptr伴随类"
  },"400": {
    "doc": "动态内存管理概念详解",
    "title": "6.414 unique_ptr类",
    "content": "一个unique_ptr“拥有”它所指向的对象。 与shared_ptr不同，某个时刻只能有一个unique_ptr指针指向一个给定对象。当某个unique_ptr指针被销毁时，它所指向的对象也会被清理。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6414-unique_ptr%E7%B1%BB",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6414-unique_ptr类"
  },"401": {
    "doc": "动态内存管理概念详解",
    "title": "6.4141 unique_ptr类所支持的操作",
    "content": "以下是unique_ptr类独有的操作。 . 支持的操作|解释 . |- unique_ptr&lt;T&gt; up(q) unique_ptr&lt;T, D&gt; up(d) unique_ptr&lt;T, D&gt; up(q, d)|q只能是能够隐式转换为T类型的普通类型指针或空指针，且如果没有传递d，则必须保存的是动态内存；D是可调用对象的类型；d是D类型对应的可调用对象。如果传递了q，则up保存q中的地址；否则up为空unique_ptr。如果指定了D，传递了d，则将用d来代替关联对象的清理工作；否则用delete运算符来进行清理工作。 (第二和第三种形式中，D和d缺一不可，不能只有其中一个) up.reset() up.reset(nullptr) up.reset(q)|q只能是能够隐式转换为T类型的普通类型指针或空指针，且如果up没有改变其清理方式，则必须保存的是动态内存；d是可调用对象。 清理up所指向的对象 如果没有传递任何实参或者只传递空指针，则会将up设为空智能指针。如果传递了q，则up保存q中的地址。 up = nptr|nptr必须是空指针(不能是空智能指针)。 清理up所指向的对象，并将up设为空智能指针。 up.release()|返回一个指向指针up所指对象的对应类型的指针，并将up设为空智能指针。 此操作是指针up放弃对该对象的内存管理所有权，所以不会再执行该对象的清理工作。 | . 我们只能用保存动态内存的普通指针来拷贝unique_ptr指针。 . 默认情况下，unique_ptr假定它们指向的是动态内存，所以在没有自定义清理操作时，其他类型的指针必须保存的是动态内存的才行，否则出现未定义行为。 . 向unique_ptr传递的删除器必须要在尖括号中unique_ptr指向类型之后指定删除器类型，且提供的可调用对象也必须是指定的类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#64141-unique_ptr%E7%B1%BB%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#64141-unique_ptr类所支持的操作"
  },"402": {
    "doc": "动态内存管理概念详解",
    "title": "6.415 智能指针的动态数组",
    "content": "对于shared_ptr和unique_ptr类，标准库都提供了一个可以分配动态内存对象的数组的版本，为了用一个智能指针来管理动态数组，我们必须在对象类型后面跟一对空方括号(也就是&lt;类型(可选 类型修饰符)[ ]&gt;)。 . // sp和up分别指向一个包含10个未初始化int的数组 shared_ptr&lt;int[]&gt; sp(new int[5]); unique_ptr&lt;int[]&gt; up(new int[10]); //自动用delete []销毁其指针 sp.reset(); up.release(); . 当一个智能指针指向一个数组时，我们不能使用点和箭头成员运算符。毕竟智能指针指向的是一个数组而不是单个对象，因此这些运算符是无意义的。另外，当一个智能指针指向一个数组时，我们可以使用下标运算符来访问数组中的元素。 . 以下是指向动态数组的shared_ptr和unique_ptr类所特有的操作。除了不能使用点和箭头成员运算符，shared_ptr和unique_ptr类所拥有的其他操作不变。 . | 支持的操作 | 解释 | . | unique_ptr&lt;T[ ]&gt; up shared_ptr&lt;T[ ]&gt; sp | sp或up可以指向一个动态分配的数组，数组元素类型为T。 | . | unique_ptr&lt;T[ ]&gt; up(q) shared_ptr&lt;T[ ]&gt; sp(q) | q只能是能够隐式转换为T*类型的指向一个动态分配的数组的指针动态内存sp或up指向指针q所指向的动态分配的数组。 | . | up[i]/sp[i] | up或sp必须指向一个数组。 返回up或sp所拥有的数组中位置i处的对象的引用。 | . 智能指针来清理动态数组对象的默认操作为delete[ ]表达式，所以自定义管理动态数组的智能指针的删除器时要注意对应的形参类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6415-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#6415-智能指针的动态数组"
  },"403": {
    "doc": "动态内存管理概念详解",
    "title": "动态内存管理概念详解",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html",
    
    "relUrl": "/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"
  },"404": {
    "doc": "第七章 类",
    "title": "第七章 类",
    "content": "第7章先介绍了类类型的概念与结构，然后依次介绍了类的各种成员，最后详细介绍了类的访问控制、继承、拷贝控制以及类类型转换等各种特性。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/index.html",
    
    "relUrl": "/guide_files/chap7/index.html"
  },"405": {
    "doc": "类概念详解",
    "title": "7.1 类的概念",
    "content": "我们之前都接触过类，类就是类型，我们所有的变量都有一个类型属性，这章的类是介绍我们怎么定义和使用自己所属的类型。 . 类是编程范式之一的面向对象程序设计(object-oriented programming)中最基础也是最重要的一种设计模式。 . 面向对象程序设计的核心思想是 . | 数据抽象 | 继承 | 动态绑定(多态性) | . 使用数据抽象，我们可以将类的接口与实现分离。 使用继承，可以定义相似的类型并对其相似关系建模。 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。 . 其中，类最基本的思想是 . | 数据抽象（data abstraction） | 封装（encapsulation）。 | . 数据抽象是一种依赖于以下这两个部分分离的编程（以及设计）技术。： . | 接口（interface） | 实现（implementation） | . 类的接口包括用户所能执行的操作。 类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数和其他类。 . 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。 . 所以为了实现数据抽象和封装，需要首先定义一个抽象数据类型（abstract data type），这里所说的抽象数据类型也就是我们自定义的类型，也就是类类型。 . 在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#71-%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#71-类的概念"
  },"406": {
    "doc": "类概念详解",
    "title": "7.2 类的定义和声明",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#72-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#72-类的定义和声明"
  },"407": {
    "doc": "类概念详解",
    "title": "7.21 类的定义",
    "content": "类的定义有两种形式： . | 类关键字 类名 (可选 类派生列表) 类体; . | 类关键字 (可选 类名) (可选 类派生列表) 类体 类对象列表; . | . 第二种形式是类的定义与类对象的定义的结合形式。 类对象列表是由多个逗号分隔的对象名组成的复杂表达式，表示该类多个对象的定义。 第二种形式中，类名可以省略，但是如果省略后，该类必须要有类对象列表，不能定义一个无意义的无名类。而且省略类名的类之后就不能再定义该类的对象了。 . 类不是对象，所以类的定义中不能加各种类型修饰符和存储说明符。 . 每个类定义了唯一的类型。对于两个不同类名的类来说，即使它们类体里的代码完全一样，这两个类也是两个不同的类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#721-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#721-类的定义"
  },"408": {
    "doc": "类概念详解",
    "title": "7.211 类定义各部分的介绍",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7211-%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%90%84%E9%83%A8%E5%88%86%E7%9A%84%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7211-类定义各部分的介绍"
  },"409": {
    "doc": "类概念详解",
    "title": "7.2111 类关键字",
    "content": "类关键字可以是关键字struct或者class，类关键字的区别在于对类体中成员的默认访问权限。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#72111-%E7%B1%BB%E5%85%B3%E9%94%AE%E5%AD%97",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#72111-类关键字"
  },"410": {
    "doc": "类概念详解",
    "title": "7.2112 类名",
    "content": "类名指的是该定义的类型的类型名，同一作用域中，不能有相同的类名。类名可以与其他变量名相同，但是之后该类就不能再定义自己的对象了(会被同名的变量所覆盖)。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#72112-%E7%B1%BB%E5%90%8D",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#72112-类名"
  },"411": {
    "doc": "类概念详解",
    "title": "7.2113 类派生列表",
    "content": "类派生列表(class derivation list)是用于类继承中的，表示该类所要继承的类。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#72113-%E7%B1%BB%E6%B4%BE%E7%94%9F%E5%88%97%E8%A1%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#72113-类派生列表"
  },"412": {
    "doc": "类概念详解",
    "title": "7.21131 继承简述",
    "content": "通过继承(inheritance)联系在一起的类构成一种层次关系。 通常在层次关系的根部有一个基类(base class)，其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类(derived class)。 一般来说，基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。 . 注意：被继承的类只能是类类型，不能是系统内置的类型（包括基本类型，复合类型、枚举、共用体等类型）。 . 一个类可以同时继承任意多个直接基类，这也叫作多重继承(multiple inheritance)，多重继承的派生类继承了所有父类的属性。 . 通常情况，一个派生类会继承其每个直接基类的所有成员(包括直接基类所定义的类和类型别名)，不存在只继承一部分这种行为。 . 派生类继承的成员也就是指在该派生类中包含这个继承成员的一个副本，这个副本与其原成员一模一样(也就是包含其原成员的各种限定符和说明符以及初始值和函数体内容等所有的代码) . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#721131-%E7%BB%A7%E6%89%BF%E7%AE%80%E8%BF%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#721131-继承简述"
  },"413": {
    "doc": "类概念详解",
    "title": "7.21132 类派生列表的形式",
    "content": "类派生列表是指定义一个类时，该类所要继承的所有类的一个说明列表，所有需要继承的类必须要在该列表中出现。 类派生列表的形式为： . : (可选 virtual) (可选 访问说明符) 类名1, (可选 访问说明符) (可选 virtual) 类名2, (可选 virtual) (可选 访问说明符) 类名3, ··· . 一个类派生列表的类可以有多个，其中每个类前可以加访问说明符和关键字virtual(这两个的顺序可以任意)，以表示定义的类对于该类的继承方式。 . 类派生列表里的每个类必须都要有定义，否则不能在类派生列表中使用。 . 一个类派生列表中不能有相同的类。 但是一个类可能会多次继承同一个类的成员。比如其有多个直接基类继承了同一个类，导致该类多次继承了这个类。 . 每个基类的继承方式中的访问说明符是用来控制该派生类对其继承成员的访问权限；关键字virtual是决定这个基类的该派生类的派生类是否会多次继承这个基类的成员。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#721132-%E7%B1%BB%E6%B4%BE%E7%94%9F%E5%88%97%E8%A1%A8%E7%9A%84%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#721132-类派生列表的形式"
  },"414": {
    "doc": "类概念详解",
    "title": "7.21133 按继承关系的类分类",
    "content": "按照继承关系，所有的类都可以分为两种： . | 基类 . | 直接基类 | 间接基类 | . | 派生类 . | 直接派生类 | 间接派生类 | . | . 基类 . 在一个类的定义中，类派生列表中所出现的所有的类被称为这个定义类的基类，且派生列表中所出现的每个类的基类以及这个基类的基类，一直到继承关系的源头的类，都被称为这个定义类的基类。 . 在一个定义类所有的基类中，出现在定义类的类派生列表中的类为该定义类的直接基类(direct base)；其他的基类都为该定义类的间接基类(indirect base)。 . 派生类 . 一个定义类的基类都把这个定义类称为自己的派生类。 . 其中定义类的直接基类都称该定义类为自己的直接派生类；而定义类的其他基类都称该定义类为自己的间接派生类。 . /* Base没有基类；有3个派生类，为Deri, Deri1, Deri2； 其中，直接派生类为Deri, Deri1。*/ class Base {}; /* Base1没有基类；有1个派生类，为Deri2； 其中，直接派生类为Deri2。*/ struct Base1 {}; /* Deri有1个基类，为Base；有2个派生类，为Deri1, Deri2； 其中，直接基类为Base；直接派生类为Deri1, Deri2。*/ struct Deri: private Base {}; /* Deri1有2个基类，为Base, Deri；有1个派生类，为Deri1； 其中，直接基类为Base, Deri；直接派生类为Deri1。*/ class Deri1: public virtual Base, virtual protected Deri {}; /* Deri2有3个基类，为Deri, Base1, Deri1；没有派生类； 其中，直接基类为Deri, Base1, Deri1。*/ struct Deri2: Deri, virtual Base1, Deri1 {}; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#721133-%E6%8C%89%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E7%B1%BB%E5%88%86%E7%B1%BB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#721133-按继承关系的类分类"
  },"415": {
    "doc": "类概念详解",
    "title": "7.2114 类体",
    "content": "类体是一个复合语句，类体中可以包含多种代码，但这些代码必须为下列形式的才行，否则会定义出错。 . | 对象(包括函数)、类或者模板的声明或定义语句(包括类型别名的定义)。 对象(包括函数)、类或者模板的声明或定义语句(包括类型别名的定义)说明了这些实体都为该类的成员。 | 访问说明符。 访问说明符是用来决定该类对象对于其中成员的访问权限的。 | 友元声明语句。 友元声明语句是用来说明非该类成员的函数或类对于该类成员的访问权限的。 | using声明语句。 详见using声明语句 | static_assert声明语句(since c++11)。 | 类模板自动推导(since c++17)。 | using枚举对象声明语句(since c++20)。 | . 其中对象(包括函数)的定义语句不能用auto类型来定义。 . // 类Cls，包含一个int类数据成员和一个类Lo。 struct Cls { int cls_ins; using Lo = long; }; /* 类Cls2，包含一个访问说明符、 一个double类数据成员 、一个函数成员和 一个类Dou。 并定义了该类的两个对象ob1, ob2*/ class Cls2 { public: double cls2_dou = 8; void cls2_f(); typedef double Dou; } ob1, ob2; /* 一个未命名的类， 包含一个友元类声明， 一个访问说明符、 、一个函数成员和 一个类Subcls。 定义了该类的两个对象ob3, ob4*/ struct { friend class Cls; private: void cls_f(){} class Subcls {}; } ob3, ob4; /* 一个未命名的派生类， 继承于类Cls, Cls2。 包含所有继承类的所有成员和一个访问说明符。 并定义了该类对象ob5*/ class :Cls, Cls2 { friend void Cls2::cls2_f(); protected: } ob5; /* 派生类Decls， 继承于类Cls2。 包含所有继承类的所有成员。*/ class Decls: Cls2 {}; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#72114-%E7%B1%BB%E4%BD%93",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#72114-类体"
  },"416": {
    "doc": "类概念详解",
    "title": "7.22 类的声明",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#722-%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#722-类的声明"
  },"417": {
    "doc": "类概念详解",
    "title": "7.221 类的声明形式",
    "content": "就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它。 类的声明形式和定义类似，只不过不用包含类体和类派生列表。 . 类关键字 类名; . class Screen; // Screen类的声明 . 一个类声明中的类关键字可以与该类定义中的类关键字不同，但是该类还是以其定义中的类关键字为主。也就是当一个类的声明与定义中的类关键字不一致，则按类的定义来。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7221-%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7221-类的声明形式"
  },"418": {
    "doc": "类概念详解",
    "title": "7.222 不完全类型",
    "content": "这种声明有时被称作前向声明（forward declaration），它向程序中引入了类的标识符并且指明这个标识符是一种类类型。 对于该类型来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知它是一个类类型，但是不清楚它到底包含哪些成员。 . 要注意在某作用域不可见的类或既没定义也没声明的类在该作用域中不属于不完全类型，而属于不存在的类型，不存在的类型是根本无法使用的。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7222-%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7222-不完全类型"
  },"419": {
    "doc": "类概念详解",
    "title": "7.2221 不完全类型的使用",
    "content": "一个不完全类型的类型只能在以下几种情形使用，其他的情形一律不合法： . | 可以定义指向这种类型的指针或引用。 | 可以声明（但是不能定义）以不完全类型为类型的变量。 | 可以声明（但是不能定义）以不完全类型作为形参或者返回类型的函数。 | 可以声明（但是不能定义）以不完全类型为类型的静态数据成员。 | 可以当作友元用于友元声明。 | 可以用于定义该类的类型别名。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#72221-%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#72221-不完全类型的使用"
  },"420": {
    "doc": "类概念详解",
    "title": "7.3 类以及类对象成员的使用简述",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#73-%E7%B1%BB%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AE%80%E8%BF%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#73-类以及类对象成员的使用简述"
  },"421": {
    "doc": "类概念详解",
    "title": "7.31 类的使用",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#731-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#731-类的使用"
  },"422": {
    "doc": "类概念详解",
    "title": "7.311 类对象的创建",
    "content": "类就像普通的类型一样，可以用于定义或声明该类的对象，定义或声明类对象的形式有三种： . | 类的定义 类对象名1 (可选 初始化), 类对象名2 (可选 初始化), ···; | (可选 存储说明符) class/struct 类名(可含类型修饰符) 类对象名 (可选 初始化); | (可选 存储说明符) 类名(可含类型修饰符) 类对象名 (可选 初始化); | . 第一种形式就是之前所描述的在定义时创建类对象； 第二种形式就是在类对象定义前加关键字class或者struct(这两个效果一样)； 第三种形式和普通类型的对象定义形式一样。 . // 类定义时创建类对象ob1, ob2 struct Cls {} ob1, ob2; // 加关键字创建类对象ob3, ob4 class Cls ob3; struct Cls ob4; // 普通创建类对象ob3, ob4 Cls ob5; . 类对象的初始化就是调用类的构造函数来进行初始化工作，类对象的初始化形式有多种，具体形式以及调用规则详见7.313 类对象的初始化。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7311-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7311-类对象的创建"
  },"423": {
    "doc": "类概念详解",
    "title": "7.312 类的调用",
    "content": "C++中的几乎所有类型(包括内置类型、类类型，共用体类型等)都支持类似于函数调用形式的使用，也就是将类当做函数，后面跟着圆括号包围的实参表，类的调用其实是隐式调用该类的构造函数，然后返回一个临时的该类对象。所以可以根据实参的不同调用相应的该类构造函数。 形式为: . 类名 (实参表)/{实参表}; . 和函数不一样的是，类调用的实参表可以用花括号包含起来。 . // 调用int类型创建了一个值为5的int类临时对象并拷贝给inte int inte = int{5}; // 调用string类型创建了一个值为strings的string类临时对象并拷贝给str string str = string(\"strings\"); // 调用vector&lt;int&gt;类型创建了一个元素数为5的vector&lt;int&gt;类临时对象并拷贝给v1 vector&lt;int&gt; v1 = vector&lt;int&gt;{8,9,3,6,4}; // 一个含有多个构造函数的类Cls struct Cls { int ins; string str; double dou; Cls(int ins, string str, double dou): ins(ins), str(str), dou(dou) {} Cls(int ins): Cls(ins, \"\", 5.5) {} Cls(string str): Cls(3, str, 5.5) {} }; // 调用Cls(int, string, double) Cls obj = Cls{3,\"str\", 8.8}; // 调用Cls(int) Cls obj2 = Cls{3}; // 调用Cls(string) Cls obj3 = Cls(\"string\"); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7312-%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7312-类的调用"
  },"424": {
    "doc": "类概念详解",
    "title": "7.313 类对象的初始化",
    "content": "类对象和普通的对象一样，有着直接初始化和拷贝初始化这两种初始化形式。之前我们说过直接初始化和拷贝初始化的形式的区别，简单来说，就是所有不用赋值运算符的初始化都是直接初始化。 . 对于类对象的直接初始化和拷贝初始化，它们的区别也就在与它们之间的工作原理： . | 直接初始化： 当使用直接初始化时，我们实际上是要求编译器使用类似于普通函数匹配的方式，來选择与我们所提供的参数最匹配的构造函数。所以直接初始化时，所有构造函数都会是候选函数(包括拷贝和移动构造函数)。 类对象的直接初始化的形式和上面的类的调用相似，形式为： (可选 存储说明符) 类名(可含类型修饰符) 类对象名 (实参表)/{实参表}; . // 一个含有多个构造函数的类Cls struct Cls { int ins; string str; double dou; Cls(int ins, string str, double dou): ins(ins), str(str), dou(dou) {} Cls(int ins): Cls(ins, \"\", 5.5) {} Cls(string str): Cls(3, str, 5.5) {} Cls():ins(3), str(\"default\"), dou(2.4) {} }; // 调用Cls(int, string, double) Cls obj{3,\"str\", 8.8}; // 调用Cls(int) Cls obj2{3}; // 调用Cls(string) Cls obj3(\"string\"); // 调用Cls() Cls obj4; . 要注意，当需要类的默认构造函数来初始化类对象时，该类对象不能用空园括号()来初始化，会被编译器误认为为函数声明，而出错。可以使用空花括号{}以及不加括号来调用默认构造函数。 这种错误也会在调用其他构造函数时嵌套使用空园括号()初始化时发生，因此类对象的直接初始化最好使用花括号{}来进行，以免存在潜在错误。 . // 一个含有多个构造函数的类Cls using namespace std; struct Cls { int ins; string str; double dou; Cls(int ins, string str, double dou): ins(ins), str(str), dou(dou) {} Cls(int ins): Cls(ins, \"\", 5.5) {} Cls(string str): Cls(3, str, 5.5) {} Cls():ins(3), str(\"default\"), dou(2.4) {} }; // 正确，调用默认构造函数Cls() Cls obj{}; // 正确，调用默认构造函数Cls() Cls obj2; // 错误，该语句会被认为为函数声明Cls()，而不是类对象的初始化。 Cls obj3(); // 错误，该语句会被认为为函数声明Cls(string)，而不是类对象的初始化。 Cls obj4(string()); . | 拷贝初始化： 当我们使用拷贝初始化时，我们是要求编译器将右侧的同类型运算对象拷贝到正在创建的对象中；如果右侧运算对象不是同类型的对象，则还要对其进行类型转换(其中可能会用到转换构造函数来执行转换)。 对于拷贝初始化，编译器会根据所要拷贝的初始值的左右值属性来决定应该调用拷贝还是移动构造函数，还有可能会跳过拷贝或者移动构造函数直接创建。 拷贝初始化只会调用拷贝或者移动构造函数，不会调用其他的构造函数。 . | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7313-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7313-类对象的初始化"
  },"425": {
    "doc": "类概念详解",
    "title": "7.32 类对象成员的使用",
    "content": "对于一个类来说，当我们在该类定义外想访问其成员，有两种访问方式： . | 我们可以通过该类对象、该类对象的引用或指针，用成员访问运算符来访问该类的所有可访问的数据和非构造函数成员。 | 我们可以通过作用域运算符来访问该类的所有可访问的静态成员、类成员和构造函数。 | . 当访问对象是重载函数时，遵循重载的调用规则。 访问的构造函数的调用就和类的调用一样，返回一个临时的该类对象。 . struct Cls { int ins; string str; double dou; typedef const int cint; struct Sub {}; Cls(int ins, string str, double dou): ins(ins), str(str), dou(dou) {} Cls(int ins = 8): Cls(ins, \"\", 5.5) {} Cls(string str): Cls(3, str, 5.5) {} ~Cls() {}; }; // 创建一个Cls类的对象 Cls obj; // 调用obj的ins成员 cout &lt;&lt; obj.ins; // 创建一个Cls类的类类型成员Sub的对象 Cls::Sub sub_obj = Cls::Sub(); // 创建一个Cls类的类类型成员cint的对象 const int c_ins = Cls::cint(9); // 创建一个Cls类对象 Cls obj2 = Cls::Cls(3,\"str\",1.3); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#732-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#732-类对象成员的使用"
  },"426": {
    "doc": "类概念详解",
    "title": "7.4 类成员",
    "content": "所有在类中声明或定义的对象(包括函数)或类都是该类的成员，一个类的对象包含该类的所有成员，我们可以通过类或者类对象来对其成员进行操作。 一般来说，类成员的值由包含该成员的类对象决定。 无论是什么类型的访问控制，一个类的所有非继承成员之间都能有权限互相访问。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74-%E7%B1%BB%E6%88%90%E5%91%98",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74-类成员"
  },"427": {
    "doc": "类概念详解",
    "title": "7.41 类成员分类",
    "content": "一个类的成员按类型可以分为三种： . | 数据成员 . | 非静态数据成员 . | 可变数据成员 | . | 静态数据成员 | . | 函数成员 . | 非静态函数成员 . | 虚函数 | . | 静态函数成员 | 构造函数 | 析构函数 | . | 类类型成员 . | 嵌套类 | 类型别名 | . | 模板成员 | . 数据成员指的是非函数的变量(可以是常量，引用等各种类型的变量)。 函数成员就是函数。 类类型成员指的是类类型或者是类型别名。 模板成员就是指为模板的成员，我们之后会在模板那一章介绍模板成员。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#741-%E7%B1%BB%E6%88%90%E5%91%98%E5%88%86%E7%B1%BB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#741-类成员分类"
  },"428": {
    "doc": "类概念详解",
    "title": "7.42 静态成员的概念",
    "content": "所有的成员都不能用除了static外的存储说明符(类类型成员也是类，所以不能用任何的存储说明符)。根据成员是否有static，所有成员可以分为： . | 非静态成员 | 静态成员 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#742-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E6%A6%82%E5%BF%B5",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#742-静态成员的概念"
  },"429": {
    "doc": "类概念详解",
    "title": "7.421 非静态成员介绍",
    "content": "非静态成员就是其声明或定义语句中没有static说明符的成员。 . 所有的非静态成员是与包含该成员的类对象相关联的，其值也是由该对象决定的。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7421-%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7421-非静态成员介绍"
  },"430": {
    "doc": "类概念详解",
    "title": "7.422 静态成员介绍",
    "content": "静态成员是指其声明或定义语句中含有static说明符的成员。 . 所有的静态成员是与该类相关联的，而不是与类对象关联；静态成员的值是由定义类时对应定义语句中所给的初始值决定的。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7422-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7422-静态成员介绍"
  },"431": {
    "doc": "类概念详解",
    "title": "7.423 非静态与静态成员的访问方式",
    "content": "非静态成员 . 当非静态成员作为访问者时： . | 直接访问：其所属类的所有成员(包括自己)。 | 间接访问：其所属类的所有成员(包括自己)： . | 通过所属类对象访问。 | 通过作用域运算符访问。 | . | . 当非静态成员作为被访问者时： . | 直接被访问：其所属类的所有非静态成员(包括自己)。 | 间接被访问： . | 其所属类的所有非静态成员(包括自己)： . | 通过所属类对象被访问。 | 通过作用域运算符被访问。 | . | 其所属类的所有静态成员： . | 通过所属类对象被访问。 | . | . | . 静态成员 . 当静态成员作为访问者时： . | 直接访问：其所属类的所有静态成员(包括自己)。 | 间接访问： . | 其所属类的所有静态成员(包括自己)： . | 通过所属类对象被访问。 | 通过作用域运算符被访问。 | . | 其所属类的所有非静态成员： . | 通过所属类对象被访问。 | . | . | . 当静态成员作为被访问者时： . | 直接被访问：其所属类的所有成员(包括自己)。 | 间接被访问：所有对象(包括自己)： . | 通过所属类对象被访问。 | 通过作用域运算符被访问。 | . | . struct Cls { // 类对象 static Cls classObj; // 非静态数据成员 int inte{35}; // 非静态函数成员 int getInt() { return 31; } // 静态数据成员 static const int inte_st = 17; // 静态函数成员 static int getInt_st() { return 39; } // 非静态成员被非静态成员访问 int nostaticDataAccessed_viaDirectly_byNostaticData = inte * 2; void nostaticDataAccessed_viaClassObject_byNostaticFunc() { Cls clsObj; int obj{clsObj.inte*3}; } int nostaticFuncAccessed_viaOperScope_byNostaticData = Cls::getInt() * 4; // 静态成员被非静态成员访问 void staticDataAccessed_viaDirectly_byNostaticFunc() { int obj{inte_st*2}; } int staticFuncAccessed_viaClassObject_byNostaticData = classObj.getInt_st() * 3; void staticFuncAccessed_viaOperScope_byNostaticFunc() { int obj{Cls::getInt_st()*4}; } // 非静态成员被静态成员访问 static int nostaticDataAccessed_viaClassObject_byStaticData; static void nostaticFuncAccessed_viaClassObject_byStaticFunc() { Cls clsObj; int obj{clsObj.getInt()*4}; } // 静态成员被静态成员访问 static void staticFuncAccessed_viaDirectly_byStaticFunc() { int obj{getInt_st()*2}; } static int staticFuncAccessed_viaClassObject_byStaticData; static void staticDataAccessed_viaOperScope_byStaticFunc() { int obj{Cls::inte_st*4}; } }; Cls Cls::classObj{}; int Cls::nostaticDataAccessed_viaClassObject_byStaticData{classObj.inte*2}; int Cls::staticFuncAccessed_viaClassObject_byStaticData{classObj.getInt_st()*3}; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7423-%E9%9D%9E%E9%9D%99%E6%80%81%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7423-非静态与静态成员的访问方式"
  },"432": {
    "doc": "类概念详解",
    "title": "7.43 类成员的声明与定义",
    "content": "除了非静态数据成员和静态constexpr数据成员，所有的成员既可以在类内定义，也可以在类外定义，不过如果在类外定义，则该成员必须要在类内声明过。 . 在类外进行的成员声明或定义语句时，要注意要在成员名之前加上所属类类名和作用域运算符，也就是类名::成员名，以表示是对类成员的声明或定义。 . 对于构造函数和析构函数来说，因为其成员名就是类名，所以在类外定义就是类名::类名或者类名::~类名。 . 要注意在类外定义的函数成员要与其类内的声明严格一致(函数名、返回类型、每个形参类型都要相同(顶层const可省略，有无顶层const按照定义的来)，包括各种类型修饰符都要一致)，否则就会编译出错。 . struct Cls { // 静态数据成员const int类内定义 static const int ins = 18; // 静态数据成员类内声明 static const float flo; // 静态数据成员constexpr类内定义（只能在类内定义） static constexpr double sta_dou = -48.35; // 静态数据成员类内声明 static double dou; // 非静态函数成员类内声明 int add(int val, int val2); // 静态函数成员类内声明 static void prints(); }; // 正确的静态数据成员定义 const float Cls::flo = 48.5; // 错误定义：没有类名和作用域运算符，该定义语句不是类成员的定义。 double dou = 7.6; // 正确的静态数据成员定义 double Cls::dou = 7.6; // 错误定义：没有类名和作用域运算符，该定义语句不是类成员的定义。 int add(int val, int val2) {}; // 正确的非静态函数成员定义 int Cls::add(int val, int val2) {}; // 正确的静态函数成员定义 void Cls::prints() {} . static说明符只能在类内的声明或定义语句中出现。 所以静态成员的类外声明或定义语句中，除了不能有static，其他的和正常声明以及定义形式一样。 . struct Cls { static void prints(); static double dou; }; // 错误：static不能在类外。 static void Cls::prints() {}; static double Cls::dou = 78.6; // 正确 void Cls::prints() {}; double Cls::dou = 78.6; . 除了静态非constexpr数据成员可以在类外定义，其他的数据成员都不能在类外定义。 . 对于所有成员来说，类外和类内之间不能有重复定义。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#743-%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#743-类成员的声明与定义"
  },"433": {
    "doc": "类概念详解",
    "title": "7.44 数据成员介绍",
    "content": "根据成员是否有static，数据成员分为两种： . | 非静态数据成员 | 静态数据成员 | . 注意：非静态数据成员不能为constexpr类型，否则编译器报错 . 对于非静态数据成员和静态constexpr数据成员来说，只能在类内定义； 而除了静态constexpr数据成员，其他静态数据成员类内类外都能定义，但大多数都在类外定义。 . 能在类内定义的静态数据成员必须是以下几种形式，其他的静态数据成员都不能在类内定义： . | const int类型，且初始值必须为常量表达式。 | constexpr类型，且初始值必须为常量表达式。 | 被inline修饰的任何类型，此时初始值可以是任意表达式。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#744-%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#744-数据成员介绍"
  },"434": {
    "doc": "类概念详解",
    "title": "7.441 数据成员初始化流程",
    "content": "在介绍数据成员初始化流程之前，我们需要了解两个概念： . | 类内初始值 类内初始值是指在数据成员定义语句中的初始值。类内初始值不能用有圆括号的直接初始化形式，但可以用其他形式的初始化。 一个数据成员的类内初始值可以是含有该成员所属的类成员的表达式，只要其结果能隐式转换成对应被初始化数据成员的类型。 但要注意类内初始值不能为以下成员，否则会出现未定义行为： . | 自身。 | 在自身初始化之后才初始化的其他数据成员。 | . | 构造函数 构造函数是指某些特殊的成员函数，这些函数都有一个特殊的初始值列表。 这些成员函数的任务是初始化类对象的所有非静态数据成员。 构造函数的调用是自动的，无论何时，只要类的对象被创建，就会执行该类构造函数。 | . 数据成员的初始化流程分为两步： . | 静态数据成员初始化过程。 | 构造函数初始化过程(只有非静态数据成员才有)。 | . | 静态数据成员初始化过程： 这个过程是发生在类的定义过程中的。 只对所有静态数据成员进行初始化。 . 首先，按照每个静态数据成员定义语句的先后顺序，根据其定义语句中的类内初始值，先对定义在类内的成员进行初始化，再对定义在类外的初始化。 对于没有类内初始值的成员，则不初始化，只当作声明(所以没有类内初始值的静态数据成员，是不能使用的)。 . | 构造函数初始化过程： 这个过程是发生在类对象的定义过程中的。 只对所有非静态数据成员进行初始化。 . 这个过程就是执行类对象定义时匹配的构造函数。在执行该构造函数的过程中，按照每个非静态数据成员在类中定义的出现顺序，从先到后，逐个对每个非静态数据成员都执行初始化。 具体来说，当初始化一个非静态数据成员时，如果该成员是在该构造函数的初始值列表中出现的成员，则用其后面紧跟的括号里的表达式的值来初始化该成员；否则用该成员的类内初始值来初始化；如果类内初始值也没有，则执行默认初始化，如果该成员连默认初始化都不行，则编译出错。 . | . // 定义了各种拷贝控制成员的类Te struct Te { int ins; static string sta_str; string str; Te(int ins = 18, string str = \"Te_str\"): ins(ins), str(str) { cout &lt;&lt; ins &lt;&lt; \" constructed!\\n\"; } Te(const Te&amp; copy_obj): ins(copy_obj.ins), str(copy_obj.str) { cout &lt;&lt; ins &lt;&lt; \" copyed constructed!\\n\"; } Te(const Te&amp;&amp; copy_obj): ins(copy_obj.ins), str(copy_obj.str) { cout &lt;&lt; ins &lt;&lt; \" moved constructed!\\n\"; } Te&amp; operator=(const Te&amp; copy_obj) { ins = copy_obj.ins; str = copy_obj.str; cout &lt;&lt; ins &lt;&lt; \" copyed operated!\\n\"; return *this; }; Te&amp; operator=(const Te&amp;&amp; move_obj) { ins = move_obj.ins; str = move_obj.str; cout &lt;&lt; ins &lt;&lt; \" moved operated!\\n\"; return *this; } ~Te() { cout &lt;&lt; ins &lt;&lt; \" deleted!\\n\"; } }; string Te::sta_str = \"Te_static_str\"; // 用于初始化De的静态成员sta_dou，并提示初始化完成的时间。 double get_dou(int val) { cout &lt;&lt; \"static member initiated\\n\"; return 3.66 + val; } // 测试数据成员的初始化流程。 /* 输出： static member initiated 表明静态数据成员是在类定义时就初始化的。 */ struct De { int ins = ret(); int ret() { cout &lt;&lt; \"ins initiated\\n\"; return 8;} Te te = {34, \"De_str\"}; De(Te te = {23,\"De_str\"}): te(te) {} static const double sta_dou; static const int sta_ins = 30; }; const double De::sta_dou = get_dou(sta_ins); /* 输出： 33.66 表明定义在类内的静态数据成员sta_ins先初始化， 然后是定义在类外的静态数据成员sta_dou的初始化。 */ cout &lt;&lt; De::sta_dou &lt;&lt; \"\\n\"; /* 输出： 23 constructed! ins initiated 23 copyed constructed! 23 deleted! 23 deleted! 根据输出，我们可以看出， 在De的类对象de的创建过程中： 先执行De的构造函数，构造函数的局部变量te被创建； 然后在构造函数的执行过程中，按照非静态数据成员的出现顺序， 成员ins首先用类内初始值初始化， 然后是成员te用构造函数的初始值列表初始化而不用其类内初始值来初始化。 最后构造函数执行完毕，局部变量te被销毁。 最后程序结束前，对象de被销毁。 */ De de; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7441-%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7441-数据成员初始化流程"
  },"435": {
    "doc": "类概念详解",
    "title": "7.45 函数成员介绍",
    "content": "根据成员是否有static，函数成员也可分为两种： . | 非静态函数成员 | 静态函数成员 | . 非静态和静态函数成员也遵循之前所说的一般的成员规则： . | 非静态函数成员可以直接访问所属类的成员(包括将该类其他成员用作默认实参，不过只有静态成员才能当默认实参)。 | 静态函数成员不能直接访问所属类的成员，只能通过该类的对象才行。 | . 函数成员也支持定义成已删除函数，不过已删除函数只能在类内定义。 . 定义在类内的函数成员默认为inline函数，类外的不算。 为了让定义在类外的函数成员也能是inline，我们可以在定义时显式指明inline函数。 . 函数成员是函数，所以也支持成员函数的重载，只要函数之间在参数的数量和/或类型上有所区别就行(所以静态和非静态之间也是可以重载的)。 . 常量成员函数之间以及与非常量成员函数之间都支持重载； 构造函数也支持重载； 析构函数不支持重载。 . 成员函数的函数匹配过程与非成员函数类似，会考虑类中所有同名的函数，包括私有、受保护和已删除的函数，对于考虑的同名函数的范围，分两种情况： . | 如果该类自己没有定义同名的对象，则会考虑所有从其基类继承的同名函数(包括所有的直接和间接基类里的同名函数)。 | 如果该类自己有定义同名的对象，则只会考虑该类自己定义的。 | . 当调用类的成员函数时，编译器就会根据实参匹配最佳的函数。 匹配成功后，根据这个最佳函数的访问权限和是否为删除决定是否成功调用，如果无权限访问或者已删除，则会提示编译错误，否则就调用成功。 . struct Cls { void prints(int val) { cout &lt;&lt; val &lt;&lt; \" int\\n\"; } private: void prints(double val) { cout &lt;&lt; val &lt;&lt; \" double\\n\"; } }; Cls matchs; // 错误：匹配的是void prints(double val)，但是该函数无法访问 matchs.prints(3.6); // 正确：匹配的是void prints(int val)，\\ 输出3 int matchs.prints(3); . struct Cls { void prints(int val) {}; static void prints(string val) {}; void prints(int val) const {}; }; Cls no_const_obj; const Cls const_obj; // 调用void prints(int); no_const_obj.prints(25); // 调用void prints(int) const; const_obj.prints(25); // 调用static void prints(string); const_obj.prints(\"good\"); . 函数成员中的虚函数和析构函数将会在之后的继承和拷贝控制的部分进行介绍。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745-%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745-函数成员介绍"
  },"436": {
    "doc": "类概念详解",
    "title": "7.451 非静态函数成员的特性",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7451-%E9%9D%9E%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98%E7%9A%84%E7%89%B9%E6%80%A7",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7451-非静态函数成员的特性"
  },"437": {
    "doc": "类概念详解",
    "title": "7.4511 this形参",
    "content": "只用于非静态函数成员 . 对于非静态函数成员来说，它们和非静态数据成员一样，可以直接访问所属类的所有成员。非静态函数成员的这种直接访问性质，其实是由一个隐含的指针形参进行的。 非静态函数成员通过一个==名为this的指向所属类的非常量对象的常量指针==的隐式形参来访问调用该指针的那个对象，通过该对象对其他成员进行访问。 . 当我们调用一个函数成员时，是用该函数的对象的地址来初始化this。 . struct Cls { int ins; void prints(); }; Cls cls; // 近似可理解为\\ Cls::prints(&amp;cls) cls.prints(); . 所以任何对类成员的直接访问都被看作是this的隐式引用。 . struct Cls { int ins; void prints() { // 等价于\\ cout &lt;&lt; this-&gt;ins; cout &lt;&lt; ins; } }; . 对于所有的函数成员来说，this形参是隐式定义的，是每个函数成员形参表中的第一个形参。所以我们可以在函数内任何需要使用形参的地方使用this形参，不过要注意this是常量指针，遵循常量指针的规则。 . 任何在函数内自定义名为this的参数或变量的行为都是非法的。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74511-this%E5%BD%A2%E5%8F%82",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74511-this形参"
  },"438": {
    "doc": "类概念详解",
    "title": "7.4512 常量成员函数",
    "content": "只用于非静态函数成员 . 和普通类一样，我们定义的类类型也可以定义常量对象。 但是由于this是指向类类型的非常量对象的常量指针。所以根据底层const的规则，我们不能在一个常量对象上调用普通的非静态成员函数。 . 为了能在常量对象上调用非静态成员函数，我们可以将其函数的this形参设置为指向常量的常量指针。但是因为this是隐式的并且不会出现在参数列表中，所以我们只能用以下形式来指明该非静态函数成员的this为指向常量的常量指针。 形式为在非静态函数的声明或定义语句中，在函数的形参表之后紧跟一个关键字const。 . 形参表 const . 像这样使用const的非静态函数成员被称作常量成员函数(const member function)。 . 如果函数在类外定义，则类内类外都需要加上关键字const，否则编译出错。 . 常量成员函数只能是非静态成员函数。 . struct Cls { int ins; void prints() {} void prints2() const {} // 常量成员函数的类内声明 void prints3() const; // 常量成员函数的类内声明 void prints4() const; }; // 错误：类外必须要有const void Cls::prints3() {} // 正确 void Cls::prints3() const {} const Cls cls; // 错误：常量对象不能调用非常量成员函数的非静态成员函数。 cls.prints(); // 正确：常量对象可以调用常量成员函数 cls.prints2(); . 常量对象，以及常量对象的引用或指针可以调用各种除了非静态成员函数的其他成员，而对于非静态成员函数，只能调用其中的常量成员函数。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74512-%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74512-常量成员函数"
  },"439": {
    "doc": "类概念详解",
    "title": "7.4513 引用成员函数",
    "content": "之前我们有过关于左值和右值方面的介绍。 我们可以在一个类对象上调用成员函数，而不管该对象是一个左值还是一个右值。 . 但有时我们不希望某些函数成员能在左值或者右值上调用，在此情况下，我们希望强制左侧运算对象(也就是隐式形参this指向的对象)是一个左值或者是一个右值。 . 此时我们可以用一个引用限定符(reference qualifier)来指明该函数成员的this只能指向某一种值，这种成员函数就叫做引用成员函数。 . 使用方式与声明或定义const成员函数类似，在函数的形参表之后紧跟一个引用限定符： . 形参表 &amp;/&amp;&amp; . 引用限定符可以是&amp;或&amp;&amp;，分别指出this可以指向一个左值或右值。也就是说，对于&amp;限定的函数，我们只能将它用于左值；对于&amp;&amp;限定的函数，只能用于右值。 . 类似const限定符, 引用限定符只能用于非静态成员函数，如果函数在类外定义，则类内类外都需要加上对应的引用限定符，否则编译出错。 . struct Cls { // 普通函数，既能用于左值，也能用于右值。 void Prints() { cout &lt;&lt; \"common\\n\"; } // 左值函数，只能用于左值 void lPrints() &amp;; // 右值函数，只能用于右值 void rPrints() &amp;&amp; { cout &lt;&lt; \"rvalue\\n\"; } }; void Cls::lPrints() &amp; { cout &lt;&lt; \"lvalue\\n\"; } // obj为左值 Cls obj; // 正确：输出common obj.Prints(); // 正确：Cls()是一个临时对象，为右值。\\ 输出common Cls().Prints(); // 正确：输出lvalue obj.lPrints(); // 错误：rPrints不能用于左值 obj.rPrints(); // 错误：lPrints不能用于右值 Cls().lPrints(); // 正确：输出rvalue Cls().rPrints(); . 同一个函数可以同时使用const和引用限定符。在此情况下，引用限定符必须跟随在const限定符之后，不能放在之前。 . 引用成员函数也像常量成员函数一样，支持重载，不同的引用限定符的同名函数可以作为重载函数。 而且，我们可以综合引用限定符和const来区分一个成员函数的重载版本。 编译器会根据调用对象的左值/右值属性还有常量属性来确定使用哪个重载版本。 . struct Cls { // 重载的引用成员函数Prints void Prints() &amp;; void Prints() &amp;&amp; { cout &lt;&lt; \"rvalue\\n\"; } }; void Cls::Prints() &amp; { cout &lt;&lt; \"lvalue\\n\"; } Cls obj; // 调用void Prints() &amp;\\ 输出lvalue obj.Prints(); // 调用void Prints() &amp;&amp;\\ 输出rvalue Cls().Prints(); . 不过相同形参表的同名成员函数不能只通过有无引用限定符来区分重载版本。 . 所以如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须要有引用限定符。 . struct Cls { void Prints() &amp;&amp; { cout &lt;&lt; \"rvalue\\n\"; } // 错误：无法只通过有无引用限定符来区分重载版本 void Prints() { cout &lt;&lt; \"common\\n\"; } }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74513-%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74513-引用成员函数"
  },"440": {
    "doc": "类概念详解",
    "title": "7.4514 可变数据成员",
    "content": "当一个类对象为常量时，其中所有的数据成员通常都不能被修改。 . 由于常量成员函数的this形参为指向常量的指针，所以也不能在常量成员函数中修改类的数据成员，即使该类对象为非常量也不行。 . 所以为了能修改常量对象的某些数据成员，以及在常量成员函数中修改类的某些数据成员，我们可以在所需要修改的数据成员的定义中使用mutable关键字。形式为： . mutable 定义语句 . struct Cls { int ins = 2; mutable int ins2 = 3; // 错误定义：常量成员函数不能修改非可变数据成员 void amends() const { ins = 5; } // 正确定义 void amends2() const { ins2 = 5; } }; const Cls cls; // 错误：常量对象不能修改非可变数据成员 cls.ins = 8; // 正确：ins2的值修改为10 cls.ins2 = 10; // 正确：ins2的值修改为5 cls.amends2(); . mutable关键字不能用于静态数据成员或者const和constexpr成员。也就是可变数据成员必须不能是这几种类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74514-%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74514-可变数据成员"
  },"441": {
    "doc": "类概念详解",
    "title": "7.452 构造函数",
    "content": "构造函数（constructor）是一种特殊的成员函数，之前我们简单介绍了一下，构造函数的任务是初始化类对象的所有非静态数据成员。 构造函数的调用是自动的，无论何时，只要类的对象被创建，就会执行该类构造函数。 . 不同于其他成员函数，构造函数不能被声明成const的(常量成员函数)。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。 . 所有的构造函数都不能有存储说明符，且也不能有类型限定符，如const，&amp;等。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7452-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7452-构造函数"
  },"442": {
    "doc": "类概念详解",
    "title": "7.4521 构造函数分类",
    "content": "在c++中，根据构造函数创建对象的不同方式，共有三种类型的构造函数： . | 普通构造函数 | 拷贝构造函数 | 移动构造函数 | . 之后我们会详细讲解后两种构造函数的特点和使用。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74521-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74521-构造函数分类"
  },"443": {
    "doc": "类概念详解",
    "title": "7.4522 构造函数的定义",
    "content": "构造函数有着特殊的形式： . 构造函数的定义形式： . 类名 形参表 (可选 初始值列表) 函数体 . 构造函数的声明形式： . 类名 形参表; . 构造函数的名字必须要与其类名相同，构造函数没有返回类型也不能写返回类型，构造函数的函数体中一般不能含有返回语句，不过可以写空return语句。 . 和普通函数一样，构造函数也有一个（可能为空的）形参列表和一个（可能为空的）函数体。 . 初始值列表是构造函数特有的一部分，该部分负责为新创建的对象的某些非静态数据成员显式赋初始值。如果省略了初始值列表，则该类的所有非静态数据成员以其类内初始值初始化或默认初始化。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74522-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74522-构造函数的定义"
  },"444": {
    "doc": "类概念详解",
    "title": "7.4523 初始值列表",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74523-%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74523-初始值列表"
  },"445": {
    "doc": "类概念详解",
    "title": "7.45231 初始值列表的普通形式",
    "content": "初始值列表是指以冒号:开头的，后面为非静态数据成员的名字后紧跟对应的直接初始化形式的初始值的列表，每个数据成员之间用逗号,隔开，形式为： . : 成员名1 成员名1的直接初始化, 成员名2 成员名2的直接初始化, 成员名3 成员名3的直接初始化, ··· . 之前也说过，构造函数通过初始值列表，对列表中的每个成员用其后面的直接初始化来初始化该成员；对于没有出现在列表中的成员，则用其类内初始值初始化或者默认初始化。 . struct Cls { int ins; static const int c_ins = 15; string str = \"good\"; double dou; /* str会用lstr的值而不是类内初始值\"good\"; dou的初始值为ldou; ins被默认初始化； c_ins不归构造函数初始化*/ Cls(string lstr, double ldou): str(lstr), dou{ld} {} }; . 构造函数的形参名可以和成员名同名，虽然遵循作用域规则，但是初始值列表里的成员名不会被局部同名变量所隐藏。 所以初始值列表里中的成员的直接初始化的初始值可以是该构造函数的与该成员同名的形参。 . struct Cls { int ins; double dou; // 构造函数的形参与成员同名，但初始值列表中的成员不会被隐藏 Cls(int ins, double dou): ins(ins), dou(dou) {} }; int main() { // 正确：成员ins被初始化为3，成员dou被初始化为-5.2 Cls obj(3,-5.2); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745231-%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8%E7%9A%84%E6%99%AE%E9%80%9A%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745231-初始值列表的普通形式"
  },"446": {
    "doc": "类概念详解",
    "title": "7.45232 派生类构造函数的初始值列表",
    "content": "对于一个继承了其他类的派生类，如果想显式初始化继承的非静态成员，则必须要在自己的构造函数的初始值列表中调用这些继承的成员所属的类的构造函数来对这些成员进行初始化，不能直接初始化基类的成员。 . 要注意我们在初始值列表中只能调用直接基类的构造函数，也就是只能初始化直接基类所定义的非静态成员，不能调用间接基类的构造函数。 . 但是对于所有从虚基类继承的非静态成员来说，我们必须要直接调用其虚基类的构造函数来初始化这些成员，就算该虚基类为间接基类也是如此(也就是说一个类直接控制其所有虚基类的初始化，而不是让其他基类来控制)。 . 如果我们在初始值列表中未明确某个虚基类或者直接基类的非静态成员的初始化，则对应的继承的非静态成员就会根据其对应的类的默认构造函数进行初始化，如果对应的类没有未删除的默认构造函数，则编译出错。 . struct Ba { int ba_int; double ba_dou; Ba(int ins = 30, double dou = 6.778): ba_int(ins), ba_dou(dou) {} }; struct Ba2 { int ba2_int; double ba2_dou; Ba2(int ins = 3, double dou = 5.4): ba2_int(ins), ba2_dou(dou) {} }; struct Der: Ba, Ba2 { int de_int; double de_dou; // 调用直接基类Ba的构造函数来显式初始化继承的成员ba_int和ba_dou。 // 省略了继承的Ba2基类的成员的显式初始化，成员ba2_int和ba2_dou自动调用对应类的默认构造函数进行初始化。 Der(int ba_int, double ba_dou, int ins, double dou):Ba{ba_int, ba_dou}, de_int(ins), de_dou(dou) {} }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745232-%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745232-派生类构造函数的初始值列表"
  },"447": {
    "doc": "类概念详解",
    "title": "7.4524 构造函数的执行顺序",
    "content": "构造函数的运行是先执行初始值列表里的代码并初始化其他所有的非静态数据成员，初始化完毕后才是执行其后面的函数体。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74524-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74524-构造函数的执行顺序"
  },"448": {
    "doc": "类概念详解",
    "title": "7.45241 非继承类的构造函数",
    "content": "构造函数对该类定义的非静态数据成员初始化的顺序为这些成员的定义顺序，所以构造函数初始值列表中的成员顺序最好要与这些成员的定义顺序一致，否则会有警告信息。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745241-%E9%9D%9E%E7%BB%A7%E6%89%BF%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745241-非继承类的构造函数"
  },"449": {
    "doc": "类概念详解",
    "title": "7.45242 继承类的构造函数",
    "content": "对于派生类来说，基类部分的构造顺序与派生类列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。 . 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。 . 具体来说： . | 派生类按照其派生类列表的顺序，从前往后一个个检查其直接基类以确定是否为虚函数以及确定这些类的基类中是否含有虚基类。 如果有，则还要检查是否之前执行过该虚基类同名的其他虚基类，如果是，则不执行该虚函数的构造函数并继续检查其中的基类，否则就先执行虚基类的对应构造函数，该虚基类也会按照这顺序检查并执行其直接基类中的虚基类的构造函数，以此类推，直到该派生类的所有直接基类检查完毕。 | 当派生类的直接基类中的所有虚基类都被检查完毕后，该派生类则继续按照其派生类列表的顺序，从前往后一个个执行非虚基类的直接基类的对应构造函数，这些直接基类也执行其非虚基类的直接基类的构造函数，以此类推，直到该派生类的所有基类的构造函数执行完毕。 | 最后，该派生类对自己所定义的非静态数据成员进行初始化(这些成员的初始化顺序也与其定义顺序一致)以及执行对应构造函数的函数体。 | . 派生类构造函数初始值列表中基类构造函数的调用之间的顺序、与该派生类的成员初始化的顺序应该与派生类的构造顺序保持一致。否则会有警告信息。 . struct Ba { int ba_int; Ba(int ins = 30): ba_int(ins) { cout &lt;&lt; \"Ba\\n\"; } }; struct Ba2 { int ba2_int; Ba2(int ins = 3): ba2_int(ins) { cout &lt;&lt; \"Ba2\\n\"; } }; struct Der: Ba, Ba2 { int de_int; Der(int ba_int, int ins):Ba{ba_int}, de_int(ins) { cout &lt;&lt; \"Der\\n\"; } }; struct Der2: Der, Ba2 { int de2_int; Der2(int de_int, int ba2_int, int ins): Der(16, de_int), Ba2(ba2_int), de2_int(ins) { cout &lt;&lt; \"Der2\\n\"; } }; /* 输出 Ba Ba2 Der Ba2 Der2 这个也就是Der2的构造顺序 */ Der2 obj(8,9,3); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745242-%E7%BB%A7%E6%89%BF%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745242-继承类的构造函数"
  },"450": {
    "doc": "类概念详解",
    "title": "7.4525 默认构造函数",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74525-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74525-默认构造函数"
  },"451": {
    "doc": "类概念详解",
    "title": "7.45251 默认初始化",
    "content": "之前我们说过，对于类类型和共用体的默认初始化，是由该类型自己所决定的。而对于每种类类型和共用体来说，都是由一个特殊的构造函数来控制其默认初始化过程，这个函数叫做默认构造函数（default constructor）。 . 只有有默认构造函数且其不为已删除的类类型和共用体才能进行默认初始化，否则该类的对象必须显式初始化。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745251-%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745251-默认初始化"
  },"452": {
    "doc": "类概念详解",
    "title": "7.45252 默认构造函数的形式",
    "content": "我们可以自己定义默认构造函数，默认构造函数和普通构造函数一样，只不过该构造函数的形参表为空或者其形参全都有默认实参。 每种类型有且只有一个默认构造函数。 . // 定义了一个Cls的默认构造函数 struct Cls { Cls() {} }; struct Cls2 { int ins; double dou; // 定义了一个Cls2的默认构造函数 Cls2(int ins = 8, double dou = 6.3): ins(ins), dou(dou) {} }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745252-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745252-默认构造函数的形式"
  },"453": {
    "doc": "类概念详解",
    "title": "7.45253 合成的默认构造函数",
    "content": "对于没有默认构造函数的类，编译器大多都会隐式生成一个默认构造函数，编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。 . 但是，只有当该类同时满足以下三种情况时，编译器才会隐式生成一个默认构造函数： . | 该类没有显式定义任何构造函数。 | 该类自己定义的每个非静态数据成员都有类内初始值或者能默认初始化。 | 该类继承的所有非静态数据成员对应的基类必须都要有非删除的默认构造函数。 | . 合成的默认构造函数可以看成是形参表为空，并且省略了初始值列表的构造函数，所以合成的默认构造函数是用对应的类内初始值初始化或者默认初始化。 . 我们也可以用另一种形式来显式要求生成合成的默认构造函数，该形式就是在一个空形参的构造函数声明后紧跟一个赋值符=和关键字default： . 类名() = default; . 要注意必须是为空形参才行。 default声明可以在类内也可以在类外，在类内的隐式声明为内联的。 . 和普通函数一样，所有的默认构造函数既可以定义在类的内部，也可以出现在类的外部。 . 只有该类同时满足之前所说的后两种情况时，才能生成合成的默认构造函数，否则编译出错。 . // 隐式生成了一个合成的默认构造函数，\\ 该函数等价于：\\ Cls(){} struct Cls { }; struct Cls2 { int ins; double dou; // 显式生成了一个合成的默认构造函数，\\ 该函数等价于：\\ Cls2(){} Cls2() = default; }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745253-%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745253-合成的默认构造函数"
  },"454": {
    "doc": "类概念详解",
    "title": "7.4526 委托构造函数",
    "content": "委托构造函数就是把自己的初始化过程委托给其他构造函数的构造函数。 . 和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。但是在委托构造函数内，其初始值列表有且只有一个成员，这个成员及其初始化也就是对该类其他的构造函数的调用。 . 委托构造函数的形式为： . 类名 形参表: 类名 (实参表)/{实参表} 函数体 . 在委托构造函数的初始值列表中，只能有一个对其他构造函数的调用，通过这个调用，委托构造函数将初始化非静态数据成员的工作委托给了这个调用的构造函数。 . 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，最后才是执行该委托构造函数的函数体。 . struct Cls { int ins; string str; double dou; Cls(int ins, string str, double dou): ins(ins), str(str), dou(dou) {} // 委托构造函数，将初始化工作委托给Cls(int, string, double) Cls(int ins, string str): Cls(ins, str, 5.5) {} // 委托构造函数，将初始化工作委托给Cls(int, string) Cls(string str): Cls(3, str) {} }; // 调用Cls(int, string, double) Cls obj = Cls{3,\"str\", 8.8}; // 调用Cls(int, string) Cls obj2 = Cls{3, \"str2\"}; // 调用Cls(string) Cls obj3 = Cls(\"string\"); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74526-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74526-委托构造函数"
  },"455": {
    "doc": "类概念详解",
    "title": "7.4527 重用基类的构造函数",
    "content": "在C++11新标准中，派生类能够重用其直接基类定义的构造函数。 也就是该派生类可以生成和其直接基类形参表，初始值列表，函数体都一样的构造函数（拷贝控制构造函数除外）。 . 一个类也只重用其直接基类的构造函数，不能重用其他的基类的，包括其虚基类。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74527-%E9%87%8D%E7%94%A8%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74527-重用基类的构造函数"
  },"456": {
    "doc": "类概念详解",
    "title": "7.45271 重用构造函数的形式",
    "content": "派生类重用基类构造函数的方式是提供一条注明了直接基类名的using声明语句，形式为： . using 直接基类名::直接基类名; . 要用作用域运算符显式注明。 . 对于该直接基类的每个构造函数，按照这些构造函数的声明顺序，编译器会依次生成与之对应的派生类构造函数。换句话说，对于基类的每个构造函数（拷贝控制构造函数除外），编译器都在派生类中生成一个和其直接基类形参表，初始值列表，函数体都一样的构造函数。 这些编译器生成的构造函数形如： . 派生类名 直接基类对应构造函数的形参表 直接基类对应构造函数的初始值列表 直接基类对应构造函数的函数体 . #include &lt;iostream&gt; // 直接基类 class Base { public: Base(const std::string&amp; s) { std::cout &lt;&lt; \"this is base\" &lt;&lt; std::endl; } Base(const Base&amp;, int i) { std::cout &lt;&lt; \"this is base\" &lt;&lt; std::endl; } }; class Derive: public Base { public: /* 生成以下构造函数： Derive(const std::string&amp; s) {std::cout &lt;&lt; \"this is base\" &lt;&lt; std::endl;} Derive(const Base&amp;, int i) { std::cout &lt;&lt; \"this is base\" &lt;&lt; std::endl; } */ using Base::Base; }; . 类不能重用合成的（包括显式用=default指定的合成函数）默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。 其中对于用户自定义的拷贝和移动构造函数，编译器会在派生类中生成一个函数体相同，但函数名及形参表都为派生类名的构造函数。 . 注意：任何构造函数如果满足了已删除的条件，则重用该构造函数失效，编译器将会生成对应构造函数的已删除版本。 . #include &lt;iostream&gt; // 直接基类 class Base { public: Base() { std::cout &lt;&lt; \"default base\" &lt;&lt; std::endl; } Base(const Base&amp;) { std::cout &lt;&lt; \"copy base\" &lt;&lt; std::endl; } Base(Base&amp;&amp;) noexcept { std::cout &lt;&lt; \"move base\" &lt;&lt; std::endl; } }; // 直接基类 class Base2 { public: Base2() = default; Base2(const Base2&amp;) { std::cout &lt;&lt; \"copy base\" &lt;&lt; std::endl; } Base2(Base2&amp;&amp;) = default; }; class Derive: public Base { public: /* 生成以下构造函数： Derive() { std::cout &lt;&lt; \"default base\" &lt;&lt; std::endl; } Derive(const Derive&amp;) { std::cout &lt;&lt; \"copy base\" &lt;&lt; std::endl; } Derive(Derive&amp;&amp;) { std::cout &lt;&lt; \"move base\" &lt;&lt; std::endl; } */ using Base::Base; }; class Derive2: public Base2 { public: /* 不会生成任何构造函数 */ using Base2::Base2; Derive2&amp; operator=(Derive2&amp;&amp;) noexcept { std::cout &lt;&lt; \"move assignment\" &lt;&lt; std::endl; } }; int main() { // 输出default base Derive d1; // 输出copy base Derive d2 = d1; // 输出move base Derive d3 = std::move(d1); // 正常 Derive2 dd1; // 错误，因为类自定义了移动赋值运算符，所以导致using不能重用拷贝构造函数，以及合成的拷贝构造函数为已删除。 Derive2 dd2 = dd1; return 0; } . 直接基类的每个构造函数还包括该直接基类自己所重用的构造函数。 . 派生类可以重用多个直接基类的构造函数，只要写上对应基类的using声明就行。 . 要注意可能会有多个形参表一样的重用构造函数，此时当使用该重用构造函数时，会编译出错。 . 此时则要定义和该重用构造函数形参表相同的(可忽略顶层const)，该派生类自己的构造函数，该派生类自己定义的构造函数会隐藏其他同形参表的重用构造函数。 . struct Te0 { Te0(int val){} }; struct Te { Te(int val){} }; // 重用了Te, Te0的构造函数 struct Sub1: Te, Te0 { using Te::Te; using Te0::Te0; }; // 错误：Sub1有两个同形参表的构造函数Sub1(int val) Sub1 obj(3); // 重用了Te, Te0的构造函数 struct Sub2: Te, Te0 { using Te::Te; using Te0::Te0; Sub2(int val): Te(val), Te0(val) {} }; // 正确：Sub2定义的构造函数会隐藏其他同形参表的重用构造函数 Sub1 obj(3); . 当使用这些重用构造函数时，派生类自己定义的非静态数据成员则会类内初始值初始化或者默认初始化。 . struct Cls { int ins; double dou; Cls(int ins, double dou): ins(ins), dou(dou) {} Cls(int ins = 5): Cls(ins,3.5) {} } struct Sub { // 重用了Cls的构造函数Cls(int ins, double dou)和Cls(int ins = 5) using Cls::Cls; } // 正确 Sub obj(9,6.5); Sub obj2(15); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745271-%E9%87%8D%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745271-重用构造函数的形式"
  },"457": {
    "doc": "类概念详解",
    "title": "7.45272 重用构造函数的特点",
    "content": ". | 该using声明不会改变所重用构造函数的访问级别。所重用的构造函数的权限是它们第一次定义时所处的访问权限，与该using声明所属类的派生访问符和该using声明所在的位置无关。 例如，不管using声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的构造函数和公有构造函数也是同样的规则。 | 一个using声明语句不能指定explicit或constexpr。如果基类的构造函数是explicit或者constexpr，则重用的构造函数也拥有相同的属性。 | 重用的构造函数不会有任何默认实参。 当一个直接基类的构造函数含有默认实参，这些默认实参并不会被重用。相反，派生类将获得多个重用的构造函数，其中每个构造函数，从前向后，分別省略掉一个含有默汄实参的形参。 例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参(没有默认实参)，另一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认实参的那个形参。 | 派生类不会重用合成的默认、合成的拷贝和合成的移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。 | 派生类自己定义的构造函数会隐藏其他具有相同形参表的重用构造函数。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745272-%E9%87%8D%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745272-重用构造函数的特点"
  },"458": {
    "doc": "类概念详解",
    "title": "7.453 虚函数",
    "content": "我们之前一直谈论过虚函数，它是实现类动态绑定思想中的基础。 . 类的任意非构造函数的非静态函数(包括运算符和析构函数)都能被指定为虚函数。 一个类可以有任意多个虚函数，且虚函数也可以是重载函数。 . 虚函数像其他函数成员一样，可以被继承，被继承的虚函数在其派生类中也是虚函数。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7453-%E8%99%9A%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7453-虚函数"
  },"459": {
    "doc": "类概念详解",
    "title": "7.4531 定义虚函数的形式",
    "content": "指定虚函数的方式为在该函数成员的类内声明或定义语句之前加上关键字virtual，形式为： . virtual 函数的声明或定义语句 . 要注意关键字virtual只能出现在类的内部，所以虚函数在类外的定义不能加关键字virtual。 . 所有被指定为虚函数的函数成员都必须要有定义，不能只有声明，就算不用到该函数也是如此。 . struct Ba { // 定义在类内的虚函数prints virtual void prints() { cout &lt;&lt; \"Ba\\n\"; } // 虚函数ret的类内声明 virtual int ret(int val); }; // 虚函数ret的类外定义，注意不能有virtual int Ba::ret(int val) { return val;} . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74531-%E5%AE%9A%E4%B9%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74531-定义虚函数的形式"
  },"460": {
    "doc": "类概念详解",
    "title": "7.4532 虚函数的覆盖",
    "content": "当该类的派生类自己定义了一个与该类的某个虚函数一致(函数名相同，返回类型和形参表都匹配)的函数时，我们就说这个派生类覆盖了该类的这个虚函数。 . 对于虚析构函数来说，不需要函数名相同就能覆盖其基类的虚析构函数。 也就是说，只要某个类定义了虚析构函数，那么该类的派生类的自己定义的析构函数就会自动覆盖该类的析构函数。 . 基类的所有虚函数都能被覆盖，就算该虚函数在基类为私有访问或者私有继承都行。而且覆盖其虚函数的函数的访问权限也可以是任意的。 . 对于重载虚函数来说，一个覆盖函数只能覆盖其对应的重载版本。 . 这个覆盖了基类某虚函数的派生类成员函数也被隐式地成为一个虚函数(所以也要遵循虚函数的规则)，所以该派生类的派生类也可以覆盖这个函数。 . 因为覆盖虚函数的函数被隐式成为一个虚函数，所以无需用virtual关键字指明(但也可以加，作用一样)。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74532-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%A6%86%E7%9B%96",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74532-虚函数的覆盖"
  },"461": {
    "doc": "类概念详解",
    "title": "7.45321 覆盖条件",
    "content": "覆盖了基类某个虚函数的，由派生类所定义的函数必须与该虚函数的函数名相同，形参表相同(可以忽略顶层const)，返回类型要一模一样。 . 返回类型有一个例外，该例外为： 如果基类的虚函数的返回类型是该基类类型的指针或者引用，则其派生类覆盖的函数的返回类型可以是该派生类类型的对应复合类型(也就是该派生类类型的指针或者引用)。 . 派生类不能定义除了该例外以外的，只有返回类型不同的函数，否则会编译出错。 . struct Ba { virtual Ba* ret(int val) { static Ba bObj; return &amp;bObj; } }; struct De:Ba { // 覆盖了基类Ba的虚函数Ba* ret(int val) De* ret(const int val) { static De dObj; return &amp;dObj; } }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745321-%E8%A6%86%E7%9B%96%E6%9D%A1%E4%BB%B6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745321-覆盖条件"
  },"462": {
    "doc": "类概念详解",
    "title": "7.45322 覆盖提示",
    "content": "之前说过，因为每个类就是一个作用域，所以派生类可以定义一个与基类中虚函数的名字相同但是形参列表不同的函数，这仍然是合法的行为，该函数并没有覆盖基类中的版本。 . 所以这就导致了我们本来想定义覆盖虚函数的函数，但是由于定义的形参表不对，导致并没有覆盖到虚函数，且我们也无法及时知道这个错误。 . 为了显式提示我们是否覆盖了虚函数，在 C++11新标准中我们可以在定义覆盖虚函数的函数时使用override关键字來提示是否正确定义了覆盖的函数。 . override关键字出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后，且和virtual关键字一样，只能出现在类内的函数声明或定义语句中。 . 使用形式为： . | 返回类型 函数名 形参表 (可选 const等修饰符) override (可选 函数体); . | auto 函数名 形参表 -&gt; 返回类型 (可选 const等修饰符) override (可选 函数体); . | . 如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数；或者我们标记的函数没有对应的虚函数，此时编译器将报错。 . struct Ba { virtual Ba* ret(int val) { static Ba bObj; return &amp;bObj; } }; struct De:Ba { // 覆盖函数的声明 De* ret(const int val) override; }; // 覆盖函数的类外定义，注意不能有override De* De::ret(const int val) { static De dObj; return &amp;dObj; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745322-%E8%A6%86%E7%9B%96%E6%8F%90%E7%A4%BA",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745322-覆盖提示"
  },"463": {
    "doc": "类概念详解",
    "title": "7.45323 阻止覆盖",
    "content": "当我们定义的虚函数不想让后续的派生类来覆盖时，可以将其指定为final，被指定为final的虚函数不能被后续的派生类函数所覆盖。 . 和override关键字一样，final关键字出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后，且只能出现在类内的函数声明或定义语句中。 . 使用形式为： . | 返回类型 函数名 形参表 (可选 const等修饰符) final (可选 函数体); . | auto 函数名 形参表 -&gt; 返回类型 (可选 const等修饰符) final (可选 函数体); . | . 当同时使用override和final关键字时，这两个关键字的相对顺序可以任意。 . struct Ba { // 指定Ba* ret(int val)不能被覆盖 virtual Ba* ret(int val) final; }; // 虚函数Ba* ret(int val)的类外定义，注意不能有final Ba* Ba::ret(int val) { static Ba bObj; return &amp;bObj; } struct De:Ba { // 错误：Ba* ret(int val)不能被覆盖 De* ret(const int val) override final { static De dObj; return &amp;dObj; } }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745323-%E9%98%BB%E6%AD%A2%E8%A6%86%E7%9B%96",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745323-阻止覆盖"
  },"464": {
    "doc": "类概念详解",
    "title": "7.4533 虚函数的使用",
    "content": "虚函数是用于动态绑定的，如果一个基类定义了它自己的引用或指针，通过该引用或指针调用某个被覆盖的虚函数时，被调用的函数是该指针或引用的内存中的，所保存对象的类型中相匹配的那一个覆盖函数，这也就叫动态绑定。 具体来说，就是优先调用覆盖函数版本的对应函数，当没有覆盖函数版本时才会考虑基类的版本。 . 当一个类中有多个该虚函数的覆盖函数时，不管这些函数时该类自己定义的还是继承的，其基类通过引用或指针调用该虚函数时都会出现二义性。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74533-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74533-虚函数的使用"
  },"465": {
    "doc": "类概念详解",
    "title": "7.45331 重载虚函数的使用",
    "content": "对于重载虚函数来说，通过该基类的引用或指针调用该重载虚函数时，覆盖函数的版本会替换掉原来的该基类版本，然后与其他非覆盖的该基类重载版本一起参与函数匹配。 . struct Ba { // 重载虚函数prints virtual void prints(int val) {cout &lt;&lt; val &lt;&lt; \" intBa\\n\";} virtual void prints(double val) {cout &lt;&lt; val &lt;&lt; \" doubleBa\\n\";} virtual void prints(string val) {cout &lt;&lt; val &lt;&lt; \" stringBa\\n\";} }; struct De:Ba { // 覆盖了基类Ba的一个重载虚函数void prints(double val)，\\ 该覆盖函数将替代原虚函数参与函数匹配 void prints(double val) {cout &lt;&lt; val &lt;&lt; \" doubleDe\\n\";} }; De obj; Ba &amp;r = obj; // 匹配的是void prints(string val\\ 输出strs stringBa r.prints(\"strs\"); // 匹配的是派生类De的void prints(double val)\\ 输出3.5 doubleDe r.prints(3.5); // 匹配的是void prints(int val)\\ 输出5 intBa r.prints(5); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745331-%E9%87%8D%E8%BD%BD%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745331-重载虚函数的使用"
  },"466": {
    "doc": "类概念详解",
    "title": "7.45332 虚函数的访问权限",
    "content": "要注意，一个虚函数能否被访问是由其动态类型中的静态类型部分对于该虚函数的访问权限所决定的，与其他部分对于该虚函数的访问权限无关。 . struct Ba { virtual void prints(string val) {cout &lt;&lt; val &lt;&lt; \" stringBa\\n\";} }; // 公有继承Ba struct De:Ba { private: // 覆盖的函数为私有函数 void prints(string val) override {cout &lt;&lt; val &lt;&lt; \" stringDe\\n\";} }; // 私有继承Ba class De2:Ba { public: // 覆盖的函数为公有函数 void prints(string val) override {cout &lt;&lt; val &lt;&lt; \" stringDe2\\n\";} }; De obj; De2 obj2; De &amp;dr = obj; Ba &amp;r = obj; // 错误：obj2中的Ba部分为私有，不可访问，无法绑定到Ba上。 Ba &amp;r2 = obj2; // 错误：dr的类型为De，prints在De中为私有函数 dr.prints(\"strs\"); // 正确：r的类型为Ba，prints在Ba中为公有函数，\\ 且De类中的prints访问权限不会影响其动态使用，所以输出为\\ strs stringDe r.prints(\"strs\"); // 错误：obj2中的Ba部分为私有，不可访问。 r2.prints(\"strs\"); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745332-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745332-虚函数的访问权限"
  },"467": {
    "doc": "类概念详解",
    "title": "7.45333 调用指定版本的虚函数",
    "content": "在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。 这时，可以使用作用域运算符来实现这一目的。 . 使用形式为： . 对象名.类名::虚函数名(实参表) . 其中类名必须是这个对象名所属的类型以及这个类型的任意包含该虚函数的基类。 . struct Ba { virtual void prints(string val) {cout &lt;&lt; val &lt;&lt; \" stringBa\\n\";} }; struct De:Ba { void prints(string val) override {cout &lt;&lt; val &lt;&lt; \" stringDe\\n\";} }; struct De2:De { void prints(string val) override {cout &lt;&lt; val &lt;&lt; \" stringDe2\\n\";} }; De2 obj; De *dr = &amp;obj; Ba &amp;br = obj; // 调用的是De2类的版本，输出为：\\ strs stringDe2 dr-&gt;prints(\"strs\"); // 调用的是Ba类的版本，输出为：\\ strs stringBa dr-&gt;Ba::prints(\"strs\"); // 调用的是De2类的版本，输出为：\\ strs stringDe2 br.prints(\"strs\"); // 错误：br的类为Ba类，De是它的派生类类，\\ 所以不能调用De的版本 br.De::prints(\"strs\"); // 调用的是Ba类的版本，输出为：\\ strs stringBa br.Ba::prints(\"strs\"); . 如果一个派生类的虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745333-%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#745333-调用指定版本的虚函数"
  },"468": {
    "doc": "类概念详解",
    "title": "7.4534 虚函数的默认实参",
    "content": "和其他函数一样，虚函数也可以拥有默认实参。 调用的虚函数所使用的默认实参是由其调用对象的类型来决定的。 换句话说，如果我们通过基类的引用或指针调用虚函数，则使用的是基类中定义的默认实参, 即使该引用或指针的内存的对象为派生类中的函数版本也是如此。 . 所以如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致，防止调用的结果不符合预期。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74534-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#74534-虚函数的默认实参"
  },"469": {
    "doc": "类概念详解",
    "title": "7.454 覆盖重载的函数",
    "content": "之前说过，除了析构函数，其他所有的函数成员都能被重载。 . 根据类的作用域，所有派生类定义的成员会隐藏掉其所有基类的同名成员，这就导致我们在派生类定义的函数成员不能与从基类继承的函数成员重载。 . 为此，我们可以为想要重载的函数成员提供一条using声明语句，形式为： . using 基类名::重载函数名; . 一条基类成员函数的using声明语句的作用是把该基类中的该函数对应的所有重载函数（不包括此基类继承的，但包括此基类用using声明语句所添加的）添加到这个调用派生类的作用域中。 此时，派生类自己定义的重载版本就可以与基类对应的重载版本一起重载了。 . 声明的基类不一定要是直接基类，可以是派生类的任何基类。 . struct Ba0 { void pri(bool val) { cout &lt;&lt; val &lt;&lt; \" Ba0\\n\"; } void pri(char val) { cout &lt;&lt; val &lt;&lt; \" Ba0\\n\"; } }; struct Ba: Ba0 { void pri(int val) { cout &lt;&lt; val &lt;&lt; \" Ba\\n\"; } void pri(double val) { cout &lt;&lt; val &lt;&lt; \" Ba\\n\"; } void pri(string val) { cout &lt;&lt; val &lt;&lt; \" Ba\\n\"; } }; struct De: Ba { // 对基类Ba0的using声明。 using Ba0::pri; void pri(int val) { cout &lt;&lt; val &lt;&lt; \" De\\n\"; } }; De ob; // 正确：输出a Ba0 ob.pri('a'); // 正确：输出6 De ob.pri(6); // 错误：基类Ba的pri被隐藏。 ob.pri(string(\"good\")); . 用using声明语句添加的函数的访问权限由该using声明语句所在位置的访问权限来决定的，并且这些访问权限的更改是永久的，是可继承的。 . class Ba0 { protected: void pri(bool val) { std::cout &lt;&lt; val &lt;&lt; \" Ba0\\n\"; } void pri(char val) { std::cout &lt;&lt; val &lt;&lt; \" Ba0\\n\"; } }; class Ba: public Ba0 { public: using Ba0::pri; void pri(int val) { std::cout &lt;&lt; val &lt;&lt; \" Ba\\n\"; } void pri(double val) { std::cout &lt;&lt; val &lt;&lt; \" Ba\\n\"; } void pri(std::string val) { std::cout &lt;&lt; val &lt;&lt; \" Ba\\n\"; } }; int main() { Ba obj; // 正确：调用void pri(bool val) // 输出1 Ba0 obj.pri(true); return 0; } . 要注意，using声明语句中基类的对应函数的每个重载版本要在派生类中都可访问，否则编译出错。 . struct Ba { void pri(int val) { cout &lt;&lt; val &lt;&lt; \" Ba\\n\"; } void pri(double val) { cout &lt;&lt; val &lt;&lt; \" Ba\\n\"; } private: void pri(string val) { cout &lt;&lt; val &lt;&lt; \" Ba\\n\"; } }; struct De: Ba { // 错误：类Ba中有一个pri不可访问 using Ba::pri; void pri(int val) { cout &lt;&lt; val &lt;&lt; \" De\\n\"; } }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7454-%E8%A6%86%E7%9B%96%E9%87%8D%E8%BD%BD%E7%9A%84%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7454-覆盖重载的函数"
  },"470": {
    "doc": "类概念详解",
    "title": "7.46 类类型成员介绍",
    "content": "类的类类型成员为以下两种： . | 嵌套类 | 类型别名 | . 类的类类型成员和其他的类成员一样，其访问权限由其所属类对应的访问符决定。 . 所有可访问的类类型成员在类外只能用作用域运算符访问，不能用类对象访问。 . 和其他类成员一样，类类型成员的名字在外层类作用域中是可见的，在外层类作用域之外不可见。 . 类类型成员也是类，所以在类类型成员声明或定义后，外层类的其他成员可以按照类类型规则直接使用这些类类型成员(要注意只声明的类类型成员是不完全类型)。 . struct Cls { // 错误定义：要在类类型成员声明或定义后才能使用 cst_int ins; // 类类型成员cst_int typedef const int cst_int; // 类类型成员Nest，为不完全类型 struct Nest; // 类类型成员Nest2 struct Nest2 {}; // 正确定义 cst_int ins2; // 错误定义：Nest为不完全类型 Nest mem1; // 正确定义：静态成员的类型可以为不完全类型 static Nest sta_mem1; // 正确定义 Nest2 mem2; // 正确定义：可以声明含有不完全类型的函数 Nest func(); // 正确定义 Nest2 func2(cst_int inss) {} }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#746-%E7%B1%BB%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98%E4%BB%8B%E7%BB%8D",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#746-类类型成员介绍"
  },"471": {
    "doc": "类概念详解",
    "title": "7.461 类型别名成员",
    "content": "类中的类类型成员可以是类型别名，它遵循类类型成员的一般规则。 . 类型别名成员与该外层类是独立的个体，它们成员之间的访问遵循类外的作用域规则与它们自己的访问权限。 . struct Ty { // 错误定义：ins是Pp的成员，与该Ty类无关。 void pri() { cout &lt;&lt; ins;} }; struct Pp { typedef Ty ok; int ins = 48; string str = \"good\"; }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7461-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E6%88%90%E5%91%98",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7461-类型别名成员"
  },"472": {
    "doc": "类概念详解",
    "title": "7.462 嵌套类",
    "content": "一个类可以定义在另一个类的内部，前者称为嵌套类(nested class)或嵌套类型(nested type)。 . 嵌套类和正常的类类型一样，遵循各种类类型的规则。 . 嵌套类和其他类成员一样，可以在外层类内或外层类外定义该嵌套类，外层类外定义时必须要先在外层类内声明该类。 . 当外层类不为局部类时，嵌套类自己的成员可以在嵌套类外定义，不过其成员的类外定义必须要在全局作用域下定义，不能在其外层类类内定义。 . struct Outs { int ins; static double sta_dou; // 嵌套类Nest的声明 struct Nest; void pro() { } }; // 嵌套类Nest的定义 struct Outs::Nest { int nins; static string nsta_str; void prn(); }; // 嵌套类Nest的成员prn和nsta_str的定义 void Outs::Nest::prn() {} string Outs::Nest::nsta_str = \"nest\"; . 外层类的其他成员不能直接访问嵌套类的类成员，这些成员访问嵌套类的类成员就和访问其他非嵌套类的类成员一样，要遵循嵌套类的访问规则。 . class Outs { // 嵌套类Nest class Nest { int nins = 8; static constexpr double ndou = 86.4; public: void n_pri() { cout &lt;&lt; \"Nest\"; } }; // 错误定义：不能直接访问嵌套类Nest的成员n_pri。 void prints() { n_pri(); } // 错误定义：嵌套类Nest的成员nins不可访问。 void prints2() { Nest n_obj; cout &lt;&lt; n_obj.nins; } // 正确定义：嵌套类Nest的成员n_pri可访问。 void prints2() { Nest n_obj2; n_obj2.n_pri(); } }; . 嵌套类的类成员类似于外层类的静态成员： 嵌套类的所有类成员可以直接访问或者通过外层类的对象间接访问外层类的所有静态或非静态成员，而不会受到外层类的访问权限限制；而且如果其外层类也是一个嵌套类，则也可以这样访问外层类的外层类成员，以此类推，可以访问到该嵌套类的所有的外层类成员。 . class Outs { int ins = 6; // 嵌套类Nest class Nest { // 正确定义：可以直接访问外层类的静态成员。 void n_pri() { cout &lt;&lt; sta_dou; } // 嵌套类Nest的嵌套类SubNest class SubNest { // 正确定义：可以直接访问外层类的外层类的静态成员。 void subn_pri() { cout &lt;&lt; sta_dou; } }; }; static double sta_dou; }; double Outs::sta_dou = 36.3; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7462-%E5%B5%8C%E5%A5%97%E7%B1%BB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7462-嵌套类"
  },"473": {
    "doc": "类概念详解",
    "title": "7.5 类的作用域",
    "content": "我们要清楚，一个类就是一个作用域，类的作用域遵循作用域的规则。 . 在作用域内，类定义的成员也会隐藏掉外部的同名对象，所以类内想要访问类外的同名对象时，需要用到作用域运算符。 . 在类的外部，成员的名字被隐藏起来了，所以我们在类外定义类成员时，就需要用作用域运算符来显式指明该成员为类的成员。 一旦类成员名遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括形参表、函数体和类体。 另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#75-%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#75-类的作用域"
  },"474": {
    "doc": "类概念详解",
    "title": "7.51 类作用域的关系",
    "content": "类相关的作用域的关系为： . | 类的作用域包含该类自己定义的函数成员和嵌套类的作用域(继承的成员的作用域不在该类作用域内)。 | 基类的作用域包含其所有派生类的作用域。 | . 所以根据类作用域的关系可知： 如果一个类所继承的成员中有多个分别来自不同基类的成员，它们的名字都相同，且该派生类自己没有定义同名的成员。则我们不能直接调用这些同名成员，会出现二义性问题。我们只能通过作用域运算符显式指明我们所要调用的是哪一个类的成员。 . struct Ba { string str = \"ba\";}; struct Ba2 { string str = \"ba2\";}; struct Ba3 { string str = \"ba3\";}; struct De: Ba, Ba2, Ba3 {}; De obj; // 错误：继承的str数据成员有多个，无法知道该使用哪一个。 cout &lt;&lt; obj.str; // 正确：指定的是从Ba3继承的str数据成员。输出ba3 cout &lt;&lt; obj.Ba3::str; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#751-%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%85%B3%E7%B3%BB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#751-类作用域的关系"
  },"475": {
    "doc": "类概念详解",
    "title": "7.52 类的定义顺序",
    "content": "类的定义顺序和普通对象的定义顺序不一样，类是先编译所有成员的声明，直到类的成员全部可见后才编译其他部分。 . 以下为类的具体定义顺序： . | 先按照成员在类内的出现顺序，逐个编译其成员的类内声明部分，也就是： . | 当成员在类内为声明语句时，就编译该声明； | 当成员在类内为定义语句时，除了静态数据成员，其他成员只编译该成员的声明部分；对于静态数据成员，则会对初始值进行名字查找和类型检查并执行该成员的初始化。 | . | 接着按照成员在类内的出现顺序，除了静态数据成员，对所有在类内定义的成员的初始化部分或者函数体进行名字查找和类型检查。 如果是类类型成员，则该成员也开始对其成员进行定义顺序的1，2步。 除了静态数据成员，所有在类内定义的成员的初始化部分或者函数体可以包含当前只有声明而无定义的对象。 名字查找和类型检查完毕前，该定义类都为不完全类型，当完毕后，该类就不再是不完全类型了。 . | 当在类外遇到某个属于该类成员的定义语句时： 进行名字查找和类型检查，此时的名字查找和类型检查还会检查该成员是否使用了未定义的对象(包括只有声明而无定义的对象)，如果检查失败，则编译出错。 检查完毕后将该定义加入到对应的类成员中。 当是静态数据成员的定义语句时，则还会执行该成员的初始化。 | 当使用了该类的某成员时，进行名字查找和类型检查，此时的名字查找和类型检查还会检查该成员是否使用了未定义的对象(包括只有声明而无定义的对象)，如果检查失败，则编译出错。 | . 所以对于类成员来说，函数成员可以以其所属类作为形参或者返回类型；对于在类外定义的成员，不能使用该类的当前未定义对象(包括只有声明而无定义的对象)。 . struct Inc { static int sta_ins; static int sta_ins2; // 可以定义含Inc类型的函数 // 正确定义：该函数包含了当前只有声明而无定义的对象。 Inc fun(Inc obj) { cout &lt;&lt; sta_ins; return Inc(); }; }; // 错误定义：使用了未定义的对象sta_ins int Inc::sta_ins2 = sta_ins; Inc obj; // 错误：fun包含当前未定义的对象。 obj.fun(Inc()); . struct Inc { static int sta_ins; static int sta_ins2; // 可以定义含Inc类型的函数 // 正确定义：该函数包含了当前只有声明而无定义的对象。 Inc fun(Inc obj) { cout &lt;&lt; sta_ins; return Inc(); }; }; // 正确定义：当前作用域有sta_ins的定义 int Inc::sta_ins2 = sta_ins; int Inc::sta_ins = 8; Inc obj; // 正确：fun包含的对象sta_ins在当前调用点有定义。 obj.fun(Inc()); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#752-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E9%A1%BA%E5%BA%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#752-类的定义顺序"
  },"476": {
    "doc": "类概念详解",
    "title": "7.53 类的名字查找",
    "content": "类中的名字查找和在各种作用域里的名字查找类似。 . 类的名字查找也是在类型检查之前，所以当在某作用域中找到了名字，则不会再考虑外层作用域的同名对象。 . 所以根据上面的作用域关系，类成员定义中的名字查找顺序为： . | 对于出现在成员函数内的名字，先在该函数作用域内从调用点(包括该调用点)向上查找。 | 对于第1步没有找到的和在类中出现的名字，则在类的作用域中继续查找。 对于不是在静态数据成员的类内初始值中出现的名字，这时类的所有成员名都可以被考虑；对于出现在静态数据成员的类内初始值中的名字，则从调用点(包括该调用点)向上查找。 | 如果在类内也没找到该名字的声明，则在该类的所有直接基类的作用域内同时进行查找；如果都没找到，则在这些直接基类的直接基类再同时查找，以此类推，直至继承的源头都已经查找完毕。 | 如果在该类的所有基类中都没找到该名字的声明，则在该类的定义位置之前继续查找。 | . 要注意在名字查找的第3步中，如果在多个直接基类中都找到了该名字，则会出现二义性错误。此时可以定义自己的对应成员来隐藏这些重复的成员或者使用作用域运算符显式指定特定的成员从而解决二义性错误。 . string str = \"out_strs\"; struct Ba { int ins = 8; string str = \"inner_strs\"; }; struct Ba2 {int ins = 8;}; struct De: Ba { double ins = 13.5; }; struct De2: De {}; struct De3: Ba, Ba2 {}; De2 obj; De3 obj2; // ins对象的查找顺序为De2 -&gt; De，在De找到后就停止查找了 // 输出为13.5 cout &lt;&lt; obj.ins &lt;&lt; endl; // ins对象的查找顺序为De2 -&gt; De -&gt; Ba，在Ba找到后就停止查找了 // 输出为inner_strs cout &lt;&lt; obj.str &lt;&lt; endl; // ins对象的查找顺序为De3 -&gt; Ba/Ba2，在Ba和Ba2都找到了ins，所以出现二义性错误。 cout &lt;&lt; obj2.ins &lt;&lt; endl; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#753-%E7%B1%BB%E7%9A%84%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#753-类的名字查找"
  },"477": {
    "doc": "类概念详解",
    "title": "7.531 类函数成员的名字查找",
    "content": "对于类的函数成员来说，根据其函数成员是否为虚函数，它们的查找顺序会有一些不一样。 . 我们后面会讲到详细的静态和动态类型，现在我们先了解以下什么是静态和动态类型。 当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型（static type）与该表达式表示对象的动态类型（dynamic type）区分开來。 . | 静态类型的表达式类型，在编译时总是已知的，它是变量声明时的类型或者表达式计算结果的类型。 | 动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。 | . 以下是c++对于所有成员函数调用的执行顺序，假定我们调用p-&gt;mem()或者obj.mem()： . | 首先确定p（或者obj）的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。 | 在p（或obj ）的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。 | 一旦找到了mem，就进行常规的类型检查，以确认对于当前找到的mem来说，本次调用是否合法。 如果调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码： . | 如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底该运行该虚函数的哪个版本，依据是对象的动态类型。 | 反之，如果mem不是虚函数或者我们是通过对象（而非引用或指针）进行的调用，则编译器将产生一个常规函数调用，也就是只考虑该对象的静态类型中的函数。 | . | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7531-%E7%B1%BB%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98%E7%9A%84%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7531-类函数成员的名字查找"
  },"478": {
    "doc": "类概念详解",
    "title": "7.6 访问控制",
    "content": "之前的介绍我们只讲述了怎样定义类的接口和各种接口所需要的数据，这也就是完成了数据抽象的方面。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#76-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#76-访问控制"
  },"479": {
    "doc": "类概念详解",
    "title": "7.61 封装的优点",
    "content": "但是我们还需要进行类的封装，封装的意思就是指对类的成员的访问权限进行控制，比如禁止在类作用域外访问某成员。 我们对类的非接口数据进行封装，可以有效的引导用户来使用接口。 . 封装有两个重要的优点： . | 确保用户的代码不会无意间破坏封装对象的状态。因为不进行封装，用户就有可能会使用到非接口的数据，从而可能会导致数据出错。 | 被封装的类的具体实现细节可以随时改变，而无须用户调整之前的代码。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#761-%E5%B0%81%E8%A3%85%E7%9A%84%E4%BC%98%E7%82%B9",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#761-封装的优点"
  },"480": {
    "doc": "类概念详解",
    "title": "7.62 访问说明符",
    "content": "c++是用一种叫做访问说明符(access specifiers)的关键字来进行封装的。 . 访问说明符作用于某些成员，对这些成员的访问权限作出控制。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#762-%E8%AE%BF%E9%97%AE%E8%AF%B4%E6%98%8E%E7%AC%A6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#762-访问说明符"
  },"481": {
    "doc": "类概念详解",
    "title": "7.621 访问说明符分类",
    "content": "c++的访问说明符一共有三种： . | 关键字public | 关键字private | 关键字protected | . 这些访问说明符有两种使用方式： . | 在定义类的类体中使用，使用形式为： 访问说明符: . | . 每个访问符的作用范围从使用的位置开始，一直到遇到另一个访问符或者类体的末尾为止的所有成员。 . | 在定义类的类派生列表中每个直接基类的前面使用，使用形式为： 访问说明符 基类名 . | . 每个访问符的作用范围为其后紧跟的那个基类的所有成员。 . struct Cls { // private访问符作用的对象为ins和dou private: int ins; double dou; // protected访问符作用的对象为str和flo protected: string str; float flo; // public访问符作用的对象为cha，bl和lng public: char cha; bool bl; long lng; }; struct Cls2 {}; struct Cls3 {}; // protected、public和private的访问符作用的对象分别为Cls2、Cls和Cls3类的所有成员。 struct Der: protected Cls2, public Cls, private Cls3 {}; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7621-%E8%AE%BF%E9%97%AE%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%88%86%E7%B1%BB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7621-访问说明符分类"
  },"482": {
    "doc": "类概念详解",
    "title": "7.622 访问说明符的访问权限",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7622-%E8%AE%BF%E9%97%AE%E8%AF%B4%E6%98%8E%E7%AC%A6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7622-访问说明符的访问权限"
  },"483": {
    "doc": "类概念详解",
    "title": "7.6221 类体中的访问说明符",
    "content": "公有访问(public)： . | 对于被控制成员所属类作用域外的对象来说： . | 可以通过该类的对象或者作用域运算符来对这些被控制成员进行访问。 | . | 对于被控制成员所属类作用域内的所有成员来说： . | 该类自己定义的成员： . | 可以通过该类的对象或者作用域运算符对这些被控制成员进行访问，还可以直接对其进行访问。 | . | 该类派生类的成员： . | 可以通过该类和该类派生类的对象以及作用域运算符对这些被控制成员进行访问，还可以直接对其进行访问。 | . | . | . // 公有访问: struct Cls { // 定义正确：Cls类自己定义的成员可以通过作用域运算符或者直接访问。 void cPrint() { cout &lt;&lt; Cls::ins &lt;&lt; str; } // 定义正确：Cls类自己定义的成员可以通过Cls类的对象obj访问。 void cPrint2() { Cls obj; cout &lt;&lt; obj.ins &lt;&lt; obj.str; } public: static const int ins = 5; string str = \"strs\"; }; struct Der: Cls { // 定义正确：Cls类的派生类Der的成员可以直接访问。 void dPrint() { cout &lt;&lt; ins &lt;&lt; str; } // 定义正确：Cls类的派生类Der的成员可以通过Cls类的对象obj和Cls类作用域运算符访问。 void dPrint2() { Cls obj; cout &lt;&lt; Cls::ins &lt;&lt; obj.str; } // 定义正确：Cls类的派生类Der的成员可以通过Der类的对象obj和Der类作用域运算符访问。 void dPrint3() { Der obj; cout &lt;&lt; Der::ins &lt;&lt; obj.str; } }; Cls obj; // 定义正确：Cls类作用域外的对象可以通过Cls类的对象obj或者Cls类作用域运算符来访问成员。 decltype(Cls::str) tmp_str = \"access data member\"; cout &lt;&lt; Cls::ins &lt;&lt; obj.str &lt;&lt; tmp_str; . 私有访问(private)： . | 对于被控制成员所属类作用域外的对象来说： . | 不能对这些被控制成员进行访问。 | . | 对于被控制成员所属类作用域内的所有成员来说： . | 该类自己定义的成员： . | 可以通过该类的对象或者作用域运算符对这些被控制成员进行访问，还可以直接对其进行访问。 | . | 该类派生类的成员： . | 不能对这些被控制成员进行访问。 | . | . | . // 私有访问: struct Cls { // 定义正确：Cls类自己定义的成员可以通过作用域运算符或者直接访问。 void cPrint() { cout &lt;&lt; Cls::ins &lt;&lt; str; } // 定义正确：Cls类自己定义的成员可以通过Cls类的对象obj访问。 void cPrint2() { Cls obj; cout &lt;&lt; obj.ins &lt;&lt; obj.str; } private: static const int ins = 5; string str = \"strs\"; }; struct Der: Cls { // 定义错误：Cls类的派生类Der的成员不能访问。 void dPrint() { cout &lt;&lt; ins &lt;&lt; str; } // 定义错误：Cls类的派生类Der的成员不能访问。 void dPrint2() { Cls obj; cout &lt;&lt; Cls::ins &lt;&lt; obj.str; } // 定义错误：Cls类的派生类Der的成员不能访问。 void dPrint3() { Der obj; cout &lt;&lt; Der::ins &lt;&lt; obj.str; } }; Cls obj; // 定义错误：Cls类作用域外的对象不能访问成员。 decltype(Cls::str) tmp_str = \"access data member\"; cout &lt;&lt; Cls::ins &lt;&lt; obj.str &lt;&lt; tmp_str; . 受保护访问(protected)： . | 对于被控制成员所属类作用域外的对象来说： . | 不能对这些被控制成员进行访问。 | . | 对于被控制成员所属类作用域内的所有成员来说： . | 该类自己定义的成员： . | 可以通过该类的对象或者作用域运算符对这些被控制成员进行访问，还可以直接对其进行访问。 | . | 该类派生类的成员： . | 可以通过该类派生类的对象以及作用域运算符对这些被控制成员进行访问，还可以直接对其进行访问，但不能通过该类的对象对这些被控制成员进行访问。 | . | . | . // 受保护访问: struct Cls { // 定义正确：Cls类自己定义的成员可以通过作用域运算符或者直接访问。 void cPrint() { cout &lt;&lt; Cls::ins &lt;&lt; str; } // 定义正确：Cls类自己定义的成员可以通过Cls类的对象obj访问。 void cPrint2() { Cls obj; cout &lt;&lt; obj.ins &lt;&lt; obj.str; } protected: static const int ins = 5; string str = \"strs\"; }; struct Der: Cls { // 定义正确：Cls类的派生类Der的成员可以直接访问。 void dPrint() { cout &lt;&lt; ins &lt;&lt; str; } // 定义错误：Cls类的派生类Der的成员可以通过Cls类作用域运算符访问，但不能通过Cls类的对象obj访问。 void dPrint2() { Cls obj; cout &lt;&lt; Cls::ins &lt;&lt; obj.str; } // 定义正确：Cls类的派生类Der的成员可以通过Der类的对象obj和Der类作用域运算符访问。 void dPrint3() { Der obj; cout &lt;&lt; Der::ins &lt;&lt; obj.str; } }; Cls obj; // 定义错误：Cls类作用域外的对象不能访问成员。 decltype(Cls::str) tmp_str = \"access data member\"; cout &lt;&lt; Cls::ins &lt;&lt; obj.str &lt;&lt; tmp_str; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#76221-%E7%B1%BB%E4%BD%93%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E8%AF%B4%E6%98%8E%E7%AC%A6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#76221-类体中的访问说明符"
  },"484": {
    "doc": "类概念详解",
    "title": "7.6222 类派生列表中的访问说明符",
    "content": "对于派生类来说，其直接基类的公有和受保护成员对于自己相关的访问权限和自己所定义的公有和受保护成员一样，所以其直接基类的公有和受保护成员可以看作为自己类所定义的公有和受保护成员。 . 所以类派生列表中的访问符不会影响该派生类自己所定义的成员对直接基类成员的访问权限，而派生类类体中的访问符也不会影响到继承自其直接基类的成员的访问权限。 . 类派生列表中的访问说明符是对其后紧跟的那个直接基类的所有成员起作用的，对于派生类来说： . | 公有继承(public)： 无影响。 | 私有继承(private)： 将从对应的直接基类继承而来的公有和受保护成员的访问权限改为私有访问。 | 受保护继承(protected)： 将从对应的直接基类继承而来的公有成员的访问权限改为受保护访问。 | . struct Cls { private: int ins; static int sta_ins; protected: double dou; static double sta_dou; public: string str; static string sta_str; }; /* 公有继承的作用类似于以下形式： struct Der { protected: double dou; static double sta_dou; public: string str; static string sta_str; }*/ struct Der: public Cls {}; /* 私有继承的作用类似于以下形式： struct Der { private: double dou; static double sta_dou; private: string str; static string sta_str; }*/ struct Der: private Cls {}; /* 受保护继承的作用类似于以下形式： struct Der { protected: double dou; static double sta_dou; protected: string str; static string sta_str; }*/ struct Der2: protected Cls {}; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#76222-%E7%B1%BB%E6%B4%BE%E7%94%9F%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E8%AF%B4%E6%98%8E%E7%AC%A6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#76222-类派生列表中的访问说明符"
  },"485": {
    "doc": "类概念详解",
    "title": "7.6223 默认的访问权限",
    "content": "之前我们接触过一些简单的访问控制： 在类定义时所用的关键字struct和class就是一种简单的访问控制。 . 关键字struct和class在定义类时的作用相同，它们的区别也就是对于该定义类的成员默认访问权限： . | 对于类体中所有的没有访问符控制的成员来说： . | 关键字struct代表公有访问。 | 关键字class代表私有访问。 | . | 对于类派生列表中所有的没有访问符控制的直接基类来说： . | 关键字struct代表公有继承。 | 关键字class代表私有继承。 | . | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#76223-%E9%BB%98%E8%AE%A4%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#76223-默认的访问权限"
  },"486": {
    "doc": "类概念详解",
    "title": "7.623 用using声明语句调整访问权限",
    "content": "我们有一种特殊的方法可以调整类成员的访问权限，也就是之前在7.454 覆盖重载的函数中提到的using声明语句。使用using声明语句可以用来调整成员的访问权限。 . 我们可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）在using声明语句中显式指明出来。 . 形式为： . using 基类名::成员名; . 给定基类中所有该定义类可访问的给定名字的成员的访问权限由该using声明语句所在位置的访问权限来决定的，并且对这些成员访问权限的更改是永久的，是可继承的。 . struct Ba0 { void bPrint() { cout &lt;&lt; \"Ba0\\n\"; } }; struct Ba: Ba0 { void b2Print() { cout &lt;&lt; \"Ba\\n\"; } protected: void b2Print(int val) { cout &lt;&lt; val &lt;&lt; \" Ba\\n\"; } }; struct Der: Ba { // 将Ba的两个b2Print成员的权限改为公有 using Ba::b2Print; private: // 将Ba0的bPrint成员的权限改为私有 using Ba0::bPrint; }; struct Der2: Der {}; Ba0 obj; Ba obj2; Der obj3; Der2 obj4; // 正确：Ba0类中的bPrint为公有 obj.bPrint(); // 错误：Der类中的bPrint被改为私有 obj3.bPrint(); // 错误：Ba类中的b2Print为受保护的 obj2.b2Print(6); // 正确：Der类中的b2Print被改为公有 obj3.b2Print(6); // 正确：Der2类继承来自Der类中的公有成员b2Print obj4.b2Print(6); . using语句中，给定基类的所有给定名字的成员中不能含有定义类不可访问的成员，否则出错。 . struct Cls { private: void prints() {} }; // 错误：using语句中不能含有不可访问的成员 struct Cls2: Cls { using Cls::prints; } . 一个类中不能有多个对同一个成员的using声明语句，否则就是重复声明。 但是可以有该类的基类中同名但不同作用域的多个成员的using声明语句。 . struct Cls { void prints() {} void ret() {} }; struct Cls2: Cls { void ret() {} } class Cls3: Cls2 { // 错误：Cls3类中不能有多个对同一成员prints的using声明语句。 using Cls2::prints; using Cls::prints; // 正确：一个是基类Cls2定义的函数ret，一个是基类Cls定义的函数ret，两个函数作用域不一样。 using Cls2::ret; using Cls::ret; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7623-%E7%94%A8using%E5%A3%B0%E6%98%8E%E8%AF%AD%E5%8F%A5%E8%B0%83%E6%95%B4%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7623-用using声明语句调整访问权限"
  },"487": {
    "doc": "类概念详解",
    "title": "7.63 友元",
    "content": "我们可能会需要某些非该类的成员的函数或者其他类对该类进行一些操作，并希望这些函数或者类能够访问该类的非公有成员。 此时，我们可以将这些其他类或者函数声明为该类的友元。 . 要注意，友元不是该类的成员，它是该类作用域外的对象，所以不受该类访问控制的约束。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#763-%E5%8F%8B%E5%85%83",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#763-友元"
  },"488": {
    "doc": "类概念详解",
    "title": "7.631 友元的声明形式",
    "content": "友元的声明形式为： . friend 类或者函数的声明语句 . 友元声明中的声明语句一定要与该友元的声明部分一模一样，否则就不是该友元的声明，无意义了。 . 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。 不过一般来说，最好在类定义开始或结束前的位置集中声明友元。 . void prints(int val) {} struct Other {}; struct Cls { // Cls类的友元函数声明 friend void prints(int val); int ins; // Cls类的友元类声明 friend struct Other; }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7631-%E5%8F%8B%E5%85%83%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7631-友元的声明形式"
  },"489": {
    "doc": "类概念详解",
    "title": "7.632 友元声明的特点",
    "content": "友元声明不是真正的声明，它仅仅是指定了一个访问的权限，而非一个通常意义上的声明。 . 根据友元的不同，友元声明有两种区别： . | 对于友元类声明来说，该友元必须是定义类所能访问到的(也就是必须要可见且能访问)。 | 对于友元函数声明来说，该友元可以是在定义类的作用域中不存在的实体。 所以如果我们希望使用到某个友元函数，那么我们就必须要确保在使用位置所在的作用域中存在该友元函数的真正声明和定义，而不只是在定义类内的友元声明。 | . struct Cls { // 正确：友元可以是不存在的。 friend void prints(); }; // 错误：友元声明不是真正的声明，所以prints不存在。 prints(); . 友元函数还可以是其他类的函数成员，但是因为作用域运算符只能用于类的成员，所以要保证该友元函数在该其他类中有声明才行，否则出错。 . struct Other { void prints(); }; struct Cls { // 错误：prints是类Other的成员，要用作用域运算符 friend void prints(); // 正确 friend void Other::prints(); }; . 普通友元函数(不能是类类型或者成员函数)能定义在类的内部，且这样的函数是隐式内联的，形式为： . friend 函数的定义语句 . 要注意定义在类内部的友元函数并不是这个类的成员，只是这个类的友元函数，所以不要把该友元函数看成了类成员。 . 因为友元声明不是真正的声明，所以我们必须在类的外部提供相应的函数声明从而使得函数可见。 . struct Other { void prints2(); }; struct Cls { // 错误：友元类不能在类内定义。 friend struct Friend_cls {}; // 错误：友元成员函数不能在类内定义。 friend void Other::prints2() { cout &lt;&lt; \"memfunc_friend\\n\"; }; // 正确 friend void prints() { cout &lt;&lt; \"func_friend\\n\"; } }; // 错误：友元声明不是真正的声明，所以prints未定义 prints(); // 声明了prints void prints(); // 正确 prints(); . 友元不是其定义类的成员，所以没有传递性，也不能被继承。一个类的友元只单单作用于这个类。 . // prints函数只能访问Cls的成员，不能访问Cls2的成员 void prints() {}; class Cls { friend void prints(); }; class Cls2: Cls {}; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7632-%E5%8F%8B%E5%85%83%E5%A3%B0%E6%98%8E%E7%9A%84%E7%89%B9%E7%82%B9",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7632-友元声明的特点"
  },"490": {
    "doc": "类概念详解",
    "title": "7.633 友元的访问权限",
    "content": "友元能够像其定义类自己定义的成员一样，除了该类基类的私有成员外，可以对该类其他所有成员进行访问。 . 友元类的访问方式和其定义类的静态函数成员的访问方式一样： . | 对于其定义类的非静态成员，友元只能通过该类的对象进行访问。 | 对于其定义类的静态成员，友元可以直接访问、或者通过该类的对象和作用域运算符进行访问。 | 对于其定义类的类类型成员，友元可以直接访问、或者通过作用域运算符进行访问。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7633-%E5%8F%8B%E5%85%83%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7633-友元的访问权限"
  },"491": {
    "doc": "类概念详解",
    "title": "7.7 继承详述",
    "content": "之前我们介绍过基类和派生类以及它们之间的关系。接下来会介绍一些关于继承方面的操作与特性。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#77-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%BF%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#77-继承详述"
  },"492": {
    "doc": "类概念详解",
    "title": "7.71 阻止继承",
    "content": "通常情况下，每个类都可以将其他的类当成其基类，但有时我们会定义这样一种类，我们不希望其他类继承它。 为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在定义该类时，在类名后跟一个关键字final，形式为： . class/struct 类名 final (可选 类派生列表) 类体 (可选 类对象列表); . 关键字final只能在定义类时使用，不能用于类的声明，且该类在定义时不能省略类名。 . 被关键字final标记的类不能出现在类定义的派生列表中。 . class NoDerived final { /* */ }; // NoDerived不能作为基类 class Base {/**/}; // Last是final的；我们不能继承Last class Last final : Base { /* */ }; // Last不能作为基类 class Bad : NoDerived { /* */ }; // 错误：NoDerived 是 final 的 class Bad2 : Last { /* */ }; //错误：Last是final的 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#771-%E9%98%BB%E6%AD%A2%E7%BB%A7%E6%89%BF",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#771-阻止继承"
  },"493": {
    "doc": "类概念详解",
    "title": "7.72 继承之间的类型转换",
    "content": "之间我们讲述过算术类型之间的转换，通常情况下，类型之间的转换是发生在两种有关联的类中的。 . 派生类向基类的隐式转换 . 基类和其派生类之间，其实也是存在某种关联的，派生类继承其基类的所有成员，且派生类的作用域也是在其基类的作用域内的。 所以，对于一个派生类对象来说，该对象以及该对象的引用和指针都能隐式转换为其任意基类(包括其所有的直接和间接基类，或者虚基类)的对象以及该基类的引用或指针，前提是==该派生类对象的这个基类部分在使用的位置是可访问的(与这个基类部分的基类本身的成员是不是可访问的无关)==。 . 派生类可以隐式转换为其基类，但是反过来是不行的，基类不能隐式转换为其派生类。 虽然基类可以显式转换为派生类，但是只支持转换为派生类的引用与指针，且转换时可能会出现未定义行为。 . 对于函数匹配来说，这种转换为类类型转换，不管向哪个基类转换，其优先级别都一样，不存在转换成谁更好。 . struct Ba{}; struct Ba2{}; struct De:Ba {}; struct De2: De, Ba2 {}; void prints(De val) {} void prints(Ba val) {} De2 obj; De2 *Dptr = &amp;obj; // 正确：派生类De2对象转换成基类De的对象 De obj2 = obj; // 正确：派生类De2对象的转换成基类Ba的引用 Ba &amp;obj3 = obj; // 正确：指向派生类De2对象的指针转换成指向基类Ba2的指针 Ba2 *obj4 = Dptr; // 错误：二义性，De2转换成De和Ba一样好 prints(obj); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#772-%E7%BB%A7%E6%89%BF%E4%B9%8B%E9%97%B4%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#772-继承之间的类型转换"
  },"494": {
    "doc": "类概念详解",
    "title": "7.721 静态类型与动态类型",
    "content": "在派生类向基类的转换过程中，类为了实现多态性，而对转换作出了一种特殊的操作，这也就是动态绑定。为了实现动态绑定，于是在继承中就有了静态类型与动态类型的说法。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7721-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7721-静态类型与动态类型"
  },"495": {
    "doc": "类概念详解",
    "title": "7.7211 静态与动态类型区别",
    "content": "当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型（static type）与该表达式表示对象的动态类型（dynamic type）区分开來。 . | 静态类型的表达式类型，在编译时总是已知的，它是变量声明时的类型或者表达式计算结果的类型。 | 动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。 | . 静态类型与动态类型主要是用于有继承关系的类的引用与指针。 对于既不是引用也不是指针的表达式，则它的动态类型永远为其静态类型。 . 要注意，动态类型是表达式的内存中的对象的类型，所以对于多个类的引用与指针连用来说，它们的动态类型都是其源头的那个表达式的类型。 . struct Ba { virtual void prints() { cout &lt;&lt; \"Ba\\n\"; } }; struct De:Ba { virtual void prints() { cout &lt;&lt; \"De\\n\"; } }; struct De2:De { virtual void prints() { cout &lt;&lt; \"De2\\n\"; } }; De2 obj; De &amp;r = obj; // 动态类型为De2 Ba *p = &amp;r; // 调用的是De2类的，输出De2 p-&gt;prints(); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#77211-%E9%9D%99%E6%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#77211-静态与动态类型区别"
  },"496": {
    "doc": "类概念详解",
    "title": "7.7212 转换中的成员变化",
    "content": "当派生类对象转换为基类的对象以及该基类的引用或指针时，派生类对象的成员会根据其静态类型有所变化。所有非继承于其静态类型的成员都会被切掉(sliced down)，也就是这些成员不再存在了，具体的可以分为两种。 . 被切掉的成员有两种情况： . | 当只是转换为基类的对象而非为指针或引用时，这种情况是拷贝、移动或赋值，基类的对象只会继承于该基类的成员的数据，其他的成员数据都不保存(包括各种同名成员)。 因为是拷贝、移动或赋值得到的数据，所以当该基类对象又显式转换成派生类时，非该基类成员的值是未定义的。 | 当转换为基类的引用或者指针时，会切掉除了所有覆盖该基类的虚函数外的其他所有非继承于该基类的成员(包括各种同名成员)。 但由于是引用或指针，原派生类对象的内存还在，所以当该基类对象又显式转换成派生类时，非该基类成员的值恢复为内存的对应成员的值。 | . 一个其类型有继承关系的表达式不能用非静态类型所属的成员。 但如果该表达式为引用或指针，且其动态类型覆盖了静态类型的某些虚函数，则该表达式只能用这些虚函数的动态类型版本而无法使用静态类型版本。 . struct Ba { virtual void prints() { cout &lt;&lt; \"Ba\\n\"; } int Bins = 48; }; struct De:Ba { virtual void prints() { cout &lt;&lt; \"De\\n\"; } int Dins = 30; De(int bins, int dins): Dins(dins) { this-&gt;Bins = bins; } }; De dObj(-8,-3); // dObj转换为基类Ba的对象 Ba bObj = dObj; // dObj转换为基类Ba的对象的引用 Ba &amp;r = dObj; // bObj只是基类对象，转换会派生类De的对象的引用，非Ba成员的值未定义 De dr = static_cast&lt;De&amp;&gt;(bObj); // 而r是基类对象的引用，转换为派生类De的对象的引用，非Ba成员的值恢复为内存dObj的对应成员的值 De dr2 = static_cast&lt;De&amp;&gt;(r); // 输出De dr.prints(); dr2.prints(); // Dins的值未定义 cout &lt;&lt; dr.Dins &lt;&lt; \"\\n\"; // Dins的值恢复为内存dObj的Dins值，输出-3 cout &lt;&lt; dr2.Dins &lt;&lt; \"\\n\"; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#77212-%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#77212-转换中的成员变化"
  },"497": {
    "doc": "类概念详解",
    "title": "7.7213 派生类向基类转换的可访问性",
    "content": "派生类向基类的转换是否可访问由使用该转换的位置决定，同时派生类的派生访问说明符也会有影响。 . 假定D继承自B: . | 只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换 | 不论D以什么方式继承B, D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元來说，永远是可访问的。 | 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则D的派生类的成员和友元不能使用该类型转换。 | . class Ba{}; class De: public Ba{}; class De2: protected Ba{ friend void test2(); }; class De3:Ba{ friend void test2(); }; De obj; De2 obj2; De3 obj3; void test() { // 以下三种定义语句都正确：obj中的Ba部分为公有继承，函数test是可以访问到其Ba部分的。 Ba *ptr = &amp;obj; Ba &amp;r = obj; Ba bobj = obj; // 以下三种定义语句都错误：obj2中的Ba部分为受保护继承，函数test不能访问到其Ba部分。 Ba *ptr2 = &amp;obj2; Ba &amp;r2 = obj2; Ba bobj2 = obj2; // 以下三种定义语句都错误：obj3中的Ba部分为私有继承，函数test不能访问到其Ba部分。 Ba *ptr3 = &amp;obj3; Ba &amp;r3 = obj3; Ba bobj3 = obj3; } void test2() { // 以下三种定义语句都正确：obj中的Ba部分为公有继承，函数test2是可以访问到其Ba部分的。 Ba *ptr = &amp;obj; Ba &amp;r = obj; Ba bobj = obj; // 以下三种定义语句都正确：obj2中的Ba部分为受保护继承，但是函数test是De2的友元，所以可以访问到其Ba部分。 Ba *ptr2 = &amp;obj2; Ba &amp;r2 = obj2; Ba bobj2 = obj2; // 以下三种定义语句都正确：虽然obj3中的Ba部分为私有继承，但是函数test是De3的友元，所以可以访问到其Ba部分。 Ba *ptr3 = &amp;obj3; Ba &amp;r3 = obj3; Ba bobj3 = obj3; } . 总而言之，对于调用位置来说，如果基类的公有成员是可访问的，则其派生类就可以转换为该基类；反之则不行。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#77213-%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%90%91%E5%9F%BA%E7%B1%BB%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#77213-派生类向基类转换的可访问性"
  },"498": {
    "doc": "类概念详解",
    "title": "7.722 运行时类型识别",
    "content": "我们之前讲述过有关虚函数的知识，虚函数的作用是使其类通过引用或者指针来调用该函数时，执行动态绑定，即在运行时选择该函数的版本，所以动态绑定也叫做运行时绑定(run-time binding)。 . 虚函数的这种性质也是运行时类型识别(run-time type identification，RTTI)的功能的一部分，使用RTTI功能可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。 . RTTI功能还有另外两个部分： . | dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或 引用。 | typeid运算符，用于返回表达式的类型。 | . 当我们将这两个运算符用于某种类型的指针或引用，并且该类型含有虚函数时，运算符将使用指针或引用所绑定对象的动态类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7722-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7722-运行时类型识别"
  },"499": {
    "doc": "类概念详解",
    "title": "7.7221 dynamic_cast运算符",
    "content": "dynamic_cast运算符是显式类型转换的一种，可以用于基类与派生类的相互转换。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#77221-dynamic_cast%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#77221-dynamic_cast运算符"
  },"500": {
    "doc": "类概念详解",
    "title": "7.72211 dynamic_cast的使用形式",
    "content": "dynamic_cast运算符的使用形式只有以下三种，为： . | dynamic_cast&lt;type*&gt; (e) . | dynamic_cast&lt;type&amp;&gt; (e) . | dynamic_cast&lt;type&amp;&amp;&gt; (e) . | . 其中，type必须是类类型，e必须是一个表达式，且e中不能含有类型名。 在第一种形式中，e必须是一个有效的指针； 在第二种形式中，e必须是一个左值； 在第三种形式中，e不能是左值。 . 这三种形式情况下都返回指定的type相关类型，且都为左值。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#772211-dynamic_cast%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#772211-dynamic_cast的使用形式"
  },"501": {
    "doc": "类概念详解",
    "title": "7.72212 dynamic_cast的使用条件",
    "content": "在上面的所有形式中，e的类型必须符合以下三个条件中的任意一个，否则就会编译出错： . | e的静态类型必须是目标type的公有继承派生类，此时e的静态类型和type类型都可以不含虚函数。 | e的静态类型就是目标type的类型，此时e的静态类型和type类型都可以不含虚函数。 | e的静态类型是目标type的公有继承基类，此时e的静态类型必须要含有虚函数，type类型可以不含虚函数。 | . 在编译正确的情况下，e的动态类型还必须为type的公有继承派生类或者就是type的类型(此时e的动态类型和type类型都可以不含虚函数)，否则类型转换失败。 . 如果一条dynamic_cast表达式的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个名为std::bad_cast异常，该异常定义在typeinfo标准库头文件中。 . 因为转换成功的要求是e的动态类型必须为type的公有继承派生类或者就是type的类型，所以e的静态类型显式转换成其派生类型时，是安全的。 因为e的内存是它们的公有继承派生类，含有各种基类的成员，所以转换后，非该静态类型成员的值会变为内存中对应成员的值。 . struct Ba { virtual void prints(string val) {cout &lt;&lt; val &lt;&lt; \" stringBa\\n\";} }; struct De:Ba { void prints(int val) {cout &lt;&lt; val &lt;&lt; \" intDe\\n\";} }; struct De2: De { void prints(double val) {cout &lt;&lt; val &lt;&lt; \" doubleDe2\\n\";} }; De2 d2_obj; De d_obj; Ba *d2r = &amp;d2_obj; Ba &amp;dr = d_obj; /* d2r的静态类型为Ba，为De的公有基类， 因为Ba有虚函数，所以编译正确； d2r的动态类型为De2，为De的公有派生类，所以转换成功。*/ De* ptr = dynamic_cast&lt;De*&gt;(d2r); /* dr的静态类型为Ba，为De2的公有基类， 因为Ba有虚函数，所以编译正确； dr的动态类型为De，不是De2的公有派生类， 所以转换失败，引发std::bad_cast异常*/ De2&amp; rr = dynamic_cast&lt;De2&amp;&gt;(dr); . 因为dynamic_cast运算符返回的都是对应类型的指针或者引用，所以当存在动态绑定时仍会进行动态绑定。 . struct Ba { virtual void prints(string val) {cout &lt;&lt; val &lt;&lt; \" stringBa\\n\";} }; struct De:Ba { void prints(string val) override {cout &lt;&lt; val &lt;&lt; \" stringDe\\n\";} }; struct De2: De { void prints(string val) override {cout &lt;&lt; val &lt;&lt; \" stringDe2\\n\";} }; De2 d2_obj; Ba *d2p = &amp;d2_obj; // 输出str stringDe2 d2p-&gt;prints(\"str\"); // ptr的动态类型仍是De2类 De *ptr = dynamic_cast&lt;De*&gt;(d2p); // 输出str stringDe2 ptr-&gt;prints(\"str\"); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#772212-dynamic_cast%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#772212-dynamic_cast的使用条件"
  },"502": {
    "doc": "类概念详解",
    "title": "7.7222 typeid运算符",
    "content": "typeid运算符(typeid operator) 有些类似于decltype说明符，它会说明给定表达式的类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#77222-typeid%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#77222-typeid运算符"
  },"503": {
    "doc": "类概念详解",
    "title": "7.72221 typeid运算符的使用形式",
    "content": "typeid运算符的使用形式为： . typeid(e) . e为右值，可以是： . | 任意的非声明或定义表达式。 | 类型名(包含类型修饰符) | . typeid返回左值，该值为一个常量对象的引用，这个引用包含e表达式的计算结果的类型或者是e所给的类型。 这个引用的类型是标准库类型type_info或者type_info的公有派生类型。 type_info类定义在typeinfo头文件中。 . 对于e值的不同，typeid会有以下的特点： . | 对于e表达式的计算结果的类型或者是e所给的类型，typeid会忽略其顶层const。 | 当e表达式的计算结果为左值且计算结果的静态类型至少含有一个虚函数时，typeid所得的类型直到运行时才会求得，为该所得类型为e表达式计算结果的动态类型。此时，e表达式必须是一个有效值，否则，运行时typeid将抛出一个名为bad_typeid的异常。 | 当e表达式不满足计算结果为左值且计算结果的静态类型至少含有一个虚函数的条件时，typeid所得类型将会是计算结果的静态类型，且无须对表达式求值也能知道其表达式的静态类型。 | . 所以，当typeid作用于指针时(而非指针所指的对象)，返回的结果是该指针的静态类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#772221-typeid%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#772221-typeid运算符的使用形式"
  },"504": {
    "doc": "类概念详解",
    "title": "7.72222 type_info类",
    "content": "type_info类的精确定义随着编译器的不同而略有差异。 不过，C++标准规定type_info类必须定义在typeinfo头文件中，并且至少提供以下的操作： . | 操作 | 解释 | . | t1 == t2 | 如果type_info的对象t1和t2是同一种类型，就返回true；否则返回false。 | . | t1 != t2 | 如果type_info的对象t1和t2表示的是不同的类型，就返回true；否则返回false。 | . | t.name() | 返回一个字符串字面值，表示类型名字的可打印形式。类型名字的生成方式因系统而异。 | . | t1.before(t2) | 返回一个bool值，表示t1对象在编译器的储存顺序是否位于t2之前。所采用的顺序关系是依赖于编译器的。 | . type_info类没有默认构造函数，而且它的拷贝和移动构造函数以及赋值运算符都被定义成删除的。因此，我们无法定义或拷贝type_info类型的对象，也不能为type_info类型的对象赋值。 创建type_info对象的唯一途径 是使用typeid运算符。 . type_info类一般是作为一个基类出现，所以它还应该提供一个公有的虚析构函数。当编译器希望提供额外的类型信息时，通常在type_info的派生类中完成。 . type_info类的name成员函数返回一个字符串字面值，表示所得的类型名字。 对于某种给定的类型来说，name的返回值因编译器而异并且不一定与在程序中使用的名字一致。 对于name返回值的唯一要求是，类型不同则返回的字符串必须有所区别。 . type_info类在不同的编译器上有所区别。有的编译器提供了额外的成员函数以提供程序中所用类型的额外信息。读者应该仔细阅读你所用编译器的使用手册，从而获取关于type_info的更多细节。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#772222-type_info%E7%B1%BB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#772222-type_info类"
  },"505": {
    "doc": "类概念详解",
    "title": "7.73 虚继承",
    "content": "之前说过，一个类可以有多个直接基类。 . 虽然派生类的类派生列表中不能有相同的直接基类，但是一个类可能会多次继承同一个类的成员。比如其有多个直接基类继承了同一个类，导致该类多次继承了这个类。 . 在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个相同部分。 这就会导致当使用这个包含多个部分的类的成员时，就会编译错误，提示出现二义性。 . 这种问题可以通过两种方法解决： . | 通过作用域运算符显式指定哪一个类中的。 | 使用虚继承。 | . 在C++语言中，我们可以通过虚继承(virtual inheritance)的机制解决上述问题。 虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类被称为虚基类(virtual base class)。 在某个类的虚基类会与其他同名的虚基类共享一个基类部分。 . 虚基类的作用为： . | 对于某个类的所有基类来说，其中所有同名的虚基类在该派生类中只会出现一个该基类部分，而不会出现多个部分。 | 所有同名的虚基类会共享这一个部分，所以这一个部分是属于任意一个同名虚基类的。 | . 之前说过虚继承的使用方式，是在类派生列表中的某个需要声明为虚基类的类前加上关键字virtual，其中与派生访问说明符的顺序可以任意： . virtual 基类名 . struct Base {}; // Der和Der2类虚继承Base类 struct Der: private virtual Base {}; struct Der2: virtual protected Base {}; . 被关键字virtual标记的类的这一个副本在该派生类以及该派生类的派生类中就成为了虚基类。 要注意是这个类的副本在该派生类的派生列表中被标记为虚基类，而不是该类被标记成了虚基类，其他继承该类的派生类如果没有显式标记其为虚基类，则该类在这些派生类中仍然不是虚基类。 . struct Ba { string bStr = \"ba\"; }; // 虚继承Ba，Ba在该类中为虚基类 struct De: virtual Ba { string dStr = \"de\"; }; // 非虚继承Ba，所以Ba在该类中仍为普通基类 struct De2: Ba { string d2Str = \"de2\"; }; // 包含两个Ba的部分，一个Ba为虚基类，一个不是虚基类 struct De3: De, De2 { string d3Str = \"de3\"; }; De3 obj; // 错误：二义性调用 cout &lt;&lt; obj.bStr; . 因为虚基类之间共享一个基类，所以就有效的解决了二义性问题。 不过要注意上面例子中，同一个基类的虚继承与普通继承混用的情况，当一个基类在某类中，既是有虚基类部分，又有非虚基类部分，则根据虚继承的性质，该派生类有非虚基类部分的数目加1个该基类的部分，还是会有二义性问题。所以尽量不要出现对同一个基类虚继承与普通继承混用的情况。 . struct Ba { string bStr = \"ba\"; }; // 虚继承Ba，Ba在该类中为虚基类 struct De: virtual Ba { string dStr = \"de\"; }; // 也是虚继承Ba，Ba在该类中为虚基类 struct De2: virtual Ba { string d2Str = \"de2\"; }; // 只包含一个Ba的部分，两个虚基类共享同一个部分 struct De3: De, De2 { string d3Str = \"de3\"; }; De3 obj; // 正确：输出ba cout &lt;&lt; obj.bStr; . struct Ba { string bStr = \"ba\"; }; // 虚继承Ba，Ba在该类中为虚基类 struct De: virtual Ba { string dStr = \"de\"; }; // 只包含一个Ba的部分，两个虚基类共享同一个部分 struct De2: De, virtual Ba { string d2Str = \"de2\"; }; // 正确：输出ba cout &lt;&lt; obj.bStr; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#773-%E8%99%9A%E7%BB%A7%E6%89%BF",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#773-虚继承"
  },"506": {
    "doc": "类概念详解",
    "title": "7.8 类类型转换",
    "content": "之前我们介绍过一些内置类型的转换规则，和内置类型一样，我们自定义的类型也可以定义相关的转换规则。 . 对于类类型转换(class-type conversions)，有时也被称作用户定义的类型转换(user-defined conversions)，有两种定义方法： . | 转换构造函数(converting constructor) | 类型转换运算符 | . 类类型的隐式转换也要遵循类型转换的规则： 编译器毎次只能执行一种类类型的隐式转换，否则转换失败。 但是类类型的隐式转换可以置于算术类型的隐式转换之前或之后，与其一起使用。 . 接下来我们就来逐个介绍这两种类类型转换方法。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#78-%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#78-类类型转换"
  },"507": {
    "doc": "类概念详解",
    "title": "7.81 转换构造函数",
    "content": "任何构造函数只要满足：第一个形参的类型是所要转换成该类类型的类型(该形参可以有默认实参)，没有其他形参或者其他的形参都有默认实参。 那么该构造函数就是一个转换构造函数(converting constructor)。 . 所以有形参的默认构造函数也就是一个转换构造函数。 . 和普通构造函数一样，转换构造函数也能支持重载等操作。 . struct Cls { int ins; double dou; // 转换构造函数 Cls(int int_val, double dou_val = 12): ins(int_val), dou(dou_val) {} }; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#781-%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#781-转换构造函数"
  },"508": {
    "doc": "类概念详解",
    "title": "7.811 转换构造函数的使用",
    "content": "在任何需要该类型对象的地方，如果我们只给了一个可以转换成该类型的其他类型对象，隐式地将这个对象转换成该类型的对象(临时对象)。 . 具体来说，也就是编译器会按照所给对象的类型匹配将要转换的类型中的转换构造函数，然后根据所给对象的值调用该转换构造函数并生成一个对应类型的临时对象，该对象即是执行转换后的对象。 . struct Cls { int ins; // 转换构造函数 Cls(int int_val): ins(int_val) {} }; void prints(Cls other) { cout &lt;&lt; other.ins; } Cls obj(15); // 输出15 cout &lt;&lt; obj.ins; // 调用Cls的转换构造函数，生成了一个成员ins为35的Cls对象，并将其赋值给obj。 obj = 35; // 输出35 cout &lt;&lt; obj.ins; // 调用Cls的转换构造函数，生成了一个成员ins为65的Cls对象，并将其赋值给prints的形参other。\\ 输出65 prints(65); . struct Cls { int ins; Cls(int int_val): ins(int_val) {} }; struct Cls2 { Cls cls; Cls2(Cls obj): cls(obj) {} }; Cls obj(3); // 错误：该表达式需要的类型转换顺序为int-&gt;Cls-&gt;Cls2，\\ 但是编译器毎次只能执行一种类类型的隐式转换。 Cls2 obj2 = 8; // 正确：该表达式需要的类型转换顺序为int-&gt;Cls-&gt;Cls2，\\ 但int-&gt;Cls是显式转换。 Cls2 obj2 = Cls(8); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7811-%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7811-转换构造函数的使用"
  },"509": {
    "doc": "类概念详解",
    "title": "7.812 显式构造函数",
    "content": "当我们想阻止某个转换构造函数的隐式转换时，可以在该转换构造函数的声明或定义语句之前用关键字explicit进行声明，该函数也就叫做显式构造函数。 . 形式为： . explicit 转换构造函数的声明或定义语句 . 和声明静态函数一样，关键字explicit只能在类内声明或定义中使用，当转换构造函数在类外定义时不要加关键字explicit，否则出错。 . struct Cls { int ins; // 被声明为explicit的转换构造函数 explicit Cls(int int_val); }; Cls::Cls(int int_val): ins(int_val) {} . 被声明为explicit的转换构造函数除了能用于显式转换，只能用于直接初始化，不能用于拷贝初始化，所以编译器将不会在自动转换过程中使用该转换构造函数。 . #include &lt;iostream&gt; using namespace std; struct Cls { int ins; // 被声明为explicit的转换构造函数 explicit Cls(int int_val); }; Cls::Cls(int int_val): ins(int_val) {} int main() { // 错误：不能进行隐式转换 Cls obj = 15; // 正确：显式调用该转换构造函数进行转换。 Cls obj2 = static_cast&lt;Cls&gt;(15); // 正确：显式直接初始化调用该转换构造函数 Cls obj3 = Cls(15); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7812-%E6%98%BE%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7812-显式构造函数"
  },"510": {
    "doc": "类概念详解",
    "title": "7.82 重载运算符简述",
    "content": "在介绍类型转换运算符之前，我们需要了解一点儿有关重载运算符(overloaded operator)的知识。 . 重载运算符本质上就是函数，可以声明或者定义。其名字由operator关键字后接表示要定义的运算符的符号组成。 . 大部分的重载运算符声明形式为: . | 返回类型 operator 运算符号 形参表 (可选 限定符); . | auto operator 运算符号 形参表 -&gt; 返回类型 (可选 限定符); . | . 比如，赋值运算符就是一个函数。 类似于任何其他函数，大部分的运算符函数也有一个返回类型和一个参数列表。 . 重载运算符的每个形参是表示运算符的每个运算对象，一个重载运算符的形参数量必须要与其运算对象数目相同。 . 和普通函数一样，相同运算符的重载运算符可以定义多个，也就是重载运算符的重载，其也要遵循函数重载的规则。 . 有些重载运算符只能是普通函数或者是成员函数，比如赋值运算符只能为成员函数；但对于另外一些重载运算符，它们既可以是普通函数，也可以是成员函数，比如算术运算符。 . 作为成员函数的重载运算符和普通成员函数一样，可以定义在类内或类外，也可以为静态、const、引用或者虚函数成员。 . 如果一个运算符是一个非静态成员函数，则其左侧的运算对象就绑定到隐式的this参数，其他的运算对象就按照顺序绑定到其他显式形参上。 比如，对于一个二元运算符如赋值运算符来说，左侧的运算对象绑定到隐式的this参数，其右侧运算对象就作为显式参数传递。 . 除了重载的函数调用运算符operator()之外，其他重 载运算符都不能含有默认实参。 . struct Cls { int ins = 5; // 赋值运算符：\\ 为成员函数，\\ 左侧运算对象为该类对象，\\ 右侧运算对象为int对象，\\ 返回赋值后的左侧运算对象 Cls&amp; operator=(int val) { this-&gt;ins = val; return *this; } }; // 加法运算符：\\ 为普通函数，\\ 左侧运算对象为Cls类对象，\\ 右侧运算对象为int对象，\\ 返回执行加法后的int值。 int operator+(Cls&amp; cls, int val) { return cls.ins + val; } . 对于重载运算符，我们有两种调用方法： . | 隐式调用： 当我们定义了重载运算符后，在这些重载运算符的可用范围内，当出现含有运算符的表达式时，就会根据运算符的运算对象的类型隐式调用匹配的重载运算符；比如，对于某个运算对象为类类型对象来说，编译器会首先自动调用该对象类型的对应非静态重载运算符。 | 显式调用： 因为重载运算符也是函数，所以我们可以用调用函数的形式显式调用重载运算符，并在实参表中传递对应类型的实参。 | . struct Cls { int ins = 5; Cls&amp; operator=(int val) { this-&gt;ins = val; return *this; } }; int operator+(Cls&amp; cls, int val) { return cls.ins + val; } Cls obj; // 隐式调用成员函数Cls&amp; operator=(int val)。 obj = 78; // 显式调用成员函数Cls&amp; operator=(int val)。 obj.operator=(30); // 输出30 cout &lt;&lt; obj.ins; // 以下都为调用普通函数int operator+(Cls&amp; cls, int val)。 // 隐式调用，输出45 cout &lt;&lt; obj + 15; // 显式调用，输出45 cout &lt;&lt; operator+(obj, 15); . 所以对于静态重载运算符来说，只能显式调用来使用该运算符函数。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#782-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%AE%80%E8%BF%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#782-重载运算符简述"
  },"511": {
    "doc": "类概念详解",
    "title": "7.83 类型转换运算符",
    "content": "类型转换运算符(conversion operator)是一种特殊重载运算符，它负责将所属类的对象转换成其他类型的对象(临时对象)。 . 它的使用形式与一般的重载运算符不同，声明形式为： . operator 类型名() (可选 类型限定符); . 其中类型名是运算符指定的类型，它表示将要转换成的类型。该类型可以为除void之外的任意类型，只要该类型能作为函数的返冋类型就行。 所以，我们不允许转换成数组或者函数类型，但允许转换成指针(包括数组指针及函数指针)或者引用类型。 . 类型转换运算符不能写返回类型，且形参表必须为空，而且类型转换运算符必须定义成类的成员函数。 类型转换运算符的函数体中基本都要有return语句，其中return语句的表达式类型必须要能隐式转换成运算符所指定的类型。 . 类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成const成员。 . 和转换构造函数一样，类型转换运算符会在任何需要转换的地方自动执行隐式转换；也可以显式调用该运算符。 . #include &lt;iostream&gt; using namespace std; struct Cls { int ins; Cls(int int_val): ins(int_val) {} // 类型转换运算符 operator int() const { return ins; } }; void prints(int val) { cout &lt;&lt; val; } int main() { Cls obj(61); // 隐式执行Cls-&gt;int的转换，输出61 cout &lt;&lt; obj; // 隐式执行Cls-&gt;int的转换，输出61 prints(obj); // 显式执行Cls-&gt;int的转换，输出61 cout &lt;&lt; static_cast&lt;int&gt;(obj); // 显式执行Cls-&gt;int的转换，输出61 cout &lt;&lt; obj.operator int(); // 显式执行Cls-&gt;int的转换，输出61 prints(obj.operator int()); return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#783-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#783-类型转换运算符"
  },"512": {
    "doc": "类概念详解",
    "title": "7.831 显式类型转换运算符",
    "content": "和显式构造函数一样，我们也能声明类型转换运算符为explicit的，该类型转换运算符也叫做显式类型转换运算符(explicit conversion operator)。 . 显式类型转换运算符的形式与显式构造函数一样，在该类型转换运算符的声明或定义语句之前用关键字explicit进行声明。 . 声明形式为： . explicit 类型转换运算符的声明 . 和显式构造函数一样，关键字explicit只能在类内中使用。 . struct Cls { int ins; Cls(int int_val): ins(int_val) {} // explicit的类型转换运算符 explicit operator int() const; }; Cls::operator int() const { return ins; } . 和显式构造函数一样，除了bool显式类型转换运算符的某个特殊情况以外，编译器将不会再自动使用该类型的其他显式类型转换运算符来进行隐式转换。 . #include &lt;iostream&gt; using namespace std; struct Cls { int ins; Cls(int int_val): ins(int_val) {} // explicit的类型转换运算符 explicit operator int() const { return ins; } }; void prints(int val) { cout &lt;&lt; val; } int main() { Cls obj(61); // 错误：不能隐式转换 cout &lt;&lt; obj; // 错误：不能隐式转换 prints(obj); // 正确：显式执行Cls-&gt;int的转换，输出61 cout &lt;&lt; static_cast&lt;int&gt;(obj); // 正确：显式执行Cls-&gt;int的转换，输出61 cout &lt;&lt; obj.operator int(); // 正确：显式执行Cls-&gt;int的转换，输出61 prints(obj.operator int()); return 0; } . 只有bool显式类型转换运算符才有一个特殊情况，情况为： 如果某类型定义了bool类型的显式类型转换运算符，当该类型对象： . | 为逻辑运算符的运算对象。 | 出现在条件表达式且该表达式中该对象只可以当作逻辑运算符的运算对象或者不当作任何运算对象。 只有控制语句和条件运算符中的条件部分才能被称为条件表达式。 . | . 当需要转换时，编译器会自动调用该类型的bool显式类型转换运算符来进行隐式转换。 . struct Cls { int ins; Cls(int int_val): ins(int_val) {} // bool显式类型转换运算符 explicit operator bool() const { return ins; } }; Cls obj(15); // 正确：隐式转换Cls-&gt;bool，输出为good if (0 || obj) cout &lt;&lt; \"good\"; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7831-%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7831-显式类型转换运算符"
  },"513": {
    "doc": "类概念详解",
    "title": "7.84 类类型转换的匹配",
    "content": "转换构造函数和类型转换运算符都是函数，且都能进行重载，所以它们都遵循函数的匹配规则。 . 和其他成员函数一样，函数匹配的函数候选集中会有各种私有和已删除的函数。 . 注意当隐式转换时，(除了bool显式类型转换运算符的特殊情况)函数的候选集是不会有explicit的函数的。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#784-%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8C%B9%E9%85%8D",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#784-类类型转换的匹配"
  },"514": {
    "doc": "类概念详解",
    "title": "7.841 类类型转换的二义性问题",
    "content": "所以在类类型转换时，要注意函数匹配的二义性问题。 对于类类型转换的匹配二义性问题，一般会出现在以下几种情况： . | 两个不同类之间互相提供相同的类型转换： 例如，当A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符。 | 类定义了多个转换规则，且对于某种调用来说有多种最佳相同匹配度的函数。 | 调用重载的函数时，该实参类型需要转换，且有多个转换后的最佳相同匹配度的函数。 | . 对于以上这些二义性问题，我们无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也面临二义性，所以我们只能显式地调用某特定的类型转换运算符或者转换构造函数来消除这种二义性问题。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7841-%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7%E9%97%AE%E9%A2%98",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7841-类类型转换的二义性问题"
  },"515": {
    "doc": "类概念详解",
    "title": "7.842 定义类类型转换的建议",
    "content": "要想正确地设计类的类类型转换，必须加倍小心。尤其是当类同时定义了类型转换运算符及重载运算符时特别容易产生二义性。 . 以下的经验规则可能对你有所帮助： . | 不要令两个类执行相同的类型转换 例如：如果Foo类有一个接受Bar类对象的构造函数，则不要在Bar类中再定义转换目标是Foo类的类型转换运算符。 | 避免转换目标是内置算术类型的类型转换。特别是当你已经定义了一个转换成算术类型的类型转换时，接下来就 . | 不要再定义接受算术类型的重载运算符。如果用户需要使用这样的运算符，则类型转换操作将转换你的类型的对象，然后使用内置的运算符。 | 不要定义转换到多种算术类型的类型转换。让标准类型转换完成向其他算术类型转换的工作。 | . | . 总之，除了可以定义bool显式类型转换运算符之外，我们应该尽量避免定义其他的类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7842-%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%BB%BA%E8%AE%AE",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7842-定义类类型转换的建议"
  },"516": {
    "doc": "类概念详解",
    "title": "7.9 拷贝控制",
    "content": "之前，我们学习了通过传递实参给普通构造函数来创建并初始化一个类的对象。 但是，除了这种方法，我们还可以定义类对象的其他初始化方法，如拷贝初始化等。 而且，我们还可以定义类对象被另一个同类型的对象赋值发生的行为以及对象被销毁时发生的行为。 . 以上这些操作统称为拷贝控制操作。 . 如果我们不主动定义这些操作，则编译器将替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。但是，对一些类来说，依赖这些操作的默认定义会导致很多问题，所以我们需要知道如何定义这些操作。 . 一个类可以通过定义五种特殊的成员函数来控制这些操作，根据这些操作的作用情景，可以分为三种类型： . | 类对象的初始化 . | 拷贝构造函数(copy constructor) | 移动构造函数(move constructor) | . | 同类对象的赋值 . | 拷贝赋值运算符(copy-assignment operator) | 移动赋值运算符(move-assignment operator) | . | 类对象的销毁 . | 析构函数(destructor) | . | . 其中的赋值运算符函数只能定义为非静态函数成员。 . 这些函数和其他普通成员函数一样，都支持类内类外定义。 . 以上的除了析构函数不支持重载，其他函数都支持重载，只要符合重载条件就行。 以上的除了构造函数，其他函数都可以为虚函数，且都能有对应的虚函数限定符。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79-拷贝控制"
  },"517": {
    "doc": "类概念详解",
    "title": "7.91 类对象初始化操作",
    "content": "接下来，我们需要学习其他的类对象的初始化方法。 . | 类对象的初始化 . | 拷贝构造函数(copy constructor) | 移动构造函数(move constructor) | . | . 和普通构造函数一样，我们依然只能用构造函数来初始化，只不过这两个构造函数的初始化方式是和普通构造函数不一样的。 . 这两个构造函数和其他的构造函数一样，可以有初始值列表以及函数体，还可以被定义为默认构造函数或者是explicit的构造函数。 . struct Cls { static Cls self_obj; // 定义了一个拷贝构造函数，这个拷贝构造函数也是默认构造函数 Cls(Cls&amp; = self_obj) { cout &lt;&lt; \"copy_constructed!\\n\"; }; }; Cls Cls::self_obj = {}; /* 在下面的操作中，拷贝构造函数被调用了三次， 前两次被当做默认构造函数使用， 分别用于self_obj和obj的初始化； 最后一次是当成拷贝构造函数使用， 用于obj2的初始化。 所以输出为： copy_constructed! copy_constructed! copy_constructed! */ Cls obj; Cls obj2 = obj; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#791-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#791-类对象初始化操作"
  },"518": {
    "doc": "类概念详解",
    "title": "7.911 拷贝构造函数",
    "content": "拷贝构造函数主要是将一个同类型的左值对象(当然也可以是右值)的数据复制到将要创建的对象中，使它们之间的数据一样。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7911-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7911-拷贝构造函数"
  },"519": {
    "doc": "类概念详解",
    "title": "7.9111 拷贝构造函数的形式",
    "content": "如果一个构造函数的第一个形参是自身类类型的左值引用(如果还需要复制右值数据，则要用左值常量引用)，且没有其他形参或者其他的形参都有默认实参，则此构造函数就是拷贝构造函数。 . struct Cls { // 默认构造函数 Cls () {}; // 拷贝构造函数 Cls (Cls &amp;) {}; }; . 拷贝构造函数的第一个参数必须是一个引用类型，如果不是引用类型，则会出错。 因为防止出现调用永远也不会成功的情况：为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。 . 虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79111-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79111-拷贝构造函数的形式"
  },"520": {
    "doc": "类概念详解",
    "title": "7.9112 拷贝构造函数的使用",
    "content": "在下列使用情景中，除了拷贝初始化以外，其他的只会调用其拷贝构造函数来进行操作： . | 直接初始化的构造函数匹配中，拷贝构造函数是最佳匹配。 | 拷贝初始化。 | 将一个非临时对象作为实参传递给一个非引用类型的形参。 | 从一个返回类型为非引用类型的函数返回一个非临时对象，该对象不能为该函数自己定义的非静态局部变量。 | 用花括号列表初始化一个数组中的元素或者一个聚合类中的成员，花括号中的初始值都不能为临时对象。 | 某些类类型还会对它们所分配的对象使用拷贝初始化。 例如，当我们用非临时对象初始化标准库容器或是调用其insert或push成员且使用非临时对象时，容器会对其元素进行拷贝初始化。 | . 拷贝初始化不仅仅只会使用拷贝构造函数，编译器还会根据所要拷贝的初始值的左右值属性来决定应该调用拷贝还是移动构造函数。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79112-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79112-拷贝构造函数的使用"
  },"521": {
    "doc": "类概念详解",
    "title": "7.912 移动构造函数",
    "content": "因为拷贝构造函数是复制初始值的数据，所以对于一些所需空间较大的类对象，这种操作就比较耗费空间了，尤其是初始值为临时对象时还需要复制。 于是就有了移动构造函数：移动构造函数和拷贝构造函数差不多，但是移动构造函数主要是对初始值为同类型的右值对象操作的。 因为初始值是右值对象，所以它们的数据即将被销毁，所以移动构造函数就可以直接接管该对象的数据，也就是将初始值数据直接移动到将要创建的对象中，而不是复制，这样也节约了资源。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7912-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7912-移动构造函数"
  },"522": {
    "doc": "类概念详解",
    "title": "7.9121 移动构造函数的形式",
    "content": "如果一个构造函数的第一个形参是自身类类型的右值引用，且没有其他形参或者其他的形参都有默认实参，则此构造函数就是移动构造函数。 . struct Cls { // 拷贝构造函数 Cls (Cls &amp;) {}; // 移动构造函数 Cls (Cls &amp;&amp;) {}; }; . 移动构造函数不像拷贝构造函数一样，一般不设为const引用，因为不管是不是常量右值引用，都能绑定对应类型的右值，而且设为const引用后还不能修改其值，所以不设为const引用。 . 移动构造函数因为是移动数据，所以定义移动构造函数时还必须确保移后源对象处于这样一个状态——销毁它是无害的，否则有可能出问题。 特别是，一旦资源完成移动后，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。 . 与拷贝构造函数不同，移动构造函数不分配任何新内存，它只是接管给定的对象的内存。因此，移动操作通常不会抛出任何异常，所以我们在需要在移动构造函数中指明noexcept。 . 我们必须在类内声明和类外定义中(如果定义在类外的话)都指定noexcept。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79121-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79121-移动构造函数的形式"
  },"523": {
    "doc": "类概念详解",
    "title": "7.9122 移动构造函数的使用",
    "content": "移动构造函数的使用情景差不多，只不过只会在初始值为右值时使用。 比如在拷贝初始化过程中，编译器会根据所要拷贝的初始值的左右值属性来决定应该调用拷贝还是移动构造函数。 . 如果一个类有一个拷贝构造函数但未定义移动构造函数，那么编译器就会调用拷贝构造函数来进行操作，但必须有某个拷贝构造函数的第一个形参为const左值引用，否则出错(因为只有常量引用才能绑定到右值上)。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79122-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79122-移动构造函数的使用"
  },"524": {
    "doc": "类概念详解",
    "title": "7.913 派生类的拷贝/移动构造函数",
    "content": "拷贝/移动构造函数的执行顺序和普通构造函数的顺序一模一样。 对于在继承关系的类的拷贝控制成员，它们会调用每个基类自己对应的拷贝控制成员来执行对应基类部分的对应操作。 . 在默认情况下，使用拷贝/移动构造函数创建类对象时，派生类是用其对应基类的默认构造函数来初始化派生类对象的该基类部分。 所以如果我们想拷贝或者移动派生类对象的基类部分，则必须要在派生类的拷贝/移动构造函数的初始值列表中显式地使用基类的拷贝或者移动构造函数。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7913-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7913-派生类的拷贝移动构造函数"
  },"525": {
    "doc": "类概念详解",
    "title": "7.914 构造函数的跳过",
    "content": "在拷贝初始化过程中(包括各种该类型的拷贝初始化，比如类对象、形参和返回值的拷贝等)，如果其初始值为==同类型的临时对象==时，编译器会直接跳过移动/拷贝构造函数(也不会调用其他的构造函数)，直接创建该类对象。 . 但是必须要满足一个条件才能执行跳过： 在这个调用点上，需要跳过的对应的拷贝或者移动构造函数必须是存在、可访问且未删除的，也就是调用点的实参所匹配的最佳构造函数必须可访问且未删除的。 . struct Cls { int ins; Cls() {} // 拷贝构造函数 Cls(const Cls&amp; other): ins(other.ins) { cout &lt;&lt; \"const_copy_constructed!\\n\"; }; // 转换构造函数 Cls(int val): ins(val) { cout &lt;&lt; \"convert_constructed!\\n\"; }; }; // Cls()生成了一个临时对象，所以拷贝初始化时Cls(const Cls&amp; other)就被跳过了，不输出任何值 Cls obj = Cls(); // 先调用的是转换构造函数，然后生成一个临时对象，然后跳过拷贝构造函数\\ 输出\\ convert_constructed! Cls obj2 = 5; . struct Cls { int ins; // 常量引用的拷贝构造函数 Cls(const Cls&amp; other): ins(other.ins) { cout &lt;&lt; \"const_copy_constructed!\\n\"; }; Cls() {} // 转换构造函数 Cls(int val): ins(val) { cout &lt;&lt; \"convert_constructed!\\n\"; }; private: // 移动构造函数 Cls(Cls&amp;&amp; other): ins(other.ins) { cout &lt;&lt; \"move_constructed!\\n\"; }; }; const Cls obj; // 正确：最佳匹配为Cls(const Cls&amp; other)，输出\\ const_copy_constructed! Cls obj2 = obj; // 错误：最佳匹配为Cls(Cls&amp;&amp; other)，但是无法访问，所以编译出错 Cls obj3 = Cls(); // 错误：先调用转换构造函数，然后生成一个临时对象，\\ 因为对应的移动构造函数Cls(Cls&amp;&amp; other)无法访问，所以编译出错 Cls obj4 = 8; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7914-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B7%B3%E8%BF%87",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7914-构造函数的跳过"
  },"526": {
    "doc": "类概念详解",
    "title": "7.92 同类对象的赋值",
    "content": "接下来，我们需要学习同类对象的赋值方法。 . | 同类对象的赋值 . | 拷贝赋值运算符(copy-assignment operator) | 移动赋值运算符(move-assignment operator) | . | . 拷贝、移动赋值运算符和拷贝、移动构造函数的作用类似，只不过都是用于同类对象的赋值过程中的： . | 拷贝赋值运算符： 主要作用于左值(右值也可以)，将初始值数据复制到左侧的类对象中，使它们之间的数据一样。 | 移动赋值运算符： 只作用于右值，将初始值数据移动到左侧的类对象中，使它们之间的数据一样。 | . 这两个函数都是重载运算符中的赋值运算符，所以使用方法和正常的重载运算符一样。 . 为了与内置类型的赋值保持一致，我们定义自己的赋值运算符时，通常返回一个指向其左侧运算对象的引用。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#792-%E5%90%8C%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#792-同类对象的赋值"
  },"527": {
    "doc": "类概念详解",
    "title": "7.921 拷贝赋值运算符",
    "content": "拷贝赋值运算符是一个右侧运算对象类型为自身类类型的左值引用(如果还需要复制右值数据，则要用左值常量引用)的赋值运算符成员函数。 . 声明形式为： . | 返回类型 operator= ((可含类型修饰符)类名&amp;) (可选 限定符); . | auto operator= ((可含类型修饰符)类名&amp;) -&gt; 返回类型 (可选 限定符); . | . 和拷贝构造函数一样，右侧运算对象类型几乎总是一个const的引用。 . 右侧运算对象类型如果不是引用，则可能在某些情况不会被判断成拷贝赋值运算符。 . struct Cls { // 拷贝赋值运算符 Cls&amp; operator=(const Cls &amp;other) { cout &lt;&lt; \"copy_assignment!\"; }; }; Cls obj, obj2; // 将obj2的数据复制到obj obj = obj2; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7921-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7921-拷贝赋值运算符"
  },"528": {
    "doc": "类概念详解",
    "title": "7.922 移动赋值运算符",
    "content": "移动赋值运算符是一个右侧运算对象类型为自身类类型的右值引用的赋值运算符成员函数。 . 声明形式为： . | 返回类型 operator= ((可含类型修饰符)类名&amp;&amp;) (可选 限定符); . | auto operator= ((可含类型修饰符)类名&amp;&amp;) -&gt; 返回类型 (可选 限定符); . | . 和移动构造函数一样，右侧运算对象类型几乎总是一个非const的引用。 . 与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为noexcept。 . struct Cls { // 拷贝赋值运算符 Cls&amp; operator=(const Cls &amp;other) { cout &lt;&lt; \"copy_assignment!\"; }; // 移动赋值运算符 Cls&amp; operator=(Cls&amp;&amp; other) { cout &lt;&lt; \"move_assignment!\"; }; }; Cls obj, obj2; // 调用拷贝赋值运算符 obj = obj2; // 调用移动赋值运算符 obj = Cls(); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7922-%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7922-移动赋值运算符"
  },"529": {
    "doc": "类概念详解",
    "title": "7.923 派生类的拷贝/移动赋值运算符",
    "content": "拷贝/移动赋值运算符的执行顺序和普通构造函数的顺序一模一样。 对于在继承关系的类的拷贝控制成员，它们会调用每个基类自己对应的拷贝控制成员来执行对应基类部分的对应操作。 . 在默认情况下，使用拷贝/移动赋值运算符来赋值或者移动类对象时，派生类是用其对应基类的默认构造函数来赋值或者移动派生类对象的该基类部分。 . 所以，与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7923-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7923-派生类的拷贝移动赋值运算符"
  },"530": {
    "doc": "类概念详解",
    "title": "7.93 类对象的销毁",
    "content": "接下来，我们需要学习类对象的销毁方法。 . | 类对象的销毁 . | 析构函数(destructor) | . | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#793-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#793-类对象的销毁"
  },"531": {
    "doc": "类概念详解",
    "title": "7.931 析构函数",
    "content": "析构函数和构造函数可以说是一对兄弟，构造函数负责类对象的构建，而析构函数则负责类对象的销毁。 . 析构函数执行与构造函数相反的操作：释放类对象使用的资源，并销毁该对象的非静态数据成员。 . 析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，且形参表必须为空，有一个函数体。 析构函数可以定义在类内或者类外。 析构函数的函数体中不能有除了空return语句外的其他类型的返回语句。 . 析构函数不能有存储说明符，且也不能有类型限定符，如const等。 . 声明形式为： . ~类名(); . struct Cls { // 析构函数 ~Cls(); }; Cls::~Cls() {}; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7931-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7931-析构函数"
  },"532": {
    "doc": "类概念详解",
    "title": "7.9311 析构函数的执行",
    "content": "如同构造函数的执行过程中有一个初始化执行部分和函数体执行部分一样，析构函数也有一个函数体执行部分和一个析构执行部分。 . 和构造函数不一样的是，在一个析构函数中，不存在类似初始化列表的东西来控制每个成员的销毁方式，成员的销毁是隐式的，析构函数会自动调用对应成员自己的析构函数来执行销毁的。 内置类型没有析构函数，因此对于系统内置类型的成员来说，销毁该成员什么也不需要做。 . 所以析构函数对于一个指向动态内存的普通指针成员，是不会自动销毁该指针成员所指向的对象的。 . 析构函数的执行顺序为： . | 先执行函数体。 | 再按初始化顺序的逆序，逐个调用成员对应的析构函数来销毁该成员(对于内置类型就什么都不做)。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79311-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79311-析构函数的执行"
  },"533": {
    "doc": "类概念详解",
    "title": "7.9312 析构函数的使用",
    "content": "析构函数的使用基本都是自动进行的，无论何时一个对象被销毁，就会自动调用其析构函数，如果该析构函数无法访问或者已删除，则会编译出错。 . 对于对象被销毁的情况，基本就是以下几种： . | 变量在离开其作用域时被销毁。 | 当一个对象被销毁时，其成员也被销毁。 | 一个容器（无论是标准库容器还是数组）被销毁时，其元素也被销毁。 | 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。 | 对于临时对象来说，除非该对象已被接管，否则当创建它的完整表达式结朿时它就会被销毁。 | . 临时对象被接管的情况有以下几种: . | 用于初始化同类型对象(不管是直接初始化还是拷贝初始化)。 | 被常量左值引用或者右值引用绑定时。 | . 我们也可以自己想普通函数调用一样调用类对象的析构函数来执行对象的销毁，但是该类的析构函数不能是合成的，且必须要可访问并为未删除的。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79312-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79312-析构函数的使用"
  },"534": {
    "doc": "类概念详解",
    "title": "7.9313 虚析构函数",
    "content": "对于有继承关系的类，基类通常应该定义一个虚析构函数，这样就能动态分配继承体系中的对象了。 . 当我们delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。 所以这样的情况下，编译器就必须清楚它应该执行的是哪一个类的析构函数。和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。 . 和其他虚函数一样，析构函数的虚属性也会被继承。因此，无论派生类使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数。只要基类的析构函数是虚函数，就能确保当我们delete基类指针时将运行正确的析构函数版本。 . struct Ba { string str = \"str\"; virtual ~Ba() { cout &lt;&lt; \"Ba destructed!\\n\"; }; }; struct De: Ba { int *p = new int{6}; ~De() { delete p; cout &lt;&lt; \"De destructed!\\n\"; } }; Ba* ptr = new De(); // 正确销毁了De类的对象，输出\\ De destructed!\\ Ba destructed! delete ptr; . 如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。 . 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79313-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#79313-虚析构函数"
  },"535": {
    "doc": "类概念详解",
    "title": "7.94 拷贝控制成员的执行顺序",
    "content": "拷贝/移动构造函数、拷贝/移动赋值运算符的执行顺序和普通构造函数的顺序一模一样；而析构函数的顺序与普通构造函数的顺序正好相反。 . 对于在继承关系的类的拷贝控制成员，它们会调用每个基类自己对应的拷贝控制成员来执行对应基类部分的对应操作。 . 以下为非析构函数的拷贝控制成员的执行顺序(析构函数的顺序与其全部相反，包括按其定义或派生顺序都相反)： . | 先按其派生列表顺序逐个调用其虚基类的拷贝\\移动构造函数或者拷贝\\移动赋值运算符进行该虚基类的成员操作(同名虚基类就进行一次)；每个虚基类也是如此做。 | 然后按其派生列表顺序逐个调用其非虚基类的直接基类的拷贝\\移动构造函数或者拷贝\\移动赋值运算符进行成员操作；每个类(包括虚基类)也是如此做。 | 最后按其非static成员的定义顺序逐个进行拷贝\\移动；每个类(包括虚基类)也是如此做。 | . 以下是各个拷贝控制成员的作用介绍： . | 拷贝\\移动构造函数： 拷贝\\移动构造函数会将其初始值的非static成员逐个拷贝或移动到正在创建的对象中。 | 拷贝\\移动赋值运算符 拷贝\\移动赋值运算符会将其会将右侧运算对象的每个非static成员赋值或移动左侧运算对象的对应成员。 | 析构函数： 成员按初始化顺序的逆序销毁。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#794-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#794-拷贝控制成员的执行顺序"
  },"536": {
    "doc": "类概念详解",
    "title": "7.95 拷贝控制成员的合成版本",
    "content": "和默认构造函数一样，所有的拷贝控制成员都有编译器自动合成的版本，也分为隐式合成和显式合成。 . 所有拷贝控制成员的合成版本都有如下特性： . | 所有非析构函数的拷贝控制成员的合成版本会自动把赋值对象的每个非静态数据成员初始化(/赋值)到被赋值对象对应的成员中。 | 析构函数不管是不是合成版本，其都会在该对象销毁时自动调用非静态数据成员自己的析构函数。 | 析构函数的拷贝控制成员的函数体为空；非析构函数的拷贝控制成员的函数体只存在非静态数据成员的赋值语句。 | 如果其类型为字面值类型，则合成版本的构造函数成员都为constexpr函数，其他合成的拷贝控制成员则不为constexpr函数。 | . 以下为各个拷贝控制成员的函数声明，假设类名为Cls，且含有某些非静态数据成员，则其合成的拷贝成员的定义一般如下所示： . #include &lt;string&gt; // 假设Cls的成员结构如下 class Cls { static constexpr int kIns = 48; int ins_; double dou_; std::string str_; /** * 以下为编译器合成的拷贝成员版本的可能定义形式 * // 合成的拷贝构造函数 * Cls(const Cls&amp; obj): ins_(obj.ins_), dou_(obj.dou_), str_(obj.str_) {} * // 合成的移动构造函数 * Cls(Cls&amp;&amp; obj): ins_(obj.ins_), dou_(obj.dou_), str_(obj.str_) {} * // 合成的拷贝赋值运算符 * Cls&amp; operator=(const Cls&amp; obj) { ins_ = obj.ins_; dou_ = obj.dou_; str_ = obj.str_; } * // 合成的移动赋值运算符 * Cls&amp; operator=(Cls&amp;&amp; obj) { ins_ = obj.ins_; dou_ = obj.dou_; str_ = obj.str_; } * // 合成的析构函数 * ~Cls() {} * */ }; . 以下为合成拷贝控制成员的特性例子： . // 自定义的delete运算符函数 void operator delete(void * ptr) noexcept { std::cout &lt;&lt; \"内存已释放\\n\"; } // 含有动态内存分配的非静态数据成员 struct Cls { double *pDou_ = new double{-12.55}; ~Cls() { delete pDou_; } }; class Base { int ins_; double dou_; // 含有动态内存分配的非静态数据成员 Cls obj; public: // 输出非静态成员 void prints() const { std::cout &lt;&lt; ins_ &lt;&lt; std::endl; std::cout &lt;&lt; dou_ &lt;&lt; std::endl &lt;&lt; std::endl; } // 默认构造函数 Base(): ins_(5), dou_(-8.2) {} // 构造函数 Base(int ins, double dou): ins_(ins), dou_(dou) { std::cout &lt;&lt; \"调用普通构造函数\\n\"; } // 合成的拷贝构造函数 Base(const Base&amp;) = default; // 移动构造函数 Base(Base&amp;&amp;) { std::cout &lt;&lt; \"调用移动构造函数\\n\"; } // 拷贝赋值运算符函数 Base&amp; operator=(const Base&amp;) { std::cout &lt;&lt; \"调用拷贝赋值运算符函数\\n\"; return *this; } // 移动赋值运算符函数 Base&amp; operator=(Base&amp;&amp;) = default; // 析构函数 ~Base() { std::cout &lt;&lt; \"调用析构函数\\n\"; } }; int main() { // 由Base(int, double)构造 Base obj(48,15.66); obj.prints(); // 由合成的Base(const Base&amp;)构造，非静态数据成员值与obj一样。 Base obj2{obj}; obj2.prints(); // 由Base(Base&amp;&amp;)构造，非静态数据成员值未初始化。 Base obj3{std::move(obj2)}; obj3.prints(); // 由Base(int, double)构造 Base obj4(230,0.55); // 由Base&amp; operator=(const Base&amp;)构造，非静态数据成员值未初始化。 obj = obj2; obj.prints(); // 由合成的Base&amp; operator=(Base&amp;&amp;)构造，非静态数据成员值与obj4一样。 obj2 = std::move(obj4); obj2.prints(); // 不管是不是合成版本的析构函数，结束时该析构函数会自动调用非静态数据成员自己的析构函数。 return 0; } . // 字面值类型Base，可以在使用常量表达式的地方调用。 class Base { int ins_; double dou_; public: // 输出非静态成员 void prints() const { std::cout &lt;&lt; ins_ &lt;&lt; std::endl; std::cout &lt;&lt; dou_ &lt;&lt; std::endl &lt;&lt; std::endl; } // 默认构造函数 constexpr Base(): ins_(5), dou_(-8.2) {} // 构造函数 constexpr Base(int ins, double dou): ins_(ins), dou_(dou) {} }; int main() { // 由constexpr Base(int, double)构造，可以在使用常量表达式的地方调用。 constexpr Base obj(48,15.66); obj.prints(); // 由合成的constexpr Base(const Base&amp;)构造，可以在使用常量表达式的地方调用。 constexpr Base obj2{obj}; obj2.prints(); // 由合成的constexpr Base(Base&amp;&amp;)构造，可以在使用常量表达式的地方调用。 constexpr Base obj3{std::move(obj2)}; obj3.prints(); // obj4不为常量表达式 Base obj4(230,0.55); // 由合成的Base&amp; operator=(const Base&amp;)构造，不可以在使用常量表达式的地方调用。 obj4 = obj; obj4.prints(); // obj5为常量表达式 constexpr Base obj5(10,0.75); // 错误：合成的Base&amp; operator=(const Base&amp;)不能在使用常量表达式的地方调用。 obj5 = obj; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#795-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98%E7%9A%84%E5%90%88%E6%88%90%E7%89%88%E6%9C%AC",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#795-拷贝控制成员的合成版本"
  },"537": {
    "doc": "类概念详解",
    "title": "7.951 隐式合成版本",
    "content": "对于除了移动构造函数和移动赋值运算符来说，如果某个类没有自己定义对应的拷贝控制成员，则编译器会为其定义一个。 . 而对于移动构造函数和移动赋值运算符来说，只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动(对于类类型的成员，该类要有可用的移动构造函数；对于内置类型，则都能移动)时，编译器才会为它合成移动构造函数或移动赋值运算符。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7951-%E9%9A%90%E5%BC%8F%E5%90%88%E6%88%90%E7%89%88%E6%9C%AC",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7951-隐式合成版本"
  },"538": {
    "doc": "类概念详解",
    "title": "7.952 显式合成版本",
    "content": "和普通构造函数一样，我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本，default的关键字用法和普通构造函数的一样，可以在类内类外使用，类内为内联。 . 对于可以声明为default的拷贝控制成员的形式有具体的规定，否则声明出错： . | 对于拷贝和移动构造函数来说，它们必须为： 形参表只能有一个形参，且该形参为自身类类型的对应引用，且不能有默认实参。 | 对于拷贝和移动赋值运算符来说，它们必须为： 返回类型为自身类类型的非常量引用、右侧运算对象类型为自身类类型的对应引用，且不能有如const，&amp;等的类型限定符，virtual等于虚函数有关的不算在内。 | 对于析构函数来说，和定义普通的析构函数一样。 | . struct Cls { // 显式合成的拷贝构造函数 Cls(const Cls&amp;) = default; // 显式合成的移动构造函数 Cls(Cls&amp;&amp;); // 显式合成的拷贝赋值运算符 Cls&amp; operator=(const Cls&amp;) = default; // 显式合成的移动赋值运算符 Cls&amp; operator=(Cls&amp;&amp;); // 显式合成的析构函数 ~Cls(); }; Cls::Cls(Cls&amp;&amp;) = default; Cls&amp; Cls::operator=(Cls&amp;&amp;) = default; Cls::~Cls() = default; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7952-%E6%98%BE%E5%BC%8F%E5%90%88%E6%88%90%E7%89%88%E6%9C%AC",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7952-显式合成版本"
  },"539": {
    "doc": "类概念详解",
    "title": "7.943 删除的合成版本",
    "content": "虽然编译器大部分会自动合成各种拷贝控制成员，但是对于有以下这些情况中的任意一个的类来说，编译器会将对应的合成成员定义为已删除的函数(隐式删除)： . | 拷贝构造函数： . | 类的某个成员(包括继承的)的拷贝构造函数是删除的或不可访问的。 | 类以及类的某个成员(包括继承的)的析构函数是删除的或不可访问的。 | 类自己定义了移动构造函数或者移动赋值运算符。 | . | 拷贝赋值运算符 . | 类的某个成员(包括继承的)的拷贝赋值运算符是删除的或不可访问的。 | 类有一个const的或引用成员(包括继承的)。 | 类自己定义了移动构造函数或者移动赋值运算符。 | . | 移动构造函数 . | 有类成员(包括继承的)的移动构造函数被定义为删除的或是不可访问的。 | 有类成员(包括继承的)定义了自己的拷贝构造函数且未定义移动构造函数。 | 有类成员(包括继承的)未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。 | 类以及类成员(包括继承的)的析构函数被定义为删除的或不可访问的。 | 用=default显式要求该类生成移动操作，且编译器不能移动所有成员。 | . | 移动赋值运算符 . | 有类成员(包括继承的)的移动赋值运算符被定义为删除的或是不可访问的。 | 有类成员(包括继承的)定义了自己的拷贝赋值运算符且未定义移动赋值运算符。 | 有类成员(包括继承的)未定义自己的拷贝赋值运算符且编译器不能为其合成移动赋值运算符。 | 有类成员(包括继承的)是const的或是引用。 | 用=default显式要求该类生成移动操作，且编译器不能移动所有成员。 | . | 析构函数: . | 类的某个成员(包括继承的)的析构函数是删除的或不可访问的（例如是private的） | . | 默认构造函数 . | 类某个成员(包括继承的)的默认构造函数是删除的或不可访问的。 | 类以及类某个成员(包括继承的)的析构函数是删除的或不可访问的。 | 类有一个引用成员，它没有类内初始化器。 | 类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数。 | . | . 这些情况中的定义了某某函数的情况包括显式要求生成合成版本的情况。 . 本质上，这些规则的含义是： . | 如果一个类有数据成员不能被默认构造、拷贝、赋值、移动或销毁，则对应的成员函数将被定义为已删除。 | 如果一个类已经有移动成员函数，则该类的拷贝和赋值成员函数将被定义为已删除。 | 如果一个类已经有拷贝和赋值成员函数，则对应的移动成员函数将不会存在。 | . 以上删除的合成版本与第5章提到的已删除函数在函数重载方面有一些区别，删除的合成版本为隐式删除，因此不会参与到函数重载中，而显式用=delete指定的函数会参与到函数重载中。 . struct Cls { // 显式合成的拷贝构造函数 Cls() = default; // 显式合成的拷贝构造函数 Cls(const Cls&amp;) = default; // 显式指定移动构造函数为delete Cls(Cls&amp;&amp;) = delete; }; // 包含显式合成的拷贝构造函数 // 和移动构造函数的删除合成版本 class Derive: public Cls {}; Cls getCls() { Cls obj; /* 编译错误： Cls的移动构造函数是被显式定义为删除，会参与到函数重载中。 编译器在函数匹配时会将Cls类的 拷贝和移动构造函数都加入到可行函数集中， 其中移动构造函数为最佳匹配，因此选择调用 该函数。 但移动构造函数已被指定为删除，所以调用出错。 */ return obj; } Derive getDerive() { Derive obj; /* 编译正确： Derive的移动构造函数的合成版本是被隐式定义为删除，不会参与到函数重载中。 编译器在函数匹配时只会将Derive类的 拷贝构造函数都加入到可行函数集中，因此选择调用 拷贝构造函数， 拷贝构造函数为正常的合成版本，因此调用正常。 */ return obj; } . 对于析构函数为已删除的类来说，有非常大的影响，因为析构函数被删除，就无法销毁此类型的对象： 所以对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象；而且如果一个类的某成员的类型删除了析构函数，则我们也不能定义该类的变量或临时对象。 但我们可以动态分配这种类型的对象，不过就不能释放掉这些对象了。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7943-%E5%88%A0%E9%99%A4%E7%9A%84%E5%90%88%E6%88%90%E7%89%88%E6%9C%AC",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7943-删除的合成版本"
  },"540": {
    "doc": "类概念详解",
    "title": "7.96 三/五法则",
    "content": "C++语言并不要求我们定义所有这些操作：可以只定义其中一个或两个，而不必定义所有。 但是，这些操作通常应该被看作一个整体。通常，只需要其中一个操作，而不需要定义所有操作的情况是很少见的。 . 对于大多数类型的定义中，有三个基本操作就可以控制该类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。 . 当我们决定一个类是否要定义它自己版本的拷贝控制成员时，我们应该用以下这几个原则来思考： . | 首先确定这个类是否需要一个析构函数。通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更为明显。 如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。 | 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然，如果一个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。 然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。 | 当某些类定义了自己的拷贝构造函数和赋值运算符时，如果它们的数据可以被移动，就可以考虑这些情况：类包含的数据太多，而且拷贝赋值需要的额外开销大。 在这种拷贝并非必要的情况下，定义移动构造函数和移动赋值运算符就可以避免此问题。 | 当我们定义一个基类时，最好定义自己的析构函数，而且要将该析构函数设定为虚函数。 因为这样就能动态分配继承体系中的对象，只要基类的析构函数是虚函数，就能确保当我们delete基类指针时将运行正确的析构函数版本。 不过此时该基类不一定需要需要赋值运算符或拷贝构造函数，要根据其他方面再来判断。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#796-%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#796-三五法则"
  },"541": {
    "doc": "类概念详解",
    "title": "7.10 特殊的类类型",
    "content": "之前我们所看到的都是普通的类，但是C++中也有一些特殊的类，当一个类类型满足特殊类的条件时，它就为该特殊的类。 . 以下是几种特殊的类类型： . | 聚合类 | 字面值常量类 | 局部类 | 抽象基类 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#710-%E7%89%B9%E6%AE%8A%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#710-特殊的类类型"
  },"542": {
    "doc": "类概念详解",
    "title": "7.101 聚合类",
    "content": "聚合类(aggregate class)使得用户可以直接访问其成员，并且具有特殊的初始化语法 形式。 . 当一个类满足如下条件时，我们说它是聚合类： . | 所有成员都是public的。 | 没有定义任何构造函数。 | 所有非静态数据成员都没有类内初始值。 | 没有任何基类，也没有任何virtual函数。 | . // Cls类是一个聚合类 struct Cls { static const int sta_ins = 35; int ins; static string sta_str; string str; static void prints() {} int ret() { return 35; } }; string Cls::sta_str = \"sta_str\"; . 和普通类不一样的是，聚合类可以用一个花括号括起来的成员初始值列表，并用它来初始化聚合类的非静态数据成员。 . 直接初始化和拷贝初始化都行。 . Cls obj{6,\"str\"}; // 输出6 str cout &lt;&lt; obj.ins &lt;&lt; \" \" &lt;&lt; obj.str; Cls obj2 = {17,\"str2\"}; // 输出17 str2 cout &lt;&lt; obj2.ins &lt;&lt; \" \" &lt;&lt; obj2.str; . 初始化列表中的初始值类型必须要与其聚合类中的非静态数据成员一一对应，否则可能会出错。 . // 错误：int变量不能用字符串初始化，\\ string变量也不能用int初始化 Cls obj{\"str\", 6}; . 与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的非静态数据成员数量，则靠后的非静态数据成员被值初始化。 且初始值列表的元素个数绝对不能超过类的非静态数据成员数量。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7101-%E8%81%9A%E5%90%88%E7%B1%BB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7101-聚合类"
  },"543": {
    "doc": "类概念详解",
    "title": "7.102 字面值常量类",
    "content": "之前我们提到过：声明为constexpr的变量或者constexpr函数的参数和返回值都必须是字面值类型。 . 之前所说的算术类型、引用、指针和枚举类型都属于字面值类型，除此之外，类类型中的字面值常量类也属于字面值类型。 . 字面值常量类有两种： . | 所有非静态数据成员都是字面值类型的聚合类。 | 符合以下要求的普通类： . | 所有非静态数据成员都必须是字面值类型。 | 类必须至少含有一个constexpr构造函数。 | 类必须使用合成的析构函数。 | 如果一个非静态数据成员含有类内初始值，则： . | 内置类型成员的初始值必须是一条常量表达式。 | 类类型成员的初始值必须使用该成员类型自己的constexpr构造函数。 | . | . | . // Cls为所有非静态数据成员都是字面值类型的聚合类\\ 所以也就是字面值常量类。 struct Cls { static const int sta_ins = 35; int ins; static string sta_str; static void prints() {} int ret() { return 35; } }; string Cls::sta_str = \"sta_str\"; // 返回类型为Cls的constexpr函数 constexpr Cls ret() { return Cls{3}; } // 类型为Cls的constexpr变量 constexpr Cls obj = ret(); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7102-%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7102-字面值常量类"
  },"544": {
    "doc": "类概念详解",
    "title": "7.1021 constexpr构造函数",
    "content": "构造函数可以声明成constexpr的函数，声明方式为在构造函数的声明或定义语句之前加上关键字constexpr。 . 声明形式为： . constexpr 构造函数的声明语句 . 只有声明为constexpr的构造函数才能用于对应字面值类型的常量表达式构造，字面值类型中的普通构造函数不能用于常量表达式的构造。 . #include &lt;iostream&gt; // 字面值常量类 struct Base { // constexpr构造函数，可用于常量表达式的构造 constexpr Base(const int&amp; val) {} // 非constexpr构造函数，不能用于常量表达式的构造 Base(const double&amp; val) { std::cout &lt;&lt; \"no constexpr\\n\"; } }; int main() { // 正确：constexpr构造函数可用于非常量的构造 Base ba1{48}; // 正确：constexpr构造函数可用于常量的构造 const Base cba1{48}; // 正确：constexpr构造函数可用于常量表达式的构造 constexpr Base ceba1{48}; // 正确：非constexpr构造函数可用于非常量的构造 Base ba2{48.48}; // 正确：非constexpr构造函数可用于常量的构造 const Base cba2{48.48}; // 错误：非constexpr构造函数不能用于常量的构造 constexpr Base ceba2{48.48}; return 0; } . constexpr构造函数必须要在其初始值列表中显式初始化所有没有类内初始值的非静态数据成员(如果该类有继承关系时，要显式调用其所有虚基类以及直接基类的构造函数来初始化其继承的没有类内初始值的非静态数据成员)。 . 不管是constexpr构造函数的初始值列表中的初始值还是类内初始值，字面值常量类的每个非静态数据成员(包括继承的成员)的初始值只有两种选择： . | 要不就使用该成员自己类的constexpr构造函数。 | 要不就是一条常量表达式。 | . constexpr构造函数体必须为空。 . 和普通构造函数一样，constexpr构造函数可以用default关键字显式要求生成一个合成的constexpr构造函数。 . // Cls为字面值常量类。 struct Cls { static const int sta_ins = 35; int ins = 8; static string sta_str; double dou; static void prints() {} int ret() { return 35; } constexpr Cls(): dou(3.5) {} }; string Cls::sta_str = \"sta_str\"; // 返回类型为Cls的constexpr函数 constexpr Cls ret() { return Cls(); } // 类型为Cls的constexpr变量 constexpr Cls obj = ret(); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#71021-constexpr%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#71021-constexpr构造函数"
  },"545": {
    "doc": "类概念详解",
    "title": "7.103 局部类",
    "content": "类可以定义在某个函数的内部，我们称这样的类为局部类(local class)。 . 局部类定义的类型只在定义它的局部作用域内可见，也就是外层函数的作用域包含着局部类的作用域。 . 和嵌套类不同，局部类的成员受到严格限制。 局部类的限制有以下几种： . | 局部类的所有成员(包括函数在内)都必须完整定义在类内，不能在类外定义。 | 在局部类中不允许声明静态数据成员。 | 局部类不能使用外层函数的非静态局部变量。 | . 外层函数对局部类的访问特权和在局部类作用域外的其他对象一样，无特殊的访问特权，所以外层函数无法访问其局部类的私有和受保护成员(不过局部类可以将外层函数声明为友元)。 . 局部类内部的名字查找次序与其他类相似，遵循类的作用域规则。 . 可以在局部类的内部再嵌套一个类： 此时，嵌套类的定义可以出现在局部类之外。不过嵌套类必须定义在与局部类相同的作用域中(也就是外层函数的作用域内)。 局部类内的嵌套类也是一个局部类，必须遵循局部类的各种规定。 所以嵌套类的所有成员都必须定义在嵌套类内，不能在嵌套类外定义；不允许声明静态数据成员；不能使用外层函数的非静态局部变量。 . void contains() { // 局部类 struct Local_cls { int ins; static void prints() { cout &lt;&lt; \"local\\n\"; } // 嵌套的局部类声明 struct Nest; }; // 嵌套的局部类定义 struct Local_cls::Nest { int Nins; string str; }; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7103-%E5%B1%80%E9%83%A8%E7%B1%BB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7103-局部类"
  },"546": {
    "doc": "类概念详解",
    "title": "7.104 抽象基类",
    "content": "抽象基类是在类继承关系中使用的一种特殊类，抽象基类一般是用于只负责定义接口形式的类。 . 在说明抽象基类之前，我们需要了解一下纯虚函数的概念。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7104-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#7104-抽象基类"
  },"547": {
    "doc": "类概念详解",
    "title": "7.1041 纯虚函数",
    "content": "纯虚函数是一种虚函数，只要一个虚函数在其声明语句之后书写一个赋值符=再加一个0就可以变为纯虚函数。所以=0只能用于虚函数。 . 声明形式为： . 虚函数的声明 = 0; . 其中，=0只能出现在虚函数的类内声明语句中。 . 所有的纯虚函数都无须定义，但我们也可以为其提供定义，不过定义语句必须在类的外部。也就是说，我们不能在类内为一个=0的函数提供函数体。 . struct Cls { // 纯虚函数的声明 virtual void prints() = 0; }; // 纯虚函数的定义 void Cls::prints() { cout &lt;&lt; \"pure func\\n\"; } . 纯虚函数和虚函数一样，继承的纯虚函数在派生类中也是纯虚函数，不过当派生类用非纯虚函数形式的函数覆盖了某纯虚函数时，该纯虚函数在该派生类中就不再是纯虚函数了(也就变成了普通的虚函数了)。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#71041-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#71041-纯虚函数"
  },"548": {
    "doc": "类概念详解",
    "title": "7.1042 抽象基类的性质",
    "content": "所有含有纯虚函数成员(包括继承的成员)的类都是抽象基类(abstract base class)。 . 我们不能用任何方法来创建一个抽象基类的对象，不过可以创建指向抽象基类的指针或者引用。 . struct Cls { virtual void prints() = 0; }; void Cls::prints() { cout &lt;&lt; \"pure func\\n\"; } // 抽象基类Cls的派生类Der，该类覆盖了纯虚函数。 struct Der: Cls { void prints() override { cout &lt;&lt; \"overrided\\n\"; } }; // 错误：不能创建抽象基类Cls的对象 Cls obj; Cls* p = new Cls(); // 正确：可以创建抽象基类Cls的指针，引用。 Der dobj; Cls* p2 = new Der(); Cls&amp; r = dobj; // 输出overrided p2-&gt;prints(); r.prints(); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#71042-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%80%A7%E8%B4%A8",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html#71042-抽象基类的性质"
  },"549": {
    "doc": "类概念详解",
    "title": "类概念详解",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html",
    
    "relUrl": "/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html"
  },"550": {
    "doc": "第八章 重载运算符",
    "title": "第八章 重载运算符",
    "content": "第8章先介绍了重载运算符的概念，然后依次介绍了各种重载运算符。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/index.html",
    
    "relUrl": "/guide_files/chap8/index.html"
  },"551": {
    "doc": "重载运算符概念详解",
    "title": "8.1 重载运算符概念",
    "content": "重载运算符(overloaded operator)本质上就是函数，可以声明或者定义。其名字由operator关键字后接表示要定义的运算符的符号组成。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#81-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E6%A6%82%E5%BF%B5",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#81-重载运算符概念"
  },"552": {
    "doc": "重载运算符概念详解",
    "title": "8.11 重载运算符的形式",
    "content": "大部分的重载运算符声明形式为: . | 返回类型 operator 运算符号 形参表 (可选 限定符); . | auto operator 运算符号 形参表 -&gt; 返回类型 (可选 限定符); . | . 比如，赋值运算符就是一个函数。 类似于任何其他函数，大部分的运算符函数也有一个返回类型和一个参数列表。 . 和普通函数一样，相同运算符的重载运算符可以定义多个，也就是重载运算符的重载，其也要遵循函数重载的规则。 . 重载运算符的每个形参是表示运算符的每个运算对象，一个重载运算符的形参数量必须要与其运算对象数目相同。 比如： . | 一元运算符有一个参数， 对于一元运算符来说，不存在左侧运算对象，而只有右侧运算对象，且一般为成员函数。 因此其形参表一般为空。 | 二元运算符有两个参数， 对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。 | . 除了重载的函数调用运算符operator()之外，其他重载运算符都不能含有默认实参。 . 对于大多数重载运算符来说，它们既可以是普通函数，也可以是成员函数，比如算术运算符；不过有些重载运算符只能是普通函数或者是成员函数，比如赋值运算符只能为成员函数。 . 作为成员函数的重载运算符和普通成员函数一样，某些运算符可以定义在类内或类外，也可以为静态、const、引用或者虚函数成员。 . 如果一个二元运算符是一个非静态成员函数，则其左侧的运算对象就绑定到隐式的this参数，其他的运算对象就按照顺序绑定到其他显式形参上。 比如，对于一个二元运算符如赋值运算符来说，左侧的运算对象绑定到隐式的this参数，其右侧运算对象就作为显式参数传递。 . 对于所有重载运算符来说，不管是隐式还是显式形参，都必须至少含有一个类类型(也就是不能运算对象全是内置类型)。 . struct Cls { int ins = 5; // 赋值运算符：\\ 为成员函数，\\ 左侧运算对象为该类对象，\\ 右侧运算对象为int对象，\\ 返回赋值后的左侧运算对象 Cls&amp; operator=(int val) { this-&gt;ins = val; return *this; } }; // 加法运算符：\\ 为普通函数，\\ 左侧运算对象为Cls类对象，\\ 右侧运算对象为int对象，\\ 返回执行加法后的int值。 int operator+(Cls&amp; cls, int val) { return cls.ins + val; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#811-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#811-重载运算符的形式"
  },"553": {
    "doc": "重载运算符概念详解",
    "title": "8.12 重载运算符的规则",
    "content": "我们可以重载大多数（但不是全部）运算符。下表指明了哪些运算符可以被重载，哪些不行。 . 我们只能重载上表已有的运算符，而无权发明新的运算符号。例如，我们不能提供operator**来执行幂操作。 . 当某些符号可以表示多种不同的运算符时，我们可以从参数的数量推断到底定义的是哪种运算符。 比如符号-既是一元运算符也是二元运算符，&amp;虽然系统中的运用是为一元运算符，但也可以当作二元运算符使用等。 . 不管我们重载什么运算符，我们都无法改变该运算符的优先级和结合律。 当我们重载规定了求值顺序或者含有短路求值属性的运算符时，该运算符的求值顺序和短路求值属性就不再生效了。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#812-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%A7%84%E5%88%99",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#812-重载运算符的规则"
  },"554": {
    "doc": "重载运算符概念详解",
    "title": "8.13 重载运算符的使用",
    "content": "对于重载运算符，我们有两种调用方法： . | 隐式调用： 当我们定义了重载运算符后，在这些重载运算符的可用范围内，当出现含有运算符的表达式时，就会根据运算符的运算对象的类型隐式调用匹配的重载运算符；比如，对于某个运算对象为类类型对象来说，编译器会首先自动调用该对象类型的对应非静态重载运算符。 | 显式调用： 因为重载运算符也是函数，所以我们可以用调用函数的形式显式调用重载运算符，并在实参表中传递对应类型的实参。 | . #include &lt;iostream&gt; using namespace std; struct Cls { int ins = 5; Cls&amp; operator=(int val) { this-&gt;ins = val; return *this; } }; int operator+(Cls&amp; cls, int val) { return cls.ins + val; } Cls obj; // 隐式调用成员函数Cls&amp; operator=(int val)。 obj = 78; // 显式调用成员函数Cls&amp; operator=(int val)。 obj.operator=(30); // 输出30 cout &lt;&lt; obj.ins; // 以下都为调用普通函数int operator+(Cls&amp; cls, int val)。 // 隐式调用，输出45 cout &lt;&lt; obj + 15; // 显式调用，输出45 cout &lt;&lt; operator+(obj, 15); . 所以对于某些支持静态的重载运算符来说，只能显式调用来使用该运算符函数。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#813-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#813-重载运算符的使用"
  },"555": {
    "doc": "重载运算符概念详解",
    "title": "8.14 关于重载运算符的建议",
    "content": "虽然我们可以在重载运算符的规则内定义任何合法的运算符，但是为了保证用户在使用重载运算符不会出现错误以及良好的理解，我们在重载运算符时应该注意一下几点： . | 不应该被重载的运算符。 | 定义时要与内置类型的运算符含义一致。 | 复合赋值运算符的定义时机。 | 成员或者非成员运算符函数的选择。 | . 不应该被重载的运算符 . | 含有求值顺序或短路求值属性的运算符（如&amp;&amp;和||运算符）。 | 逗号运算符和取地址运算符。 | . 对于本身就含有求值顺序或短路求值属性的运算符，我们不应该重载，因为这些运算符的重载版本无法保留这些属性，因此不建议重载它们。 当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用了。 . 我们一般也不重载逗号运算符（,）和取地址运算符（&amp;）：因为C++语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。 因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应。 . 定义时要与内置类型的运算符含义一致 . 当你开始设计一个类时，首先应该考虑的是这个类将提供哪些操作。在确定类需要哪些操作之后，才能思考到底应该把每个类操作设成普通函数还是重载的运算符。如果某些操作在逻辑上与运算符相关，则它们适合于定义成重载的运算符，否则就不要定义重载的运算符。 也就是只有当操作的含义对于用户来说清晰明了时才使用运算符。 . 复合赋值运算符的定义时机 . 赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。重载的赋值运算应该继承而非违背其内置版本的含义。 . 如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符。无须赘言，+=运算符的行为显然应该与其内置版本一致，即先执行+，再执行=。 . 成员或者非成员运算符函数的选择 . 当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。在某些时候我们别无选择，因为有的运算符必须作为成员；另一些情况下，运算符作为普通函数比作为成员更好。 . 下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择： . | 赋值=、下标[]、调用()和成员访问箭头-&gt;运算符被规定必须是成员。 | 复合赋值运算符一般來说应该是成员。 | 改变对象状态的运算符或者与给定类型密切相关的运算符，如正号、负号、逻辑非、递增、递减以及解引用运算符等，通常应该是成员。 | 具有对称性的运算符可能转换任意一端的运算对象，例如算术、关系和位运算符等，因此它们通常应该是普通的非成员函数。 | 左边类型为非本身类型的运算符，就应该设计为非成员函数，如输入输出运算符等。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#814-%E5%85%B3%E4%BA%8E%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BB%BA%E8%AE%AE",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#814-关于重载运算符的建议"
  },"556": {
    "doc": "重载运算符概念详解",
    "title": "8.2 输入和输出运算符",
    "content": "如我们所知，IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入和输出操作。 对于这两个运算符来说，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。 . 输入输出运算符必须是非成员函数，否则，它们的左侧运算对象将是我们的类的一个对象，则它们也必须istream或ostream的成员。 然而，这两个类属于标准库，并且我们无法给标准厍中的类添加任何成员。所以只能是非成员函数。 . IO运算符通常都需要读写类的非公有数据成员，所以IO运算符一般被声明为友元。 . #include &lt;iostream&gt; // 类Cls class Cls { friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Cls&amp; obj); friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Cls&amp; obj); int val_; public: explicit Cls(int val = 0): val_(val) {} }; // 类Cls的输出运算符 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Cls&amp; obj) { os &lt;&lt; obj.val_; return os; } // 类Cls的输入运算符 std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Cls&amp; obj) { is &gt;&gt; obj.val_; // 处理输入失败的情况 if (!is) obj.val_ = 0; return is; } int main() { // 类Cls的对象 Cls obj(5); // 输出5 std::cout &lt;&lt; obj &lt;&lt; std::endl &lt;&lt; \"请输入一个整数（回车结束输入）：\\n\"; // 终端输入 std::cin &gt;&gt; obj; // 输出 std::cout &lt;&lt; obj &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#82-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#82-输入和输出运算符"
  },"557": {
    "doc": "重载运算符概念详解",
    "title": "8.21 输出运算符",
    "content": "通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。之所以ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法直接复制一个ostream对象。 第二个形参一般來说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参；而之所以该形参可以是常量是因为(通常情况下)打印对象不会改变对象的内容。 为了与其他输出运算符保持一致，operator&lt;&lt;般要返回它的ostream形参。 . 输出运算符尽量减少格式化操作： 用于内置类型的输出运算符不太考虑格式化操作，尤其不会打印换行符，用户希望类的输出运算符也像如此行事。如果运算符打印了换行符，则用户就无法在对象的同一行内接着打印一些描述性的文本了。相反，令输出运算符尽量减少格式化操作可以使用户有权控制输出的细节。 . #include &lt;iostream&gt; // 类Cls class Cls { friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Cls&amp; obj); int val_; public: explicit Cls(int val = 0): val_(val) {} }; // 类Cls的输出运算符 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Cls&amp; obj) { os &lt;&lt; obj.val_; return os; } int main() { // 类Cls的对象 Cls obj(5); // 输出5 std::cout &lt;&lt; obj &lt;&lt; std::endl &lt;&lt; \"请输入一个整数（回车结束输入）：\\n\"; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#821-%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#821-输出运算符"
  },"558": {
    "doc": "重载运算符概念详解",
    "title": "8.22 输入运算符",
    "content": "通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。 . 输入运算符必须处理输入可能失败的情况，当读取操作发生错误时，输入运算符应该负责从错误中恢复。 . #include &lt;iostream&gt; // 类Cls class Cls { friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Cls&amp; obj); int val_; public: explicit Cls(int val = 0): val_(val) {} }; // 类Cls的输入运算符 std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Cls&amp; obj) { is &gt;&gt; obj.val_; // 处理输入失败的情况 if (!is) obj.val_ = 0; return is; } int main() { // 类Cls的对象 Cls obj(5); // 终端输入 std::cin &gt;&gt; obj; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#822-%E8%BE%93%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#822-输入运算符"
  },"559": {
    "doc": "重载运算符概念详解",
    "title": "8.3 赋值运算符",
    "content": "之前已经介绍过拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给该类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。 . 和拷贝赋值及移动赋值运算符一样，其他重载的赋值运算符也必须先释放当前内存空间，再创建一片新空间。 . 我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。 . #include &lt;iostream&gt; // 类Cls class Cls { friend int main(); int val_; public: explicit Cls(int val = 0): val_(val) {} // 赋值运算符 Cls&amp; operator=(double val) { this-&gt;val_ = static_cast&lt;int&gt;(val); return *this; } }; int main() { // 类Cls的对象 Cls obj(5); obj = 45.66; // 输出45 std::cout &lt;&lt; obj.val_ &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#83-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#83-赋值运算符"
  },"560": {
    "doc": "重载运算符概念详解",
    "title": "8.31 复合赋值运算符",
    "content": "复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要返回其左侧运算对象的引用。 . #include &lt;iostream&gt; // 类Cls class Cls { friend int main(); int val_; public: explicit Cls(int val = 0): val_(val) {} // 加法赋值运算符 Cls&amp; operator+=(const Cls&amp; obj) { this-&gt;val_ += obj.val_; return *this; } // 减法赋值运算符 Cls&amp; operator-=(const Cls&amp; obj) { this-&gt;val_ -= obj.val_; return *this; } // 乘法赋值运算符 Cls&amp; operator*=(const Cls&amp; obj) { this-&gt;val_ *= obj.val_; return *this; } // 除法赋值运算符 Cls&amp; operator/=(const Cls&amp; obj) { this-&gt;val_ /= obj.val_; return *this; } // 除余赋值运算符 Cls&amp; operator%=(const Cls&amp; obj) { this-&gt;val_ %= obj.val_; return *this; } }; int main() { // 类Cls的对象 Cls obj(5); Cls obj2(53); obj += obj2; // 输出58 std::cout &lt;&lt; obj.val_ &lt;&lt; std::endl; obj *= obj2; // 输出3074 std::cout &lt;&lt; obj.val_ &lt;&lt; std::endl; obj /= obj2; // 输出58 std::cout &lt;&lt; obj.val_ &lt;&lt; std::endl; obj -= obj2; // 输出5 std::cout &lt;&lt; obj.val_ &lt;&lt; std::endl; obj2 %= obj; // 输出3 std::cout &lt;&lt; obj2.val_ &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#831-%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#831-复合赋值运算符"
  },"561": {
    "doc": "重载运算符概念详解",
    "title": "8.4 算术运算符",
    "content": "通常情况下，我们把算术运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。 . 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。 . #include &lt;iostream&gt; // 类Cls class Cls { friend int main(); int val_; public: explicit Cls(int val = 0): val_(val) {} // 加法赋值运算符 Cls&amp; operator+=(const Cls&amp; obj) { this-&gt;val_ += obj.val_; return *this; } // 减法赋值运算符 Cls&amp; operator-=(const Cls&amp; obj) { this-&gt;val_ -= obj.val_; return *this; } // 乘法赋值运算符 Cls&amp; operator*=(const Cls&amp; obj) { this-&gt;val_ *= obj.val_; return *this; } // 除法赋值运算符 Cls&amp; operator/=(const Cls&amp; obj) { this-&gt;val_ /= obj.val_; return *this; } // 除余赋值运算符 Cls&amp; operator%=(const Cls&amp; obj) { this-&gt;val_ %= obj.val_; return *this; } // 正号运算符（一元），不改变对象的状态，所以一般为常量 Cls operator+() const { return Cls(val_); } // 负号运算符（一元），不改变对象的状态，所以一般为常量 Cls operator-() const { return Cls(-val_); } }; // 加法运算符 Cls operator+(const Cls&amp; a, const Cls&amp; b) { Cls res = a; res += b; return res; } // 减法运算符 Cls operator-(const Cls&amp; a, const Cls&amp; b) { Cls res = a; res -= b; return res; } // 乘法运算符 Cls operator*(const Cls&amp; a, const Cls&amp; b) { Cls res = a; res *= b; return res; } // 除法运算符 Cls operator/(const Cls&amp; a, const Cls&amp; b) { Cls res = a; res /= b; return res; } // 除余运算符 Cls operator%(const Cls&amp; a, const Cls&amp; b) { Cls res = a; res %= b; return res; } int main() { // 类Cls的对象 const Cls kObj(5); const Cls kObj2(53); // 输出-5 std::cout &lt;&lt; (-kObj).val_ &lt;&lt; std::endl; // 输出53 std::cout &lt;&lt; (+kObj2).val_ &lt;&lt; std::endl; // 输出58 std::cout &lt;&lt; (kObj + kObj2).val_ &lt;&lt; std::endl; // 输出-48 std::cout &lt;&lt; (kObj - kObj2).val_ &lt;&lt; std::endl; // 输出265 std::cout &lt;&lt; (kObj * kObj2).val_ &lt;&lt; std::endl; // 输出0 std::cout &lt;&lt; (kObj / kObj2).val_ &lt;&lt; std::endl; // 输出3 std::cout &lt;&lt; (kObj2 % kObj).val_ &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#84-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#84-算术运算符"
  },"562": {
    "doc": "重载运算符概念详解",
    "title": "8.5 关系运算符",
    "content": "和算术运算符一样，通常情况下，我们把关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#85-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#85-关系运算符"
  },"563": {
    "doc": "重载运算符概念详解",
    "title": "8.51 相等运算符",
    "content": "通常情况下，C++中的类通过定义相等运算符来检验两个对象是否相等。也就是说，它们会比较对象的每一个数据成员，只有当所有对应的成员都相等时才认为两个对象相等。 . 所以对于相等运算符的定义，应该考虑以下设计准则： . | 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成operator==而非一个普通的命名函数： 因为用户肯定希望能使用==比较对象，所以提供了==就意味着用户无须再费时费力地学习并记忆一个全新的函数名字；此外，类定义了==运算符之后也更容易使用标准库容器和算法。 | 如果类定义了operator==，则该运算符应该能判断一组给定的对象中是否含有重复数据。 | 通常情况下，相等运算符应该具有传递性，换句话说，如果a==b和b==c都为真，则a==c也应该为真。 | 如果类定义了operator==,则这个类也应该定义operator!=。对于用户来说，当他们能使用==时肯定也希望能使用!=，反之亦然。 | 相等运算符和不相等运算符中的一个应该把工作委托给另外一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符。 | . // 类Cls class Cls { friend bool operator==(const Cls&amp; a, const Cls&amp; b); int val_; public: explicit Cls(int val = 0): val_(val) {} }; // 类Cls的相等运算符 bool operator==(const Cls&amp; a, const Cls&amp; b) { return a.val_ == b.val_; } // 类Cls的不相等运算符，不用为友元，因为实现用相等运算符 bool operator!=(const Cls&amp; a, const Cls&amp; b) { return !(a == b); } int main() { // 类Cls的对象 Cls obj(5); Cls obj2(48); // 输出0 std::cout &lt;&lt; (obj == obj2) &lt;&lt; std::endl; // 输出1 std::cout &lt;&lt; (obj != obj2) &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#851-%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#851-相等运算符"
  },"564": {
    "doc": "重载运算符概念详解",
    "title": "8.52 其他关系运算符",
    "content": "定义了相等运算符的类也常常（但不总是）包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义operator&lt;会比较有用。 . 通常情况下关系运算符应该考虑以下设计准则： . | 定义顺序关系，令其与关联容器中对关键字的要求一致 | 如果类同时也含有==运算符的话，则定义一种关系令其与==保持一致。特别是，如果两个对象是!=的，那么一个对象应该&lt;另外一个。 | . 如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。 . // 类Cls class Cls { friend bool operator==(const Cls&amp; a, const Cls&amp; b); friend bool operator&lt;(const Cls&amp; a, const Cls&amp; b); int val_; public: explicit Cls(int val = 0): val_(val) {} }; // 类Cls的相等运算符 bool operator==(const Cls&amp; a, const Cls&amp; b) { return a.val_ == b.val_; } // 类Cls的小于运算符 bool operator&lt;(const Cls&amp; a, const Cls&amp; b) { return (!(a == b)) &amp;&amp; (a.val_ &lt; b.val_); } // 类Cls的大于运算符 bool operator&gt;(const Cls&amp; a, const Cls&amp; b) { return !(a &lt; b || a == b); } // 类Cls的小于等于运算符 bool operator&lt;=(const Cls&amp; a, const Cls&amp; b) { return a &lt; b || a == b; } // 类Cls的大于等于运算符 bool operator&gt;=(const Cls&amp; a, const Cls&amp; b) { return !(a &lt; b); } int main() { // 类Cls的对象 Cls obj(5); Cls obj2(48); Cls obj3(48); // 输出1 std::cout &lt;&lt; (obj &lt; obj2) &lt;&lt; std::endl; // 输出0 std::cout &lt;&lt; (obj2 &lt; obj3) &lt;&lt; std::endl; // 输出0 std::cout &lt;&lt; (obj &gt; obj2) &lt;&lt; std::endl; // 输出0 std::cout &lt;&lt; (obj2 &gt; obj3) &lt;&lt; std::endl; // 输出1 std::cout &lt;&lt; (obj &lt;= obj2) &lt;&lt; std::endl; // 输出1 std::cout &lt;&lt; (obj2 &lt;= obj3) &lt;&lt; std::endl; // 输出0 std::cout &lt;&lt; (obj &gt;= obj2) &lt;&lt; std::endl; // 输出1 std::cout &lt;&lt; (obj2 &gt;= obj3) &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#852-%E5%85%B6%E4%BB%96%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#852-其他关系运算符"
  },"565": {
    "doc": "重载运算符概念详解",
    "title": "8.6 递增和递减运算符",
    "content": "在迭代器类中通常会实现递增运算符++和递减运算符--这两种运算符使得类可以在元素的序列中前后移动。 . C++语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。 . 对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#86-%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#86-递增和递减运算符"
  },"566": {
    "doc": "重载运算符概念详解",
    "title": "8.61 前置递增/递减运算符",
    "content": "假设类为Index，则通常成员函数的前置递增/递减运算符为： . 为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。 . #include &lt;iostream&gt; // 类Index class Index { friend int main(); int val_; public: explicit Index(int val = 0): val_(val) {} // 前置递增运算符 Index&amp; operator++() { this-&gt;val_ += 1; return *this; } // 前置递减运算符 Index&amp; operator--() { this-&gt;val_ -= 1; return *this; } }; int main() { // 输出0-10 for (Index i(-1); i.val_ &lt; 10;) std::cout &lt;&lt; (++i).val_ &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; // 输出10-0 for (Index i{11}; i.val_ &gt; 0;) std::cout &lt;&lt; (--i).val_ &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#861-%E5%89%8D%E7%BD%AE%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#861-前置递增递减运算符"
  },"567": {
    "doc": "重载运算符概念详解",
    "title": "8.62 后置递增/递减运算符",
    "content": "因为前置和后置版本的符号一样，为了解决这个问题，后置版本接受一个额外的(不被使用)int类型的形参。 . 只接受唯一一个int形参，不能有更多的形参或者非int形参。 . struct Cls { // 后置递增运算符 Cls&amp; operator++(int); // 后置递减运算符 Cls&amp; operator--(int); }; . 当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。 . 尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中通常不会这么做。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。 . 因为我们不会用到int形参，所以无须为其命名。 . 为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或递减之前的值)，返回的形式是一个值而非引用。 . #include &lt;iostream&gt; // 类Index class Index { friend int main(); int val_; public: explicit Index(int val = 0): val_(val) {} // 后置递增运算符 Index operator++(int) { Index res = *this; this-&gt;val_ += 1; return res; } // 后置递减运算符 Index operator--(int) { Index res = *this; this-&gt;val_ -= 1; return res; } }; int main() { // 输出0-10 for (Index i; i.val_ &lt;= 10;) std::cout &lt;&lt; (i++).val_ &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; // 输出10-0 for (Index i{10}; i.val_ &gt;= 0;) std::cout &lt;&lt; (i--).val_ &lt;&lt; std::endl; return 0; } . 后置版本的显式调用 . 当显式地调用后置运算符时，必须要向其传递一个int实参，因为编译器只有通过它才能知道应该使用后置版本。 . #include &lt;iostream&gt; // 类Index class Index { friend int main(); int val_; public: explicit Index(int val = 0): val_(val) {} // 后置递增运算符 Index operator++(int) { Index res = *this; this-&gt;val_ += 1; return res; } // 后置递减运算符 Index operator--(int) { Index res = *this; this-&gt;val_ -= 1; return res; } }; int main() { // 输出0-10 for (Index i; i.val_ &lt;= 10;) std::cout &lt;&lt; (i.operator++(0)).val_ &lt;&lt; std::endl; // 显式调用 std::cout &lt;&lt; std::endl; // 输出10-0 for (Index i{10}; i.val_ &gt;= 0;) std::cout &lt;&lt; (i.operator--(184)).val_ &lt;&lt; std::endl; // 显式调用 return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#862-%E5%90%8E%E7%BD%AE%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#862-后置递增递减运算符"
  },"568": {
    "doc": "重载运算符概念详解",
    "title": "8.7 下标运算符",
    "content": "表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。 . 下标运算符必须是成员函数。 . 为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。 . 进一步，我们最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。 . #include &lt;iostream&gt; // 类模板Array template&lt;const unsigned N&gt; class Array { friend int main(); int *ptr_vals_; public: explicit Array(int *ptr): ptr_vals_(ptr) {} // 下标运算符 int&amp; operator[](const unsigned index) { return ptr_vals_[index]; } // 下标运算符 const int&amp; operator[](const unsigned index) const { return ptr_vals_[index]; } }; int main() { int list[]{8,3,6,8}; Array&lt;4&gt; arr(list); // 输出8 std::cout &lt;&lt; (arr.ptr_vals_)[3] &lt;&lt; std::endl; arr[3] = 33; // 输出33 std::cout &lt;&lt; (arr.ptr_vals_)[3] &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#87-%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#87-下标运算符"
  },"569": {
    "doc": "重载运算符概念详解",
    "title": "8.8 解引用以及成员访问运算符",
    "content": "在迭代器类及智能指针类中常常用到解引用运算符*和箭头运算符-&gt;。 . 解引用运算符： . #include &lt;iostream&gt; #include &lt;string&gt; // 类IntegerPointer class IntegerPointer { int *ptr_; public: IntegerPointer(int &amp;val): ptr_(&amp;val) {} IntegerPointer(int *val): ptr_(val) {} // 解引用运算符 int &amp;operator*() { return *ptr_; } // 解引用运算符，用于常量 const int &amp;operator*() const { return *ptr_; } }; int main() { int ins = 7; int ins2 = -48; // 类IntegerPointer的对象 const IntegerPointer kObj(ins); IntegerPointer obj(ins2); // 输出7 std::cout &lt;&lt; *kObj &lt;&lt; std::endl; // 输出48 std::cout &lt;&lt; *obj &lt;&lt; std::endl; return 0; } . 箭头操作符与众不同，它是对对象解引用以获取成员。 它其实是一元操作符，却表现得像二元操作符一样：接受一个对象和一个成员名。但它不接受任何显式形参，形参表为空，因为-&gt;的右操作数不是表达式，相反，是对应着类成员的一个标识符。没有明显可行的途径将一个标识符作为形参传递给函数，该操作由编译器来自动获取其对应的成员。 . 箭头运算符必须是类的成员。而解引用运算符通常也是类的成员，尽管并非必须如此。 . 箭头运算符的限制 . 和大多数其他运算符一样(尽管这么做不太好)，我们能令operator*完成任何我们指定的操作。换句话说，我们可以让operator*返回一个固定值42,或者打印对象的内容，或者其他。 . 箭头运算符则不是这样，它永远不能丢掉成员访问这个最基本的含义。当我们重载箭头时，可以改变的是箭头从哪个对象当中获取成员，而箭头获取成员这一事实则永远不变。 . 对于形如point-&gt;mem的表达式来说，point必须是指向类对象的指针或者是一个重载了 operator-&gt;的类的对象。 . 根据point类型的不同，point-&gt;mem分別等价于 . (*point).mem; // point是一个内置的指针类型 point.operator()-&gt;mem; // point是类的一个对象 . 除此之外，代码都将发生错误。 . point-&gt;mem的执行过程如下所示： . | 如果point是指针，则我们应用内置的箭头运算符，表达式等价于(*point).mem。 首先解引用该指针，然后从所得的对象中获取指定的成员。如果point所指的类型没有名为mem的成员，程序会发生错误。 | 如果point是定义了operator-&gt;的类的一个对象，则我们使用point.operator-&gt;()的结果来获取mem。 其中，如果该结果是一个指针，则执行第1步；如果该结果本身含有重载的operator-&gt;()，则重复调用当前步骤。 最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息。 | . 所以重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。 . 箭头运算符： . #include &lt;iostream&gt; #include &lt;string&gt; // 类StringPointer class StringPointer { std::string *ptr_; public: StringPointer(std::string &amp;val): ptr_(&amp;val) {} StringPointer(std::string *val): ptr_(val) {} // 箭头运算符 // 注意，箭头运算符的返回类型必须为指针类型或者自定义了箭头运算符的某个类的对象 std::string* operator-&gt;() { return ptr_; } // 箭头运算符，用于常量 // 注意，箭头运算符的返回类型必须为指针类型或者自定义了箭头运算符的某个类的对象 const std::string* operator-&gt;() const { return ptr_; } }; int main() { std::string str = \"const strings\"; std::string str2 = \"strings\"; // 类StringPointer的对象 const StringPointer kObj(str); StringPointer obj(str2); // 输出13 std::cout &lt;&lt; kObj-&gt;size() &lt;&lt; std::endl; // 输出strings appended std::cout &lt;&lt; obj-&gt;append(\" appended\") &lt;&lt; std::endl; return 0; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#88-%E8%A7%A3%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html#88-解引用以及成员访问运算符"
  },"570": {
    "doc": "重载运算符概念详解",
    "title": "重载运算符概念详解",
    "content": "之前在类的介绍中，我们简述了一下关于重载 运算符的一些知识，接下来我们会详细讲述重载运算符。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html",
    
    "relUrl": "/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html"
  },"571": {
    "doc": "第九章 异常处理",
    "title": "第九章 异常处理",
    "content": "第9章先介绍了异常处理的概念与流程，然后对流程的各个部分进行详细介绍。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/index.html",
    
    "relUrl": "/guide_files/chap9/index.html"
  },"572": {
    "doc": "异常处理概念详解",
    "title": "9.1 异常处理的概念",
    "content": "异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。 . 典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一部分。 当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。 . 异常处理机制分为两部分： . | 异常检测 | 异常处理 | . 异常检测 . 该部分应该发出某种信号以表明程序遇到了故障，无法继续下去了，而且信号的发出方无须知道故障将在何处得到解决。一旦发出异常信号，检测出问题的部分也就完成了任务。 . 在C++语言中，异常检测部分是通过throw表达式(throw expression)来进行的。 . 使用throw表达式来表示它遇到了无法处理的问题。所以我们可以说throw引发(raise)了异常。 . 异常处理 . 如果程序中含有可能引发异常的代码，那么通常也会有异常处理代码来处理这些问题。例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据；如果丢失了数据库连接，会发出报警信息。 . 异常处理部分使用try语句块以及catch子句来处理异常。 try语句块以关键字try开始，并以一个或多个catch子句(catch clause)结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码(exception handler)。 . C++语言的标准库还定义了一套异常类(exception class)，用于在throw表达式和相关的catch子句之间传递异常的某些具体信息。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#91-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#91-异常处理的概念"
  },"573": {
    "doc": "异常处理概念详解",
    "title": "9.2 异常处理的流程",
    "content": "程序正常执行时，编译器会按照C++代码所规定的顺序执行其他非catch子句的语句，但是如果遇到了抛出异常的代码时，编译器就会进入异常处理模式。 . 通常的异常处理过程可以分为以下几个步骤，这个步骤被称为栈展开(stack unwinding)过程： . | 当一个throw表达式被执行时(包括调用函数的该函数中的或者创建类对象时隐式调用的构造函数中的)，该表达式就会抛出异常，然后编译器检查包含这个throw表达式的作用域是否为try语句块： 如果该作用域不为try语句块，则转到第2步，否则转到第3步。 | 检查包含该作用域(或者语句块)的作用域是否为try语句块，不是则继续向外层找，以此类推： 如果没有找到任何try语句块，则编译器调用标准库函数terminate，terminate负责终止程序的执行； 如果找到了try语句块，则转到第3步。 | 检査与该try语句块关联的catch子句是否有与其抛出异常匹配的子句： 如果找到了匹配的catch子句，就使用该子句处理异常，当该catch子句处理完毕后，有两种情况： . | 如果该catch子句关联的是构造函数try语句块或者析构函数try语句块，则编译器会在调用该构造或析构函数的位置重新抛出该异常并回到第2步进行操作。 | 否则，程序跳转到关联该catch子句的try语句块的最后一个catch子句之后的位置继续正常执行。 如果没有找到匹配的子句，则回到第2步。 | . | . 如果一个异常没有被捕获，则它将调用标准库函数terminate来终止当前的程序。 . 在栈展开过程中，每次编译器跳转到外层作用域进行查找时，就和函数调用完毕一样，之前内层的作用域的所有非静态局部变量都会自动执行销毁。 . 不管是构造函数发生异常还是其他情况的异常，编译器都将确保在这个块中创建的非静态对象能被正确地销毁： 如果某个局部对象的类型是类类型，则该对象的析构函数将被自动调用；与往常一样，编译器在销毁内置类型的对象时不需要做任何事情。 . 因为编译器是通过调用析构函数来销毁对应类型的对象的，所以如果析构函数本身抛出了异常，且该异常也没有被处理，则程序将被异常终止。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#92-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%B5%81%E7%A8%8B",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#92-异常处理的流程"
  },"574": {
    "doc": "异常处理概念详解",
    "title": "9.3 异常检测部分",
    "content": " ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#93-%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E9%83%A8%E5%88%86",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#93-异常检测部分"
  },"575": {
    "doc": "异常处理概念详解",
    "title": "9.31 throw表达式",
    "content": "在C++语言中，我们通过抛出（throwing）一条表达式来引发（raised）一个异常。 . throw表达式包含关键字throw和紧随其后的一个表达式，其中紧随其后的表达式的类型就是抛出的异常类型，该表达式的结果也就叫做异常对象。 throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。 . throw表达式的形式为： . throw 表达式 . throw 3.6 + 15; . 根据异常处理的流程，当执行一个throw表达式时，同作用域的跟在throw后面的语句将不再被执行。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#931-throw%E8%A1%A8%E8%BE%BE%E5%BC%8F",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#931-throw表达式"
  },"576": {
    "doc": "异常处理概念详解",
    "title": "9.32 异常对象",
    "content": "异常对象（exception object）是一种特殊的对象，该对象由throw表达式來创建并初始化的，throw表达式后面紧跟的表达式结果也就是异常对象。 . throw表达式的异常对象表达了所抛出的异常信息，随后异常处理部分的catch子句会根据该异常对象的类型进行匹配并处理该异常。 . 异常对象位于由编译器管理的特殊空间中，编译器确保无论最终调用的是哪个catch子句，都能访问到该空间中的异常对象。当异常处理完毕后，异常对象就会被销毁。 . 异常对象可以为空，也就是throw后面直接跟;，此时由于异常对象为空，没有任何catch子句能够匹配到，所以编译器会执行标准库函数terminate来终止程序。 . 异常对象的形式 . throw表达式后面紧跟的表达式的静态类型决定了异常对象的类型；且throw表达式是用该表达式的结果值对异常对象进行拷贝初始化。 . 对于表达式的静态类型是数组类型或函数类型来说，异常对象的类型则是与之对应的指针类型，且表达式的结果值也转换成了与之对应的指针类型。 . 因为表达式的静态类型决定了异常对象的类型，所以如果一条throw表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出。 . 对于异常对象的类型，有以下几种规定： . | 必须是完全类型。 | 如果是类类型的话，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。 | . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#932-%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#932-异常对象"
  },"577": {
    "doc": "异常处理概念详解",
    "title": "9.4 异常处理部分",
    "content": "当throw表达式抛出了异常后，被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码（handler）将被用来处理该异常。 . 被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内容，程序的异常抛出部分将会告知异常处理部分到底发生了什么错误。 . 异常处理部分使用try语句块以及catch子句来处理异常。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#94-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%83%A8%E5%88%86",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#94-异常处理部分"
  },"578": {
    "doc": "异常处理概念详解",
    "title": "9.41 try语句块",
    "content": "try语句块的通用语法形式是： . try 复合语句 catch 复合语句··· . try语句块的一开始是关键字try，随后紧跟着一个复合语句。 try语句块后面必须跟一个或多个catch子句，这些catch子句也就是与之关联的子句。 . try语句块中的复合语句是一个局部作用域，可以包含任意能在复合语句中使用的代码。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#941-try%E8%AF%AD%E5%8F%A5%E5%9D%97",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#941-try语句块"
  },"579": {
    "doc": "异常处理概念详解",
    "title": "9.411 函数try语句块",
    "content": "通常情况下，程序执行的任何时刻都可能发生异常，特别是异常可能发生在函数执行中。 . 虽然我们可以在函数体中写上try语句，但是如果我们想对整个函数体进行异常处理时，就行不通了。 . 还有一些特殊函数： . | 比如构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的try语句块还未生效，所以构造函数体内的catch子句无法处理构造函数初始值列表抛出的异常。 | 比如在析构函数体内的catch子句不能处理隐式析构部分抛出的异常。 | . 所以为了处理函数执行时抛出的异常，我们可以将这些函数写成函数try语句块(也称为函数测试块，function try block)的形式。 . 函数try语句块的定义形式为： . | 对于构造函数来说： . (可选 类型限定符) 类名 形参表 (可选 类型限定符) try 初始值列表 函数体 catch子句 . | 对于析构函数来说： . (可选 类型限定符) ~类名 () (可选 类型限定符) try 函数体 catch子句 . | 对于其他函数来说： . (可选 类型限定符) 返回类型 函数名 形参表 (可选 类型限定符) try 函数体 catch子句 (可选 类型限定符) auto 函数名 形参表 (可选 类型限定符) -&gt; 返回类型 try 函数体 catch子句 . | . 所以函数try语句块中的try部分没有复合语句块。 而且函数try语句块只能出现在函数定义中，不能在函数声明时出现。 . constexpr构造函数不能使用函数try语句块。 . struct Cls { int ins; inline Cls(int val); // 静态成员函数try语句块 static auto prints() -&gt; void try { cout &lt;&lt; \"Cls\\n\"; } catch(int obj) { cout &lt;&lt; obj &lt;&lt; \" error\\n\"; } // 成员函数try语句块 auto ret(int val) const -&gt; int try { return val*val; } catch(int obj) { cout &lt;&lt; obj &lt;&lt; \" error\\n\"; } // 析构函数try语句块 virtual ~Cls() try {} catch(int obj) { cout &lt;&lt; obj &lt;&lt; \" error\\n\"; } }; // 构造函数try语句块 inline Cls::Cls(int val) try: ins(8) {} catch(int obj) { cout &lt;&lt; obj &lt;&lt; \" error\\n\"; } // 普通函数try语句块 void prints2() try { cout &lt;&lt; \"External\\n\"; } catch(int obj) { cout &lt;&lt; obj &lt;&lt; \" error\\n\"; } . 对于函数try语句块来说，其关联的catch子句既能处理构造函数体(或者析构函数体和普通函数体)，也能处理构造函数的初始化部分(或析构函数的析构部分)。 . 对于成员函数try语句块(包括构造和析构函数)来说，其关联的catch子句能像该成员函数本身一样对该类其他成员有着一些访问权限；且该catch子句还能使用这些函数的形参(但不能用函数体定义的局部变量)，所以catch子句的异常声明不能与这些形参同名。 . 对于构造和析构函数try语句块来说，当这些函数try语句块关联的catch子句处理完异常后，编译器还会在这些函数的调用位置重新抛出该异常并继续执行异常处理。 . struct Cls { int ins; Cls(int val) try: ins(8) { throw 56; } catch(int obj) { cout &lt;&lt; obj &lt;&lt; \" error\\n\"; } }; void prints() try { throw \"prints\"; } catch(const char* str) { cout &lt;&lt; str &lt;&lt; \" error\\n\"; } /* 输出 prints error 56 error capture again*/ try { prints(); Cls ob(3); } catch (int obj) { cout &lt;&lt; \"capture again\\n\"; } . 不管某函数是不是函数try语句块形式，该函数的所有形参的初始化都不属于函数try语句块的一部分，在形参的初始化过程中发生的异常是属于调用表达式的。 所以在函数形参初始化过程中发生的异常只能在其调用表达式的上下文中处理了。 . struct Ex { Ex() { throw \"Ex\"; } }; struct Cls { Ex ins; Cls(Ex val) try: ins() {} catch(const char* str) { cout &lt;&lt; str &lt;&lt; \" error\\n\"; } }; // 输出Ex capture try { Cls ob({}); } catch (const char* obj) { cout &lt;&lt; obj &lt;&lt; \" capture\\n\"; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#9411-%E5%87%BD%E6%95%B0try%E8%AF%AD%E5%8F%A5%E5%9D%97",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#9411-函数try语句块"
  },"580": {
    "doc": "异常处理概念详解",
    "title": "9.42 catch子句",
    "content": "catch子句的形式为： . catch (异常声明) 复合语句 . 每个catch子句只与同作用域下的最近的try语句块关联。 . catch子句中的复合语句也是一个局部作用域，可以包含任意能在复合语句中使用的代码。 . 异常声明(exception declaration)类似于只包含一个形参的函数形参列表，异常声明不能为空。 像在形参列表中一样，如果catch无须访问该参数的话，则我们可以在定义中省略该参数名字。 . 该声明参数的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，但不能是右值引用。 . 当进入一个catch语句后，通过异常对象初始化异常声明中的参数。 . 和函数的参数类似，如果catch的参数类型是非引用类型，则该参数是异常对象的一个副本，在catch语句内改变该参数实际上改变的是局部副本而非异常对象本身；相反，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名，此时改变参数也就是改变异常对象。 . try { int ins; cin &gt;&gt; ins; if (ins == 0) throw \"Can't divide by zero!\"; else cout &lt;&lt; 35.0 / ins; } catch (const char* str) { cout &lt;&lt; str &lt;&lt; endl; } . catch参数和普通函数的形参类似，支持继承的动态绑定。所以，通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#942-catch%E5%AD%90%E5%8F%A5",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#942-catch子句"
  },"581": {
    "doc": "异常处理概念详解",
    "title": "9.421 catch子句的匹配过程",
    "content": "catch子句的匹配过程也就叫做捕获异常过程。 子句的匹配过程是根据抛出的异常对象的类型和catch子句中的异常声明的类型来匹配的。 . 与实参和形参的匹配规则相比，catch子句的匹配规则受到更多限制。 此时，绝大多数类型转换都不被允许，除了一些极细小的差別之外，要求异常的类型和catch声明的类型要基本上精确匹配。 . 以下catch语句的匹配规则： . | 要按照catch语句的出现顺序逐一进行匹配，只要出现一个语句能匹配时，就会匹配成功而忽略之后的catch语句。 | 只允许以下的类型转换，除此之外的其他所有转换规则(包括算术类型转换和类类型转换在内)都不能使用： . | 允许非顶层const和顶层const的相互类型转换。 | 允许从非底层const向底层const的类型转换。 | 允许从派生类向基类的类型转换(包括其指针和引用)。 | 允许数组和函数被转换成对应类型的指针。 | . | . try { const int ins = 18; // 按照规则，匹配的是catch (int val)，\\ 所以输出error1 18 throw ins; } catch (int val) { cout &lt;&lt; \"error1 \" &lt;&lt; val &lt;&lt; endl; } catch (const int val) { cout &lt;&lt; \"error2 \" &lt;&lt; val &lt;&lt; endl; } catch (double val) { cout &lt;&lt; \"error3 \" &lt;&lt; val &lt;&lt; endl; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#9421-catch%E5%AD%90%E5%8F%A5%E7%9A%84%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#9421-catch子句的匹配过程"
  },"582": {
    "doc": "异常处理概念详解",
    "title": "9.422 捕获所有异常",
    "content": "有时我们希望不论抛出的异常是什么类型，程序都能统一捕获它们。 为了一次性捕获所有异常，我们使用省略号...作为catch语句的异常声明，这样的处理代码称为捕获所有异常(catch-all)的处理代码，形如catch(...)的catch语句可以与任意类型的异常对象匹配(除了空异常对象，空异常对象不能被任何catch语句捕获)。 . 形如catch(...)的catch语句既能单独关联某个try语句块，也能与其他几个catch语句一起关联，但是catch(...)语句必须要放在这些catch语句的最后一个，否则编译出错。 . 使用省略号的异常声明中只能有省略号而不能有其他的符号或者标识符，所以对于捕获所有异常的catch语句来说，我们并不能直接用该异常对象。 . // 输出error try { const int ins = 18; throw ins; } catch (...) { cout &lt;&lt; \"error\" &lt;&lt; endl; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#9422-%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#9422-捕获所有异常"
  },"583": {
    "doc": "异常处理概念详解",
    "title": "9.423 重新抛出",
    "content": "有时，一个单独的catch语句不能完整地处理某个异常。在执行了某些校正操作之后，当前的catch语句可能会决定由调用链更上一层的函数接着处理异常。 一条catch语句通过重新抛出(rethrowing)的操作将异常传递给另外一个catch语句。 . 重新抛出的操作就是在捕获当前异常对象的catch子句中写上一个throw表达式，由该catch子句再次抛出异常，让外层作用域的catch子句处理该异常。 . 可以通过多个catch子句的throw表达式进行多次重新抛出。 . 关于catch子句中throw表达式的形式，和普通的throw表达式一样，既可以写上异常对象，也可以省略： . | 如果写上了异常对象，则编译器储存该异常对象的类型和初始值。 | 如果省略，则编译器按照之前的异常对象进行传递。 | . 要注意如果catch的异常声明为引用类型，那么就会绑定到该异常对象上，所以对引用的修改也会影响到异常对象。 . // 输出error1 18\\ error3 str try { try { const int ins = 18; throw ins; } catch (int val) { cout &lt;&lt; \"error1 \" &lt;&lt; val &lt;&lt; endl; throw \"str\"; } catch (const char* str) { cout &lt;&lt; \"error2 \" &lt;&lt; str &lt;&lt; endl; } } catch (const char* str) { cout &lt;&lt; \"error3 \" &lt;&lt; str &lt;&lt; endl; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#9423-%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#9423-重新抛出"
  },"584": {
    "doc": "异常处理概念详解",
    "title": "9.5 异常说明",
    "content": "对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。 首先，知道函数不会抛出异常有助于简化调用该函数的代码；其次，如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#95-%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#95-异常说明"
  },"585": {
    "doc": "异常处理概念详解",
    "title": "9.51 异常说明的形式",
    "content": "所以我们可以对函数进行不抛出异常说明来指定某个函数不会抛出异常，这也叫做不抛出说明(nonthrowing specification)。 . 对于不抛出异常说明，有两种： . | 关键字throw() | 关键字noexcept | . 关键字throw()是c++11之前标准所设计的，而关键字noexcept是c++11新加的，并对用了关键字noexcept的函数有特殊优化。 . 这两种说明符的放置位置是相同的，都是紧跟在函数的参数列表后面；如果函数为成员函数，则说明符还要在const及引用限定符之后，final、override或虚函数的=0之前；如果说明符要用于函数的尾置返回类型形式，则应放在返回类型之前。 . 异常说明符还可以在函数指针的声明和定义中使用，但不能在typedef或类型别名中使用。 . 对于每一个使用异常说明符的函数來说，异常说明符必须要在该函数的声明或定义中全都出现，否则出错。 . // 用throw()的函数 void prints() throw(); void prints() throw() { cout &lt;&lt; \"Print\\n\"; } // 用noexcept的函数 auto ret() noexcept -&gt; int { return 15; } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#951-%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E%E7%9A%84%E5%BD%A2%E5%BC%8F",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#951-异常说明的形式"
  },"586": {
    "doc": "异常处理概念详解",
    "title": "9.52 异常说明的作用",
    "content": "编译器并不会在编译时检查异常说明符。 . 实际上，如果一个函数在说明了不抛出异常的同时又含有throw语句或者调用了可能抛出异常的其他函数，编译器还是会顺利编译通过，并不会因为这种违反异常说明的情况而报错(不排除个別编译器会对这种用法提出警告)。 . 所以对于说明了不抛出异常但同时又可能抛出异常的函数来说，程序就会在调用该函数时调用terminate函数来终止程序，以确保遵守不在运行时抛出异常的承诺(但对于所有的函数try语句块不生效，也就是说函数try语句块有无异常说明符都是一样的异常处理流程)。 . 异常说明符noexcept还接受一个可选的实参(有且仅有一个实参)，该实参的类型必须能转换为bool类型：如果实参是true，则函数不会抛出异常；如果实参是false，则函数可能抛出异常。 以下为含有说明符noexcept的函数声明，假设函数为void prints() . // 以下两种函数声明都为可能抛出异常的函数声明 void prints(); void prints() noexcept(false); // 以下三种函数声明都为不抛出异常的函数声明 void prints() noexcept; void prints() noexcept(1); void prints() throw(); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#952-%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E%E7%9A%84%E4%BD%9C%E7%94%A8",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#952-异常说明的作用"
  },"587": {
    "doc": "异常处理概念详解",
    "title": "9.53 noexcept说明符的规定",
    "content": "尽管noexcept说明符不属于函数类型的一部分，但是其仍然会影响函数的使用。 . 以下是noexcept说明符函数的几种规定： . | 声明了不抛出异常的函数指针只能指向不抛出异常的函数，反之则不用。 | 声明了不抛出异常的虚函数，在后续派生类的覆盖中也必须声明不抛出异常，反之则不用。 | 当编译器生成合成拷贝控制成员时，同时也会为其生成一个noexcept说明符，该说明符的状态是根据该类成员(包括继承的)的异常说明符来决定的： 如果合成的拷贝控制成员将会调用的任意函数都承诺不会抛出异常，则该合成的拷贝控制成员是noexcept的，反之则是noexcept(false)。 | 如果我们定义的析构函数中没有提供异常说明符，则编译器将会为其添加一个noexcept说明符。 和编译器生成合成拷贝控制成员时一样，该说明符的状态是根据该析构函数将会调用的所有函数的异常说明符来决定的。 | . struct Ba { int ins; virtual void prints() noexcept(0) { cout &lt;&lt; ins &lt;&lt; endl;} virtual void prints2() noexcept { cout &lt;&lt; ins &lt;&lt; endl;} }; struct De: Ba { // 正确覆盖 void prints() {} // 正确覆盖 void prints2() noexcept {} }; int ret(int val) {} int ret2(int val) noexcept {} // 错误：ptr只能指向noexcept函数 int (*ptr) (int) noexcept = ret; // 正确覆盖 int (*ptr2) (int) noexcept = ret2; . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#953-noexcept%E8%AF%B4%E6%98%8E%E7%AC%A6%E7%9A%84%E8%A7%84%E5%AE%9A",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#953-noexcept说明符的规定"
  },"588": {
    "doc": "异常处理概念详解",
    "title": "9.54 noexcept运算符",
    "content": "noexcept运算符为一元运算符，运算对象在右侧。 . 运算对象为右值。运算结果为右值。 . noexcept运算符接受一个或多个非声明或定义的表达式，并返回一个bool类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。 . 所以noexcept运算符接受的表达式中不能含有类型名。 . noexcept运算符的使用形式有两种： . | noexcept (expr) . | noexcept (expr1, expr2, expr3, ···) . | . noexcept运算符会根据表达式结果的异常说明来决定返回true还是false： 如果该表达式调用的函数做了不抛出说明或者该表达式不是throw表达式，则返回true，否则返回false。 . 对于第二种形式来说，必须所有的表达式都满足返回true的条件，运算符才会返回true，否则返回false。 . 和sizeof类似，noexcept也不用求其运算对象的值而直接得出结果。 . 对于非throw表达式的表达式的结果不是由函数调用所得时(也就是表达式只是普通的变量，比如一个函数名或者其他对象名)，noexcept运算符一律当作true . void prints() {} void prints2(int val) noexcept {} int ins = 18; // 因为prints2为noexcept函数，所以\\ 输出1 cout &lt;&lt; noexcept(prints2(3)); // 因为prints不为noexcept函数，所以\\ 输出0 cout &lt;&lt; noexcept(prints(), prints2(6)); // 因为ins只是对象名，所以\\ 输出1 cout &lt;&lt; noexcept(ins); // 因为prints只是函数名，所以\\ 输出1 cout &lt;&lt; noexcept(prints); . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#954-noexcept%E8%BF%90%E7%AE%97%E7%AC%A6",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#954-noexcept运算符"
  },"589": {
    "doc": "异常处理概念详解",
    "title": "9.6 异常类",
    "content": "C++语言的标准库定义了一组类，用于报告标准库函数遇到的问题。 这些类也叫做异常类(exception class)。 . 这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中： . | exception头文件： 定义了最通用的异常类型exception。 它只报告异常的发生，不提供任何额外信息。 | stdexcept头文件： 定义了几种常用的异常类型。 | new头文件： 定义了bad_alloc异常类型。 | type_info头文件： 定义了bad_cast异常类型。 | . 下表为stdexcept头文件中定义的异常类型： . 标准库所有的异常类型其实是一个继承体系，下图为该继承体系： . 异常类型exception仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为what的虚函数。 . 其中what函数返回一个const char*，该指针指向一个以'\\0'结尾的字符数组，并且确保不会抛出任何异常。 . 对于为exception、bad_alloc、bad_cast类型的异常对象来说，它们只支持默认初始化，所以不允许为这些对象提供初始值；但对于为其他标准库异常类型的异常对象来说，它们不支持默认初始化，且它们只能用string对象或者字符串字面值来初始化。 . 继承自异常类型exception的其他异常类型的what虚函数负责返回用于初始化对应类型的异常对象信息。因为what是虚函数，所以当我们捕获基类的引用时，对what函数的调用将执行与异常对象动态类型对应的版本。 . try { throw runtime_error(\"error\"); } // 调用runtime_error类的what函数\\ 输出error catch (const exception&amp; err) { cout &lt;&lt; err.what(); } . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#96-%E5%BC%82%E5%B8%B8%E7%B1%BB",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html#96-异常类"
  },"590": {
    "doc": "异常处理概念详解",
    "title": "异常处理概念详解",
    "content": "异常处理是在程序开发时非常重要的一部分。 . 异常处理（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。 . 异常使得我们能够将问题的检测与解决过程分离开来。 程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。 检测环节无须知道问题处理模块的所有细节，反之亦然。 . ",
    "url": "/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html",
    
    "relUrl": "/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html"
  }
}
