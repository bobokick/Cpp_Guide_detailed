<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul:nth-of-type(1) > li > ul > li > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li:not(:nth-child(3)) > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li > ul > li > a { background-image: none; } .site-nav > ul:not(:nth-of-type(1)) a, .site-nav li.external a { background-image: none; } .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(2) > ul > li:nth-child(3) > a { font-weight: 600; text-decoration: none; } .site-nav > ul.nav-category-list > li > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(2) > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(2) > ul > li:nth-child(3) > button svg { transform: rotate(-90deg); } .site-nav > ul.nav-category-list > li.nav-list-item > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(2) > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(2) > ul.nav-list > li.nav-list-item:nth-child(3) > ul.nav-list { display: block; } </style> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.stemmer.support.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.zh.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.multi.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>限定符与说明符 | C++语法教程</title> <meta name="generator" content="Jekyll v3.9.3" /> <meta property="og:title" content="限定符与说明符" /> <meta name="author" content="BBK" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="2.5 常量限定符" /> <meta property="og:description" content="2.5 常量限定符" /> <link rel="canonical" href="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html" /> <meta property="og:url" content="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html" /> <meta property="og:site_name" content="C++语法教程" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2025-02-11T03:16:47+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="限定符与说明符" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BBK"},"dateModified":"2025-02-11T03:16:47+00:00","datePublished":"2025-02-11T03:16:47+00:00","description":"2.5 常量限定符","headline":"限定符与说明符","mainEntityOfPage":{"@type":"WebPage","@id":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html"},"url":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/Cpp_Guide_detailed/" class="site-title lh-tight"> C++语法教程 </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第一章 c++入门介绍 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap1/index.html" class="nav-list-link">第一章 c++入门介绍</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html" class="nav-list-link">预处理指令概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第二章 基本类型与变量 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap2/index.html" class="nav-list-link">第二章 基本类型与变量</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html" class="nav-list-link">类型与变量</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html" class="nav-list-link">复合类型</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html" class="nav-list-link">限定符与说明符</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第三章 表达式 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap3/index.html" class="nav-list-link">第三章 表达式</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" class="nav-list-link">表达式概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第四章 语句 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap4/index.html" class="nav-list-link">第四章 语句</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html" class="nav-list-link">语句概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第五章 函数 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap5/index.html" class="nav-list-link">第五章 函数</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html" class="nav-list-link">函数概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第六章 动态内存管理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap6/index.html" class="nav-list-link">第六章 动态内存管理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" class="nav-list-link">动态内存管理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第七章 类 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap7/index.html" class="nav-list-link">第七章 类</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">类概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第八章 重载运算符 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap8/index.html" class="nav-list-link">第八章 重载运算符</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html" class="nav-list-link">重载运算符概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第九章 异常处理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap9/index.html" class="nav-list-link">第九章 异常处理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html" class="nav-list-link">异常处理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十章 模板 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap10/index.html" class="nav-list-link">第十章 模板</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html" class="nav-list-link">模板概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十一章 派生类类型 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap11/index.html" class="nav-list-link">第十一章 派生类类型</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">派生类类型概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十二章 命名空间 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap12/index.html" class="nav-list-link">第十二章 命名空间</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html" class="nav-list-link">命名空间概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十三章 分离式编译 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap13/index.html" class="nav-list-link">第十三章 分离式编译</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html" class="nav-list-link">分离式编译概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十四章 固有的不可移植特性 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap14/index.html" class="nav-list-link">第十四章 固有的不可移植特性</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html" class="nav-list-link">固有的不可移植特性概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十五章 标准库 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap15/index.html" class="nav-list-link">第十五章 标准库</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html" class="nav-list-link">标准库详解</a></li></ul></li></ul> </nav> <footer class="site-footer"> <button type="button" id="theme_switch_button" class="site-button btn-reset" theme_id="dark" onclick="switch_theme()">切换到<b id="current_theme_name">明亮</b>主题 </button> <script src=/Cpp_Guide_detailed/assets/js/cookie_manager.js></script> <script src=/Cpp_Guide_detailed/assets/js/theme_switch.js></script> </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search C++语法教程" aria-label="Search C++语法教程" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://github.com/bobokick/Cpp_Guide_detailed" class="site-button" > Cpp_Guide_detailed on GitHub </a> </li> </ul> </nav> </div> <div class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/index.html">第二章 基本类型与变量</a></li> <li class="breadcrumb-nav-list-item"><span>限定符与说明符</span></li> </ol> </nav> <div id="main-content" class="main-content"> <main> <div> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h3"><a href="#25-常量限定符">2.5 常量限定符</a> <ul> <li class="toc-entry toc-h4"><a href="#251-const限定符">2.51 const限定符</a> <ul> <li class="toc-entry toc-h5"><a href="#2511-非引用或指针类型的const变量">2.511 非引用或指针类型的const变量</a></li> <li class="toc-entry toc-h5"><a href="#2512-引用类型的const变量">2.512 引用类型的const变量</a></li> <li class="toc-entry toc-h5"><a href="#2513-指针类型const变量">2.513 指针类型const变量</a></li> </ul> </li> <li class="toc-entry toc-h4"><a href="#252-constexpr限定符">2.52 constexpr限定符</a> <ul> <li class="toc-entry toc-h5"><a href="#2521-常量表达式">2.521 常量表达式</a></li> <li class="toc-entry toc-h5"><a href="#2522-constexpr变量">2.522 constexpr变量</a> <ul> <li class="toc-entry toc-h6"><a href="#25221-constexpr变量的定义和初始化">2.5221 constexpr变量的定义和初始化</a></li> <li class="toc-entry toc-h6"><a href="#25222-字面值类型简述">2.5222 字面值类型简述</a></li> <li class="toc-entry toc-h6"><a href="#25223-constexpr函数简述">2.5223 constexpr函数简述</a></li> </ul> </li> </ul> </li> </ul> </li> <li class="toc-entry toc-h3"><a href="#26-类型别名">2.6 类型别名</a> <ul> <li class="toc-entry toc-h4"><a href="#261-类型别名的使用">2.61 类型别名的使用</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#27-类型自动推断">2.7 类型自动推断</a> <ul> <li class="toc-entry toc-h4"><a href="#271-auto类型说明符">2.71 auto类型说明符</a></li> <li class="toc-entry toc-h4"><a href="#272-decltype类型说明符">2.72 decltype类型说明符</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#28-引用折叠">2.8 引用折叠</a></li> </ul> </div> <div id="markdown-content"> <h3 id="25-常量限定符"> <a href="#25-常量限定符" class="anchor-heading" aria-labelledby="25-常量限定符"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.5 常量限定符 </h3> <p>有时我们希望定义这样一种变量，它的值不能被改变。此时可以用常量类型修饰符对变量的类型加以限定。</p> <p>对于常量类型修饰符，有两种</p> <ul> <li><code class="language-plaintext highlighter-rouge">const</code></li> <li><code class="language-plaintext highlighter-rouge">constexpr</code></li> </ul> <p>这两种虽然都能定义常量类型，但是还是有很大的区别的。</p> <blockquote> <p>虽然没有意义，但是<code class="language-plaintext highlighter-rouge">const</code>和<code class="language-plaintext highlighter-rouge">constexpr</code>可以作用于同一个定义或声明语句中，修饰同一个类型，此时变量以类型修饰符<code class="language-plaintext highlighter-rouge">constexpr</code>的规则为主。</p> </blockquote> <h4 id="251-const限定符"> <a href="#251-const限定符" class="anchor-heading" aria-labelledby="251-const限定符"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.51 <code class="language-plaintext highlighter-rouge">const</code>限定符 </h4> <p>例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。 另一方面，也应随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以用关键字<code class="language-plaintext highlighter-rouge">const</code>对变量的类型加以限定</p> <p>一般定义<code class="language-plaintext highlighter-rouge">const</code>对象的语句形式为</p> <blockquote> <p>const 类型说明符 变量名 (初始化); 或 类型说明符 const 变量名 (初始化);</p> </blockquote> <p>任何<code class="language-plaintext highlighter-rouge">const</code>对象一旦创建后其值就不能再改变，任何试图为其赋值的行为都将引发错误。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span> <span class="c1">// 输入缓冲区大小</span>
<span class="n">buf</span> <span class="n">Size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span> <span class="c1">//错误：试图向const对象写值</span>
</code></pre></div></div> <p>类型修饰符<code class="language-plaintext highlighter-rouge">const</code>既可作用于类型，也可作用于变量。当无其他类型修饰符修饰变量时，默认作用于其类型。</p> <blockquote> <p>作用于类型时，放置在类型的左边右边都可以。 作用于变量时，只能放置在变量的左边。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这两个定义语句形式等价，都是定义了3个const int型变量，const此时修饰的是int类型</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="k">const</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="c1">// 定义了一个指向int的常量指针p和一个int变量ins，const此时修饰的是变量p</span>
<span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</code></pre></div></div> <p>因为<code class="language-plaintext highlighter-rouge">const</code>对象一旦创建后其值就不能再改变，所以==定义的<code class="language-plaintext highlighter-rouge">const</code>对象必须显式初始化==。一如既往，初始值可以是任意复杂的表达式。</p> <blockquote> <p>但是<code class="language-plaintext highlighter-rouge">const</code>变量可以用extern只声明而不定义。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">get_size</span> <span class="p">()</span> <span class="p">;</span> <span class="c1">//正确：运行时初始化</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">//正确：编译时初始化</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">k</span><span class="p">;</span> <span class="c1">//错误：k是一个未经初始化的</span>
</code></pre></div></div> <blockquote> <p>默认状态下，<code class="language-plaintext highlighter-rouge">const</code>对象仅在当前文件内有效，要想多文件内都有效要用之前说的<code class="language-plaintext highlighter-rouge">extern</code>存储修饰符。</p> </blockquote> <h5 id="2511-非引用或指针类型的const变量"> <a href="#2511-非引用或指针类型的const变量" class="anchor-heading" aria-labelledby="2511-非引用或指针类型的const变量"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.511 非引用或指针类型的<code class="language-plaintext highlighter-rouge">const</code>变量 </h5> <p><code class="language-plaintext highlighter-rouge">const</code>对于非引用或指针类型的变量来说，用<code class="language-plaintext highlighter-rouge">const</code>修饰后的变量，其变量无法被赋值。</p> <p>对于容器类来说，<code class="language-plaintext highlighter-rouge">const</code>的对象不仅无法被赋值，其元素也无法类赋值。</p> <p>对于派生类类型来说，<code class="language-plaintext highlighter-rouge">const</code>的对象不仅无法被赋值，其非<code class="language-plaintext highlighter-rouge">mutable</code>的非静态成员也无法被赋值，且<code class="language-plaintext highlighter-rouge">const</code>对象无法使用非<code class="language-plaintext highlighter-rouge">const</code>的函数成员。</p> <blockquote> <p>支持拷贝初始化的非引用或指针类型的<code class="language-plaintext highlighter-rouge">const</code>变量与对应类型的非<code class="language-plaintext highlighter-rouge">const</code>变量之间能够相互初始化对方。 支持赋值的非引用或指针类型的非<code class="language-plaintext highlighter-rouge">const</code>变量能够被对应类型的<code class="language-plaintext highlighter-rouge">const</code>变量赋值。</p> </blockquote> <h5 id="2512-引用类型的const变量"> <a href="#2512-引用类型的const变量" class="anchor-heading" aria-labelledby="2512-引用类型的const变量"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.512 引用类型的<code class="language-plaintext highlighter-rouge">const</code>变量 </h5> <p>可以把引用绑定到<code class="language-plaintext highlighter-rouge">const</code>对象上，就像绑定到其他对象上一样，我们称之为对常量 的引用(reference to const)。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象</p> <blockquote> <p>要注意引用本身并不是对象，所以<code class="language-plaintext highlighter-rouge">const</code>只能修饰引用所绑定的对象的类型</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">rl</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">//正确：引用及其对应的对象都是常量</span>
<span class="n">rl</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1">//错误：rl是对常量的引用</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>  <span class="c1">//错误：试图让一个非常量引用指向一个常量对象</span>
</code></pre></div></div> <p>之前说过，引用的类型必须与其所引用对象的类型一致，不能用常量引用来初始化非常量引用。</p> <blockquote> <p>右值常量引用同样遵循这个规则，不能用常量引用来初始化右值非常量引用。</p> </blockquote> <blockquote> <p>要注意，不管是右值引用还是右值常量引用都能绑定到对应类型的字面值常量上。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">r1</span> <span class="o">=</span> <span class="mi">84</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">r1</span><span class="p">);</span> <span class="c1">// 正确：右值常量引用来初始化右值常量引用。</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">r1</span><span class="p">);</span> <span class="c1">// 错误：不能用右值常量引用来初始化右值非常量引用。</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">r4</span> <span class="o">=</span> <span class="mi">53</span><span class="p">;</span> <span class="c1">// 正确：右值引用可以由字面值常量来初始化。</span>
</code></pre></div></div> <p>左值常量引用能够用任意表达式作为初始值，尤其，允许为一个常量引用绑定对应类型的常量或非常量引用、非常量的对象、字面值，甚至是个一般表达式(也就是左值常量引用能够绑定到右值上了)：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span><span class="o">-</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">rl</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//允许将const int&amp;绑定到一个普通int对象上</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">//正确：rl是一个常量引用</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">rl</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//正确：r3是一个常量引用</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r4</span> <span class="o">=</span> <span class="n">rl</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//错误：r4是一个普通的非常量引用</span>
</code></pre></div></div> <h5 id="2513-指针类型const变量"> <a href="#2513-指针类型const变量" class="anchor-heading" aria-labelledby="2513-指针类型const变量"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.513 指针类型<code class="language-plaintext highlighter-rouge">const</code>变量 </h5> <p>根据<code class="language-plaintext highlighter-rouge">const</code>在指针对象所处的不同位置，<code class="language-plaintext highlighter-rouge">const</code>指针可以分为两种</p> <ul> <li>顶层<code class="language-plaintext highlighter-rouge">const</code>(top-level <code class="language-plaintext highlighter-rouge">const</code>)</li> <li>底层<code class="language-plaintext highlighter-rouge">const</code> (low-level <code class="language-plaintext highlighter-rouge">const</code>)</li> </ul> <p>顶层<code class="language-plaintext highlighter-rouge">const</code>表示该指针本身是个常量，更一般的，顶层<code class="language-plaintext highlighter-rouge">const</code>可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等(引用本身就是不可被修改赋值的)。</p> <p>而底层<code class="language-plaintext highlighter-rouge">const</code>一般用于表示指针所指的对象是一个常量，多用于与指针和引用类型</p> <blockquote> <p>指针类型既可以是顶层<code class="language-plaintext highlighter-rouge">const</code>也可以是底层<code class="language-plaintext highlighter-rouge">const</code>，或者两者都是</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">pl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span> <span class="c1">//不能改变pl的值，这是一个顶层const</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">//不能改变ci的值，这是一个顶层const</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span> <span class="c1">//允许改变p2的值，这是一个底层const</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span> <span class="c1">// 靠右的 const 是顶层 const,靠左的是底层 const </span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">//用于声明引用的const都是底层const</span>
</code></pre></div></div> <p>顶层<code class="language-plaintext highlighter-rouge">const</code>和底层顶层<code class="language-plaintext highlighter-rouge">const</code>的区别为</p> <ul> <li> <p>顶层<code class="language-plaintext highlighter-rouge">const</code>能初始化或赋值对应类型的非<code class="language-plaintext highlighter-rouge">const</code>变量，非<code class="language-plaintext highlighter-rouge">const</code>变量也能初始化顶层<code class="language-plaintext highlighter-rouge">const</code></p> </li> <li> <p>非<code class="language-plaintext highlighter-rouge">const</code>变量能初始化底层<code class="language-plaintext highlighter-rouge">const</code>，但底层<code class="language-plaintext highlighter-rouge">const</code>却不能初始化或赋值对应类型的非<code class="language-plaintext highlighter-rouge">const</code>变量。</p> </li> </ul> <blockquote> <p>也就是所有的非常量都能转换为常量，而反过来，只有顶层<code class="language-plaintext highlighter-rouge">const</code>才能转成非常量，底层<code class="language-plaintext highlighter-rouge">const</code>不行。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">//正确：拷贝ci的值，ci是一个顶层const,对此操作无影响</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">p3</span><span class="p">;</span> <span class="c1">//正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">p3</span><span class="p">;</span> <span class="c1">//错误：p3包含底层const的定义，而p没有</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">p3</span><span class="p">;</span> <span class="c1">//正确：p2和p3都是底层</span>
<span class="k">const</span> <span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span> <span class="c1">// 正确：int*能转换成 </span>
<span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">//错误：普通的int&amp;不能绑定到int常量上</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//正确：const int&amp;可以绑定到一个普通in</span>
</code></pre></div></div> <h4 id="252-constexpr限定符"> <a href="#252-constexpr限定符" class="anchor-heading" aria-labelledby="252-constexpr限定符"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.52 <code class="language-plaintext highlighter-rouge">constexpr</code>限定符 </h4> <p>在讲解<code class="language-plaintext highlighter-rouge">constexpr</code>限定符之前，我们需要先弄清楚常量表达式的概念。</p> <h5 id="2521-常量表达式"> <a href="#2521-常量表达式" class="anchor-heading" aria-labelledby="2521-常量表达式"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.521 常量表达式 </h5> <p>常量表达式，是指值不会改变并且在编译过程中就能得到计算结果的表达式。显然，字面值属于常量表达式。</p> <blockquote> <p>常量表达式不能是任何的声明或定义形式的表达式。</p> </blockquote> <p>常量表达式的值要在编译过程中就能得到结果，指的是以下几种情况：</p> <ol> <li>常量表达式中参与常量表达式结果运算的子表达式必须要能在编译过程中就能得到结果，而不能要在程序运行时才能获得。</li> <li>常量表达式中不参与常量表达式结果运算的子表达式要在该常量表达式所对应的语句执行之前就能得到结果。</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 非常量的int变量</span>
<span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">85</span><span class="p">;</span>
<span class="c1">// 正确："literals"是字面值，不需要在该表达式运行时才能有结果。cstexpr_ins值为8。</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">cstexpr_ins</span> <span class="o">=</span> <span class="p">(</span><span class="s">"literals"</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="c1">// 正确：ins是非常量的int变量，ins的值在该定义语句之前就已经获得。cstexpr_ins2值为15。</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">cstexpr_ins2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
<span class="c1">// 错误：表达式ins = 18需要在该定义语句运行时才能得到结果。</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">cstexpr_ins3</span> <span class="o">=</span> <span class="p">(</span><span class="n">ins</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="c1">// 错误：表达式ins + 18需要在该定义语句运行时才能得到结果。</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">cstexpr_ins4</span> <span class="o">=</span> <span class="p">(</span><span class="n">ins</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</code></pre></div></div> <p>常量和常量表达式的概念不一样：</p> <ul> <li>常量是指字面值或者由<code class="language-plaintext highlighter-rouge">const</code>或<code class="language-plaintext highlighter-rouge">constexpr</code>类型说明符修饰的变量。</li> <li>满足以下任意一种情况才为常量表达式： <ul> <li>满足常量表达式情况的式子。</li> <li>字面值。</li> <li>由<code class="language-plaintext highlighter-rouge">const</code>类型说明符修饰的变量，且该变量的初始值也是常量表达式。</li> <li>由<code class="language-plaintext highlighter-rouge">constexpr</code>类型说明符修饰的已初始化的变量。</li> </ul> </li> </ul> <blockquote> <p>所以可知==常量不一定是常量表达式，但常量表达式一定是常量==。</p> </blockquote> <p>一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定的。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">max_files</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// max_files 是常量表达式</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">max_files</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// limit 是常量表达式</span>
<span class="kt">int</span> <span class="n">staff_size</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span> <span class="c1">// staff_size 不是常量表达式，由于它的数据类型只是一个普通int而非const，所以它不属于常量表达式</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">get_size</span><span class="p">();</span> <span class="c1">// sz 不是常量表达式。尽管sz本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。</span>
</code></pre></div></div> <h5 id="2522-constexpr变量"> <a href="#2522-constexpr变量" class="anchor-heading" aria-labelledby="2522-constexpr变量"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.522 <code class="language-plaintext highlighter-rouge">constexpr</code>变量 </h5> <p>C++11新标准规定，允许将变量声明为<code class="language-plaintext highlighter-rouge">constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。</p> <blockquote> <p>类型修饰符<code class="language-plaintext highlighter-rouge">constexpr</code>只作用于变量，但是是放置在类型的左边或右边。<code class="language-plaintext highlighter-rouge">constexpr</code>修饰的是该定义语句的所有定义的变量而不是某一个，所以一个语句中只需在开头标注就行。</p> </blockquote> <h6 id="25221-constexpr变量的定义和初始化"> <a href="#25221-constexpr变量的定义和初始化" class="anchor-heading" aria-labelledby="25221-constexpr变量的定义和初始化"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.5221 <code class="language-plaintext highlighter-rouge">constexpr</code>变量的定义和初始化 </h6> <p>声明为<code class="language-plaintext highlighter-rouge">constexpr</code>的变量的类型一定要是字面值类型，而且<strong>必须用常量表达式初始化</strong>，所以==<code class="language-plaintext highlighter-rouge">constexpr</code>变量一定是常量表达式==。</p> <p>和<code class="language-plaintext highlighter-rouge">const</code>变量一样，==定义的<code class="language-plaintext highlighter-rouge">constexpr</code>变量也必须显式初始化==，且<code class="language-plaintext highlighter-rouge">constexpr</code>变量不能用<code class="language-plaintext highlighter-rouge">extern</code>只声明而不定义。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">mf</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// 20 是常量表达式</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">mf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// mf + 1 是常量表达式</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">size</span><span class="p">();</span> <span class="c1">// 只有当 size 是一个constexpr 函数时，才是一条正确的声明</span>
</code></pre></div></div> <p>对于类型修饰符<code class="language-plaintext highlighter-rouge">constexpr</code>来说，不存在像<code class="language-plaintext highlighter-rouge">const</code>一样有着顶层底层之分，<code class="language-plaintext highlighter-rouge">constexpr</code>修饰指针和引用时，只会作用于它们本身，不会影响到它们所指的对象</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// p是一个指向整型常量的指针</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// q是一个指向整数的常量指针</span>
</code></pre></div></div> <blockquote> <p>尽管指针和引用都能定义成<code class="language-plaintext highlighter-rouge">constexpr</code>，但它们的初始值却受到严格限制。 一个<code class="language-plaintext highlighter-rouge">constexpr</code>指针的初始值必须是空指针，或者是非栈区的对象。 <code class="language-plaintext highlighter-rouge">constexpr</code>引用也是一样，只能绑定非栈区的对象。</p> </blockquote> <h6 id="25222-字面值类型简述"> <a href="#25222-字面值类型简述" class="anchor-heading" aria-labelledby="25222-字面值类型简述"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.5222 字面值类型简述 </h6> <p>常量表达式的值需要在编译时就得到计算，因此对声明<code class="language-plaintext highlighter-rouge">constexpr</code>时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”。</p> <p>之前所说的算术类型、引用、指针和枚举类型都属于字面值类型，除此之外，类类型中的字面值常量类也属于字面值类型，其他的类型都不是字面值类型。</p> <h6 id="25223-constexpr函数简述"> <a href="#25223-constexpr函数简述" class="anchor-heading" aria-labelledby="25223-constexpr函数简述"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.5223 <code class="language-plaintext highlighter-rouge">constexpr</code>函数简述 </h6> <p>尽管不能使用普通函数作为<code class="language-plaintext highlighter-rouge">constexpr</code>变量的初始值，但新标准允许定义一种特殊的<code class="language-plaintext highlighter-rouge">constexpr</code>函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用<code class="language-plaintext highlighter-rouge">constexpr</code>函数去初始化<code class="language-plaintext highlighter-rouge">constexpr</code>变量了。</p> <h3 id="26-类型别名"> <a href="#26-类型别名" class="anchor-heading" aria-labelledby="26-类型别名"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.6 类型别名 </h3> <p>当有时候我们所要声明或定义的类型比较长或者复杂时，为了使用时简单明了、易于理解和使用，我们可以定义类型别名。</p> <p>类型别名(type alias)是一个名字，它是某种类型的同义词。</p> <p>类型别名可用于单一类型，也可用于类型加多个类型修饰符的复杂类型。</p> <blockquote> <p>不能定义<code class="language-plaintext highlighter-rouge">auto</code>和<code class="language-plaintext highlighter-rouge">decltype</code>的类型别名</p> </blockquote> <p>有两种方法可用于定义类型别名：</p> <ul> <li>使用关键字 <code class="language-plaintext highlighter-rouge">typedef</code></li> <li>使用关键字 <code class="language-plaintext highlighter-rouge">using</code> (该方法也叫做别名声明(alias declaration))</li> </ul> <p><strong><code class="language-plaintext highlighter-rouge">typedef</code>定义类型别名</strong></p> <p>使用关键字<code class="language-plaintext highlighter-rouge">typedef</code>的语句形式为</p> <blockquote> <p>typedef (可选 类型修饰符) 类型说明符 (可选 类型修饰符)别名1, (可选 类型修饰符)别名2, …;</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">double</span> <span class="n">wages</span><span class="p">;</span> <span class="c1">//wages是double的同义词</span>
<span class="k">typedef</span> <span class="n">wages</span> <span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">//base是double的同义词，p是double*的同义词</span>
</code></pre></div></div> <p>和普通声明语句一样，关键字<code class="language-plaintext highlighter-rouge">typedef</code>的语句可看做为一种声明语句，<em>关键字<code class="language-plaintext highlighter-rouge">typedef</code>看作为数据类型的一部分</em>，但此声明语句中的定义的是类型别名而不是变量。</p> <blockquote> <p>类型修饰符放置的位置和用于普通声明语句一样，放在该放的位置。<code class="language-plaintext highlighter-rouge">typedef</code>可以放在声明语句最前面，也可以紧跟在类型说明符的前面。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这两个语句等价，rt1，rt2是const int&amp;的同义词。</span>
<span class="c1">// pt1，pt2是const int *const的同义词。</span>
<span class="k">const</span> <span class="k">typedef</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">rt1</span><span class="p">,</span> <span class="o">*</span><span class="k">const</span> <span class="n">pt1</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">rt2</span><span class="p">,</span> <span class="o">*</span><span class="k">const</span> <span class="n">pt2</span><span class="p">;</span>
</code></pre></div></div> <p><strong>别名声明定义类型别名</strong></p> <p>使用关键字<code class="language-plaintext highlighter-rouge">using</code>的语句形式为</p> <blockquote> <p>using 别名 = 类型说明符(可选 类型修饰符);</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">SI</span> <span class="o">=</span> <span class="n">Sales_item</span><span class="p">;</span> <span class="c1">// SI是Sales_item的同义词</span>
<span class="k">using</span> <span class="n">ciptr</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="k">const</span><span class="p">;</span>  <span class="c1">// ciptr是const int *const的同义词</span>
</code></pre></div></div> <blockquote> <p>类型修饰符放置的位置和用于普通声明语句一样，放在该放的位置。</p> </blockquote> <blockquote> <p>别名声明和<code class="language-plaintext highlighter-rouge">typedef</code>的形式不一样，一个别名声明语句只能定义一个别名。</p> </blockquote> <h4 id="261-类型别名的使用"> <a href="#261-类型别名的使用" class="anchor-heading" aria-labelledby="261-类型别名的使用"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.61 类型别名的使用 </h4> <p>类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">wages</span> <span class="n">hourly</span><span class="p">,</span> <span class="n">weekly</span><span class="p">;</span> <span class="c1">// 等价于 double hourly、weekly。</span>
<span class="n">SI</span> <span class="n">item</span><span class="p">;</span> <span class="c1">// 等价于 Sales_item item。</span>
</code></pre></div></div> <p>当用类型别名声明语句定义了一个类型别名时，该类型别名里的所有东西组成了一个基本类型，类型别名里的类型修饰符也是这个基本类型的一部分。要注意当该类型别名用作的类型别名声明语句时的情况：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pstring</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// cstr是指向char的常量指针</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span> <span class="c1">// ps是一个指针，它的对象是指向char的常量指针</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 是对const pstring cstr的错误理解</span>
</code></pre></div></div> <h3 id="27-类型自动推断"> <a href="#27-类型自动推断" class="anchor-heading" aria-labelledby="27-类型自动推断"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.7 类型自动推断 </h3> <p>当我们需要定义一个某表达式的类型的变量，但无法得知或很难得知其类型时，我们可以定义一种能让编译器自动分析表达式所属的类型的变量。</p> <p>类型自动推断有两种方法</p> <ul> <li><code class="language-plaintext highlighter-rouge">auto</code>类型说明符</li> <li><code class="language-plaintext highlighter-rouge">decltype</code>类型说明符</li> </ul> <h4 id="271-auto类型说明符"> <a href="#271-auto类型说明符" class="anchor-heading" aria-labelledby="271-auto类型说明符"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.71 <code class="language-plaintext highlighter-rouge">auto</code>类型说明符 </h4> <p>通过定义<code class="language-plaintext highlighter-rouge">auto</code>类型的变量，可以让编译器通过分析其变量的初始值所属的类型自动决定该变量的类型。显然，<code class="language-plaintext highlighter-rouge">auto</code>定义的变量必须显式初始化。</p> <p><code class="language-plaintext highlighter-rouge">auto</code>类型的声明形式为：</p> <blockquote> <p>auto(可含类型修饰符) 变量名 (可选 初始化)</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//由vail和val2相加的结果可以推断出item的类型</span>
<span class="k">auto</span> <span class="n">item</span> <span class="o">=</span> <span class="n">vail</span> <span class="o">+</span> <span class="n">val2</span><span class="p">;</span> <span class="c1">// item初始化为vail和val2相加的结果</span>
</code></pre></div></div> <p>和普通定义语句一样，<code class="language-plaintext highlighter-rouge">auto</code>定义语句也能在一条语句中声明多个变量。<code class="language-plaintext highlighter-rouge">auto</code>以第一个变量的初始值类型来决定变量的类型。 因为一条声明语句只能有一个基本类型，因此该语句中所有变量的类型都一样。所以每个变量的初始值的类型必须严格一致(能隐式转换也不行)：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span> <span class="c1">//正确：i是整数、p是整型指针</span>
<span class="k">auto</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span> <span class="c1">// 错误：sz 和 pi 的类型不一致</span>
</code></pre></div></div> <p><strong>常量和<code class="language-plaintext highlighter-rouge">auto</code>的关系</strong></p> <p>当常量用来初始化<code class="language-plaintext highlighter-rouge">auto</code>类型的变量时，编译器推断出来的类型和初始值的类型并不完全一样。</p> <p><code class="language-plaintext highlighter-rouge">auto</code>默认情况下会忽略掉顶层<code class="language-plaintext highlighter-rouge">const</code>，所以希望推断出的类型是一个顶层<code class="language-plaintext highlighter-rouge">const</code>，则需要明确指定为<code class="language-plaintext highlighter-rouge">const</code>。</p> <p>当初始化的值为左值时，<code class="language-plaintext highlighter-rouge">auto</code>会保留底层<code class="language-plaintext highlighter-rouge">const</code>；为右值时，<code class="language-plaintext highlighter-rouge">auto</code>会忽略掉底层<code class="language-plaintext highlighter-rouge">const</code>。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// b是一个整数（ci的顶层const特性被忽略掉了）</span>
<span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cr</span><span class="p">;</span> <span class="c1">// c是一个整数（cr是ci的别名，ci本身是一个顶层const） </span>
<span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span> <span class="c1">// d是一个整型指针（整数的地址就是指向整数的指针）</span>
<span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span> <span class="c1">// e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// ci的推演类型是int, f是const int</span>
<span class="k">auto</span> <span class="o">&amp;</span><span class="n">g</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// g是一个整型常量引用，绑定到ci</span>
<span class="k">auto</span> <span class="o">&amp;</span><span class="n">h</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">//错误：不能为非常量引用绑定字面值</span>
<span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">j</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">//正确：可以为常量引用绑定字面值</span>
</code></pre></div></div> <h4 id="272-decltype类型说明符"> <a href="#272-decltype类型说明符" class="anchor-heading" aria-labelledby="272-decltype类型说明符"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.72 <code class="language-plaintext highlighter-rouge">decltype</code>类型说明符 </h4> <p>有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。 此时可以用<code class="language-plaintext highlighter-rouge">decltype</code>类型说明符，它的作用是返回非声明或定义形式的表达式(右值)的操作数的数据类型</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">decltype</code>类型说明符的括号内只能放表达式，不能含有类型名，也不能含有<code class="language-plaintext highlighter-rouge">auto</code>，像``decltype<code class="language-plaintext highlighter-rouge">(</code>auto<code class="language-plaintext highlighter-rouge">)</code>是不行的。</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">decltype</code>类型的声明形式为：</p> <blockquote> <p>(可含类型修饰符)decltype(表达式) 变量名 (可选 初始化)</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">())</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// sum的类型就是函数f的返回类型。</span>
</code></pre></div></div> <p>当<code class="language-plaintext highlighter-rouge">decltype</code>的括号内是一个单一变量时，则<code class="language-plaintext highlighter-rouge">decltype</code>返回该变量的类型(包括顶层<code class="language-plaintext highlighter-rouge">const</code>和引用在内)：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cj</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// x的类型是const int</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// y的类型是const int&amp;, y绑定到变量x </span>
<span class="k">decltype</span><span class="p">(</span><span class="n">cj</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="c1">// 错误：z是一个引用，必须初始化</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">cj</span><span class="p">)</span> <span class="n">z</span><span class="p">;</span>
</code></pre></div></div> <p>如果<code class="language-plaintext highlighter-rouge">decltype</code>的括号内是一个复杂表达式，那么<code class="language-plaintext highlighter-rouge">decltype</code>返回该表达式结果会有一些不同：</p> <ul> <li>当==表达式==的结果==是右值==时==<code class="language-plaintext highlighter-rouge">decltype</code>返回==该表达式结果==对应的类型==。</li> <li>如果==是左值==时，<code class="language-plaintext highlighter-rouge">decltype</code>返回该表达式结果==对应的类型的引用==。</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// decltype的结果可以是引用类型</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="k">decltype</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="n">b</span><span class="p">;</span> <span class="c1">//正确：加法的结果是int，因此b是一个(未初始化的)int</span>
<span class="k">decltype</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="n">c</span><span class="p">;</span> <span class="c1">//错误：c是int&amp;,必须初始化</span>
</code></pre></div></div> <p>当<code class="language-plaintext highlighter-rouge">decltype</code>的括号内是一个变量名加上了一对(或多对)括号时，该表达式的结果也是左值，所以<code class="language-plaintext highlighter-rouge">decltype</code>就会返回该变量类型的引用类型。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// decltype的表达式如果是加上了括号的变量，结果将是引用</span>
<span class="c1">// 错误：d1，d2是int&amp;,必须初始化</span>
<span class="k">decltype</span><span class="p">((</span><span class="n">i</span><span class="p">))</span> <span class="n">d1</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(((</span><span class="n">i</span><span class="p">)))</span> <span class="n">d2</span><span class="p">;</span> 
<span class="k">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">e</span><span class="p">;</span> <span class="c1">//正确：e是一个(未初始化的)int。</span>
</code></pre></div></div> <p>当类型修饰符与<code class="language-plaintext highlighter-rouge">decltype</code>类型说明符一起用时，这些类型修饰符都会视为修饰<code class="language-plaintext highlighter-rouge">decltype</code>所返回的类型。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ins</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">lr</span> <span class="o">=</span> <span class="n">ins</span><span class="p">;</span>
<span class="c1">// 等价于const int var1</span>
<span class="k">const</span> <span class="k">decltype</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span> <span class="n">var1</span><span class="p">;</span>
<span class="c1">// 等价于int *const &amp;var2</span>
<span class="k">const</span> <span class="k">decltype</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">var2</span><span class="p">;</span>
<span class="c1">// 因为引用不是对象，引用本身不能为const\</span>
<span class="err">所以等价于</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">var3</span>
<span class="k">const</span> <span class="k">decltype</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span> <span class="n">var3</span><span class="p">;</span>
<span class="c1">// 等价于const int &amp;var4</span>
<span class="k">const</span> <span class="k">decltype</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">var4</span><span class="p">;</span>
</code></pre></div></div> <blockquote> <p>因为函数是一种特殊的函数对象，也可以用在<code class="language-plaintext highlighter-rouge">decltype</code>中，且可以使用<strong>只声明未定义</strong>的函数(因为<code class="language-plaintext highlighter-rouge">decltype</code>说明符只会获取其数据类型)</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="c1">// 只声明未定义的函数</span>
<span class="kt">int</span> <span class="nf">prints</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="c1">// 相同函数原型的定义函数</span>
<span class="kt">int</span> <span class="nf">getVal</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">val</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 正确：使用函数prints来定义func对象的变量类型</span>
    <span class="c1">// decltype(prints)*等价于为int (*)(int)</span>
    <span class="k">decltype</span><span class="p">(</span><span class="n">prints</span><span class="p">)</span><span class="o">*</span> <span class="n">func</span> <span class="o">=</span> <span class="n">getVal</span><span class="p">;</span>
    <span class="c1">// 输出46</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">func</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>虽然引用类类型中的非静态数据成员需要与特定对象相对应，但是由于<code class="language-plaintext highlighter-rouge">decltype</code>只获取对象的类型，所以其也可以用于类类型中的非静态数据成员。和静态数据成员一样用作用域运算符来进行访问。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">class</span> <span class="nc">Class</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">double</span> <span class="n">dou_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 正确：使用函数prints来定义dou_obj对象的变量类型</span>
    <span class="c1">// decltype(Class::dou_)等价于为double</span>
    <span class="k">decltype</span><span class="p">(</span><span class="n">Class</span><span class="o">::</span><span class="n">dou_</span><span class="p">)</span> <span class="n">dou_obj</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>
    <span class="c1">// 输出3.1415</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dou_obj</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="28-引用折叠"> <a href="#28-引用折叠" class="anchor-heading" aria-labelledby="28-引用折叠"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.8 引用折叠 </h3> <p>之前我们讲述过关于引用的各种规则。</p> <p>尤其是以下这两个规则：</p> <ul> <li>不能定义引用的引用。</li> <li>左值非常量引用只能绑定到左值，而左值常量引用还能绑定到右值；右值引用只能绑定到右值。</li> </ul> <p>对于普通情况来说，这两个规则是适用的，但是，C++语言在该 绑定规则之外还定义了两个例外，这两种例外会允许某些特殊的绑定：</p> <ul> <li>我们可以间接地定义一个引用的引用。</li> <li>如果间接定义了一个引用的引用，则这些引用会进行折叠。</li> </ul> <p>以下是这两种例外的说明：</p> <ol> <li>间接定义一个引用的引用有以下几种方法： <ul> <li>通过使用类型別名</li> <li>通过使用类型自动推断 <ul> <li><code class="language-plaintext highlighter-rouge">auto</code>类型说明符</li> <li><code class="language-plaintext highlighter-rouge">decltype</code>类型说明符</li> <li>某些模板形参</li> </ul> </li> </ul> </li> <li>引用折叠会将该对象的所有引用折叠成普通的引用，根据引用的类型，折叠情况分为两种(其中X代表类型说明符和其他的类型修饰符)： <ul> <li>以下这三种情况都会折叠成左值引用<code class="language-plaintext highlighter-rouge">X&amp;</code>： <ul> <li><code class="language-plaintext highlighter-rouge">X&amp; &amp;</code></li> <li><code class="language-plaintext highlighter-rouge">X&amp; &amp;&amp;</code></li> <li><code class="language-plaintext highlighter-rouge">X&amp;&amp; &amp;</code></li> </ul> </li> <li>以下这一种情况会折叠成右值引用<code class="language-plaintext highlighter-rouge">X&amp;&amp;</code>： <ul> <li><code class="language-plaintext highlighter-rouge">X&amp;&amp; &amp;&amp;</code></li> </ul> </li> </ul> </li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">int_r</span><span class="p">;</span>
<span class="k">using</span> <span class="n">int_rr</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&amp;&amp;</span><span class="p">;</span>

<span class="c1">// int_r_r等价于</span>
<span class="c1">// int&amp; &amp;，折叠成</span>
<span class="c1">// int&amp;</span>
<span class="k">typedef</span> <span class="n">int_r</span><span class="o">&amp;</span> <span class="n">int_r_r</span><span class="p">;</span>
<span class="c1">// int_r_rr等价于</span>
<span class="c1">// int&amp; &amp;&amp;，折叠成</span>
<span class="c1">// int&amp;</span>
<span class="k">typedef</span> <span class="n">int_r</span><span class="o">&amp;&amp;</span> <span class="n">int_r_rr</span><span class="p">;</span>
<span class="c1">// int_rr_r等价于</span>
<span class="c1">// int&amp;&amp; &amp;，折叠成</span>
<span class="c1">// int&amp;</span>
<span class="k">using</span> <span class="n">int_rr_r</span> <span class="o">=</span> <span class="n">int_rr</span><span class="o">&amp;</span><span class="p">;</span>
<span class="c1">// int_rr_rr等价于</span>
<span class="c1">// int&amp;&amp; &amp;&amp;，折叠成</span>
<span class="c1">// int&amp;&amp;</span>
<span class="k">using</span> <span class="n">int_rr_rr</span> <span class="o">=</span> <span class="n">int_rr</span><span class="o">&amp;&amp;</span><span class="p">;</span>
<span class="c1">// 等价于int &amp;var</span>
<span class="n">int_r_r</span> <span class="n">var</span> <span class="o">=</span> <span class="n">ins</span><span class="p">;</span>
<span class="c1">// 等价于int &amp;var1</span>
<span class="n">int_r_rr</span> <span class="n">var1</span> <span class="o">=</span> <span class="n">ins</span><span class="p">;</span>
<span class="c1">// 等价于int &amp;var2</span>
<span class="n">int_rr_r</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">ins</span><span class="p">;</span>
<span class="c1">// 等价于int &amp;&amp;var3</span>
<span class="n">int_rr_rr</span> <span class="n">var3</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">lr</span> <span class="o">=</span> <span class="n">ins</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="c1">// 等价于int&amp; &amp;&amp;var</span>
<span class="c1">// 折叠成int&amp; var</span>
<span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">var</span> <span class="o">=</span> <span class="n">ins</span><span class="p">;</span>
<span class="c1">// 等价于int&amp; &amp;var1</span>
<span class="c1">// 折叠成int&amp; var1</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">var1</span> <span class="o">=</span> <span class="n">ins</span><span class="p">;</span>
<span class="c1">// 等价于int&amp; &amp;&amp;var2</span>
<span class="c1">// 折叠成int&amp; var2</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span> <span class="o">&amp;&amp;</span><span class="n">var2</span> <span class="o">=</span> <span class="n">ins</span><span class="p">;</span>
<span class="c1">// 等价于int&amp;&amp; &amp;var3</span>
<span class="c1">// 折叠成int&amp; var3</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">var3</span> <span class="o">=</span> <span class="n">ins</span><span class="p">;</span>
<span class="c1">// 等价于int&amp;&amp; &amp;&amp;var4</span>
<span class="c1">// 折叠成int&amp;&amp; var4</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span> <span class="o">&amp;&amp;</span><span class="n">var4</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ty</span><span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="c1">// val的类型等价于int&amp; &amp;&amp;</span>
<span class="c1">// 折叠成int&amp;</span>
<span class="n">prints</span><span class="p">(</span><span class="n">ins</span><span class="p">);</span>
</code></pre></div></div> <p>这个规则能够得出一个重要的结论，也就是我们能够使用间接方式来使右值类型变量接受任意的左右值属性对象。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 该模板接受左值和右值，并把它们的类型和左右值属性原封不动再返回。</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="n">ty</span> <span class="nf">res</span><span class="p">(</span><span class="n">ty</span><span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="c1">// 正确，ty类型为int&amp;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">rin</span> <span class="o">=</span> <span class="n">res</span><span class="p">(</span><span class="n">ins</span><span class="p">);</span>
<span class="c1">// 错误，ty类型为int&amp;</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rrin</span> <span class="o">=</span> <span class="n">res</span><span class="p">(</span><span class="n">ins</span><span class="p">);</span>
<span class="c1">// 正确，ty类型为int</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rrin2</span> <span class="o">=</span> <span class="n">res</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
</code></pre></div></div> </div> </div> </main> <hr> <footer> <!-- # Footer content # appears at the bottom of every page's main content --> <p class="text-small text-grey-dk-100 mb-0"> Copyright &copy; 2020-2024 bobokick. Distributed by an <a href="https://github.com/bobokick/Cpp_Guide_detailed/blob/master/LICENSE">Apache License 2.0.</a> </p> <div class="d-flex mt-2"> <p class="text-small text-grey-dk-000 mb-0"> <a href="https://github.com/bobokick/Cpp_Guide_detailed/tree/master/docs/my_collections/_guide_files/chap2/第2章_基本类型与变量3.md" id="edit-this-page">Edit this page on GitHub.</a> </p> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js"></script> <script> var config = {} ; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid')); </script> </body> </html>
