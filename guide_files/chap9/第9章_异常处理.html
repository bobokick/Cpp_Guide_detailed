<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul:nth-of-type(1) > li > ul > li > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li:not(:nth-child(1)) > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li > ul > li > a { background-image: none; } .site-nav > ul:not(:nth-of-type(1)) a, .site-nav li.external a { background-image: none; } .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(9) > ul > li:nth-child(1) > a { font-weight: 600; text-decoration: none; } .site-nav > ul.nav-category-list > li > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(9) > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(9) > ul > li:nth-child(1) > button svg { transform: rotate(-90deg); } .site-nav > ul.nav-category-list > li.nav-list-item > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(9) > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(9) > ul.nav-list > li.nav-list-item:nth-child(1) > ul.nav-list { display: block; } </style> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.stemmer.support.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.zh.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.multi.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>异常处理概念详解 | C++语法教程</title> <meta name="generator" content="Jekyll v3.9.3" /> <meta property="og:title" content="异常处理概念详解" /> <meta name="author" content="BBK" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="异常处理是在程序开发时非常重要的一部分。" /> <meta property="og:description" content="异常处理是在程序开发时非常重要的一部分。" /> <link rel="canonical" href="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html" /> <meta property="og:url" content="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html" /> <meta property="og:site_name" content="C++语法教程" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2025-02-11T03:16:47+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="异常处理概念详解" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BBK"},"dateModified":"2025-02-11T03:16:47+00:00","datePublished":"2025-02-11T03:16:47+00:00","description":"异常处理是在程序开发时非常重要的一部分。","headline":"异常处理概念详解","mainEntityOfPage":{"@type":"WebPage","@id":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html"},"url":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/Cpp_Guide_detailed/" class="site-title lh-tight"> C++语法教程 </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第一章 c++入门介绍 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap1/index.html" class="nav-list-link">第一章 c++入门介绍</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html" class="nav-list-link">预处理指令概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第二章 基本类型与变量 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap2/index.html" class="nav-list-link">第二章 基本类型与变量</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html" class="nav-list-link">类型与变量</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html" class="nav-list-link">复合类型</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html" class="nav-list-link">限定符与说明符</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第三章 表达式 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap3/index.html" class="nav-list-link">第三章 表达式</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" class="nav-list-link">表达式概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第四章 语句 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap4/index.html" class="nav-list-link">第四章 语句</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html" class="nav-list-link">语句概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第五章 函数 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap5/index.html" class="nav-list-link">第五章 函数</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html" class="nav-list-link">函数概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第六章 动态内存管理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap6/index.html" class="nav-list-link">第六章 动态内存管理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" class="nav-list-link">动态内存管理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第七章 类 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap7/index.html" class="nav-list-link">第七章 类</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">类概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第八章 重载运算符 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap8/index.html" class="nav-list-link">第八章 重载运算符</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html" class="nav-list-link">重载运算符概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第九章 异常处理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap9/index.html" class="nav-list-link">第九章 异常处理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html" class="nav-list-link">异常处理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十章 模板 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap10/index.html" class="nav-list-link">第十章 模板</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html" class="nav-list-link">模板概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十一章 派生类类型 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap11/index.html" class="nav-list-link">第十一章 派生类类型</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">派生类类型概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十二章 命名空间 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap12/index.html" class="nav-list-link">第十二章 命名空间</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html" class="nav-list-link">命名空间概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十三章 分离式编译 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap13/index.html" class="nav-list-link">第十三章 分离式编译</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html" class="nav-list-link">分离式编译概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十四章 固有的不可移植特性 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap14/index.html" class="nav-list-link">第十四章 固有的不可移植特性</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html" class="nav-list-link">固有的不可移植特性概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十五章 标准库 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap15/index.html" class="nav-list-link">第十五章 标准库</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html" class="nav-list-link">标准库详解</a></li></ul></li></ul> </nav> <footer class="site-footer"> <button type="button" id="theme_switch_button" class="site-button btn-reset" theme_id="dark" onclick="switch_theme()">切换到<b id="current_theme_name">明亮</b>主题 </button> <script src=/Cpp_Guide_detailed/assets/js/cookie_manager.js></script> <script src=/Cpp_Guide_detailed/assets/js/theme_switch.js></script> </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search C++语法教程" aria-label="Search C++语法教程" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://github.com/bobokick/Cpp_Guide_detailed" class="site-button" > Cpp_Guide_detailed on GitHub </a> </li> </ul> </nav> </div> <div class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap9/index.html">第九章 异常处理</a></li> <li class="breadcrumb-nav-list-item"><span>异常处理概念详解</span></li> </ol> </nav> <div id="main-content" class="main-content"> <main> <div> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"><a href="#91-异常处理的概念">9.1 异常处理的概念</a></li> <li class="toc-entry toc-h2"><a href="#92-异常处理的流程">9.2 异常处理的流程</a></li> <li class="toc-entry toc-h2"><a href="#93-异常检测部分">9.3 异常检测部分</a> <ul> <li class="toc-entry toc-h3"><a href="#931-throw表达式">9.31 throw表达式</a></li> <li class="toc-entry toc-h3"><a href="#932-异常对象">9.32 异常对象</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#94-异常处理部分">9.4 异常处理部分</a> <ul> <li class="toc-entry toc-h3"><a href="#941-try语句块">9.41 try语句块</a> <ul> <li class="toc-entry toc-h4"><a href="#9411-函数try语句块">9.411 函数try语句块</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#942-catch子句">9.42 catch子句</a> <ul> <li class="toc-entry toc-h4"><a href="#9421-catch子句的匹配过程">9.421 catch子句的匹配过程</a></li> <li class="toc-entry toc-h4"><a href="#9422-捕获所有异常">9.422 捕获所有异常</a></li> <li class="toc-entry toc-h4"><a href="#9423-重新抛出">9.423 重新抛出</a></li> </ul> </li> </ul> </li> <li class="toc-entry toc-h2"><a href="#95-异常说明">9.5 异常说明</a> <ul> <li class="toc-entry toc-h3"><a href="#951-异常说明的形式">9.51 异常说明的形式</a></li> <li class="toc-entry toc-h3"><a href="#952-异常说明的作用">9.52 异常说明的作用</a></li> <li class="toc-entry toc-h3"><a href="#953-noexcept说明符的规定">9.53 noexcept说明符的规定</a></li> <li class="toc-entry toc-h3"><a href="#954-noexcept运算符">9.54 noexcept运算符</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#96-异常类">9.6 异常类</a></li> </ul> </div> <div id="markdown-content"> <p>异常处理是在程序开发时非常重要的一部分。</p> <p>异常处理（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。</p> <p>异常使得我们能够将问题的检测与解决过程分离开来。 程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。 检测环节无须知道问题处理模块的所有细节，反之亦然。</p> <h2 id="91-异常处理的概念"> <a href="#91-异常处理的概念" class="anchor-heading" aria-labelledby="91-异常处理的概念"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1 异常处理的概念 </h2> <p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。</p> <p>典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一部分。 当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。</p> <p>异常处理机制分为两部分：</p> <ul> <li>异常检测</li> <li>异常处理</li> </ul> <p><strong>异常检测</strong></p> <p>该部分应该发出某种信号以表明程序遇到了故障，无法继续下去了，而且信号的发出方无须知道故障将在何处得到解决。一旦发出异常信号，检测出问题的部分也就完成了任务。</p> <p>在C++语言中，异常检测部分是通过<code class="language-plaintext highlighter-rouge">throw</code>表达式(throw expression)来进行的。</p> <p>使用<code class="language-plaintext highlighter-rouge">throw</code>表达式来表示它遇到了无法处理的问题。所以我们可以说<code class="language-plaintext highlighter-rouge">throw</code>引发(raise)了异常。</p> <p><strong>异常处理</strong></p> <p>如果程序中含有可能引发异常的代码，那么通常也会有异常处理代码来处理这些问题。例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据；如果丢失了数据库连接，会发出报警信息。</p> <p>异常处理部分使用<code class="language-plaintext highlighter-rouge">try</code>语句块以及<code class="language-plaintext highlighter-rouge">catch</code>子句来处理异常。 <code class="language-plaintext highlighter-rouge">try</code>语句块以关键字<code class="language-plaintext highlighter-rouge">try</code>开始，并以一个或多个<code class="language-plaintext highlighter-rouge">catch</code>子句(catch clause)结束。<code class="language-plaintext highlighter-rouge">try</code>语句块中代码抛出的异常通常会被某个<code class="language-plaintext highlighter-rouge">catch</code>子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码(exception handler)。</p> <p>C++语言的标准库还定义了一套异常类(exception class)，用于在<code class="language-plaintext highlighter-rouge">throw</code>表达式和相关的<code class="language-plaintext highlighter-rouge">catch</code>子句之间传递异常的某些具体信息。</p> <h2 id="92-异常处理的流程"> <a href="#92-异常处理的流程" class="anchor-heading" aria-labelledby="92-异常处理的流程"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2 异常处理的流程 </h2> <p>程序正常执行时，编译器会按照C++代码所规定的顺序执行其他非<code class="language-plaintext highlighter-rouge">catch</code>子句的语句，但是如果遇到了抛出异常的代码时，编译器就会进入异常处理模式。</p> <p>通常的异常处理过程可以分为以下几个步骤，这个步骤被称为栈展开(stack unwinding)过程：</p> <ol> <li>当一个<code class="language-plaintext highlighter-rouge">throw</code>表达式被执行时(包括调用函数的该函数中的或者创建类对象时隐式调用的构造函数中的)，该表达式就会抛出异常，然后编译器检查包含这个<code class="language-plaintext highlighter-rouge">throw</code>表达式的作用域是否为<code class="language-plaintext highlighter-rouge">try</code>语句块： 如果该作用域不为<code class="language-plaintext highlighter-rouge">try</code>语句块，则转到第2步，否则转到第3步。</li> <li>检查包含该作用域(或者语句块)的作用域是否为<code class="language-plaintext highlighter-rouge">try</code>语句块，不是则继续向外层找，以此类推： 如果没有找到任何<code class="language-plaintext highlighter-rouge">try</code>语句块，则编译器调用标准库函数<code class="language-plaintext highlighter-rouge">terminate</code>，<code class="language-plaintext highlighter-rouge">terminate</code>负责终止程序的执行； 如果找到了<code class="language-plaintext highlighter-rouge">try</code>语句块，则转到第3步。</li> <li>检査与该<code class="language-plaintext highlighter-rouge">try</code>语句块关联的<code class="language-plaintext highlighter-rouge">catch</code>子句是否有与其抛出异常匹配的子句： 如果找到了匹配的<code class="language-plaintext highlighter-rouge">catch</code>子句，就使用该子句处理异常，当该<code class="language-plaintext highlighter-rouge">catch</code>子句处理完毕后，有两种情况： <ol> <li>如果该<code class="language-plaintext highlighter-rouge">catch</code>子句关联的是构造函数<code class="language-plaintext highlighter-rouge">try</code>语句块或者析构函数<code class="language-plaintext highlighter-rouge">try</code>语句块，则编译器会在调用该构造或析构函数的位置重新抛出该异常并回到第2步进行操作。</li> <li>否则，程序跳转到关联该<code class="language-plaintext highlighter-rouge">catch</code>子句的<code class="language-plaintext highlighter-rouge">try</code>语句块的最后一个<code class="language-plaintext highlighter-rouge">catch</code>子句之后的位置继续正常执行。 如果没有找到匹配的子句，则回到第2步。</li> </ol> </li> </ol> <blockquote> <p>如果一个异常没有被捕获，则它将调用标准库函数<code class="language-plaintext highlighter-rouge">terminate</code>来终止当前的程序。</p> </blockquote> <p>在栈展开过程中，每次编译器跳转到外层作用域进行查找时，就和函数调用完毕一样，之前内层的作用域的所有非静态局部变量都会自动执行销毁。</p> <p>不管是构造函数发生异常还是其他情况的异常，编译器都将确保在这个块中创建的非静态对象能被正确地销毁： 如果某个局部对象的类型是类类型，则该对象的析构函数将被自动调用；与往常一样，编译器在销毁内置类型的对象时不需要做任何事情。</p> <blockquote> <p>因为编译器是通过调用析构函数来销毁对应类型的对象的，所以如果析构函数本身抛出了异常，且该异常也没有被处理，则程序将被异常终止。</p> </blockquote> <h2 id="93-异常检测部分"> <a href="#93-异常检测部分" class="anchor-heading" aria-labelledby="93-异常检测部分"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.3 异常检测部分 </h2> <h3 id="931-throw表达式"> <a href="#931-throw表达式" class="anchor-heading" aria-labelledby="931-throw表达式"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.31 throw表达式 </h3> <p>在C++语言中，我们通过抛出（throwing）一条表达式来引发（raised）一个异常。</p> <p><code class="language-plaintext highlighter-rouge">throw</code>表达式包含关键字<code class="language-plaintext highlighter-rouge">throw</code>和紧随其后的一个表达式，其中紧随其后的表达式的类型就是抛出的异常类型，该表达式的结果也就叫做异常对象。 <code class="language-plaintext highlighter-rouge">throw</code>表达式后面通常紧跟一个分号，从而构成一条表达式语句。</p> <p><code class="language-plaintext highlighter-rouge">throw</code>表达式的形式为：</p> <blockquote> <p>throw 表达式</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">throw</span> <span class="mf">3.6</span> <span class="o">+</span> <span class="mi">15</span><span class="p">;</span>
</code></pre></div></div> <blockquote> <p>根据异常处理的流程，当执行一个<code class="language-plaintext highlighter-rouge">throw</code>表达式时，同作用域的跟在<code class="language-plaintext highlighter-rouge">throw</code>后面的语句将不再被执行。</p> </blockquote> <h3 id="932-异常对象"> <a href="#932-异常对象" class="anchor-heading" aria-labelledby="932-异常对象"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.32 异常对象 </h3> <p>异常对象（exception object）是一种特殊的对象，该对象由<code class="language-plaintext highlighter-rouge">throw</code>表达式來创建并初始化的，<code class="language-plaintext highlighter-rouge">throw</code>表达式后面紧跟的表达式结果也就是异常对象。</p> <p><code class="language-plaintext highlighter-rouge">throw</code>表达式的异常对象表达了所抛出的异常信息，随后异常处理部分的<code class="language-plaintext highlighter-rouge">catch</code>子句会根据该异常对象的类型进行匹配并处理该异常。</p> <p>异常对象位于由编译器管理的特殊空间中，编译器确保无论最终调用的是哪个<code class="language-plaintext highlighter-rouge">catch</code>子句，都能访问到该空间中的异常对象。当异常处理完毕后，异常对象就会被销毁。</p> <blockquote> <p>异常对象可以为空，也就是<code class="language-plaintext highlighter-rouge">throw</code>后面直接跟<code class="language-plaintext highlighter-rouge">;</code>，此时由于异常对象为空，没有任何<code class="language-plaintext highlighter-rouge">catch</code>子句能够匹配到，所以编译器会执行标准库函数<code class="language-plaintext highlighter-rouge">terminate</code>来终止程序。</p> </blockquote> <p><strong>异常对象的形式</strong></p> <p><code class="language-plaintext highlighter-rouge">throw</code>表达式后面紧跟的表达式的静态类型决定了异常对象的类型；且<code class="language-plaintext highlighter-rouge">throw</code>表达式是用该表达式的结果值对异常对象进行拷贝初始化。</p> <p>对于表达式的静态类型是数组类型或函数类型来说，异常对象的类型则是与之对应的指针类型，且表达式的结果值也转换成了与之对应的指针类型。</p> <p>因为表达式的静态类型决定了异常对象的类型，所以如果一条<code class="language-plaintext highlighter-rouge">throw</code>表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出。</p> <p>对于异常对象的类型，有以下几种规定：</p> <ul> <li>必须是完全类型。</li> <li>如果是类类型的话，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。</li> </ul> <h2 id="94-异常处理部分"> <a href="#94-异常处理部分" class="anchor-heading" aria-labelledby="94-异常处理部分"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.4 异常处理部分 </h2> <p>当<code class="language-plaintext highlighter-rouge">throw</code>表达式抛出了异常后，被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码（handler）将被用来处理该异常。</p> <p>被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内容，程序的异常抛出部分将会告知异常处理部分到底发生了什么错误。</p> <p>异常处理部分使用<code class="language-plaintext highlighter-rouge">try</code>语句块以及<code class="language-plaintext highlighter-rouge">catch</code>子句来处理异常。</p> <h3 id="941-try语句块"> <a href="#941-try语句块" class="anchor-heading" aria-labelledby="941-try语句块"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.41 try语句块 </h3> <p><code class="language-plaintext highlighter-rouge">try</code>语句块的通用语法形式是：</p> <blockquote> <p>try 复合语句 catch 复合语句···</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">try</code>语句块的一开始是关键字<code class="language-plaintext highlighter-rouge">try</code>，随后紧跟着一个复合语句。 <code class="language-plaintext highlighter-rouge">try</code>语句块后面必须跟一个或多个<code class="language-plaintext highlighter-rouge">catch</code>子句，这些<code class="language-plaintext highlighter-rouge">catch</code>子句也就是与之关联的子句。</p> <p><code class="language-plaintext highlighter-rouge">try</code>语句块中的复合语句是一个局部作用域，可以包含任意能在复合语句中使用的代码。</p> <h4 id="9411-函数try语句块"> <a href="#9411-函数try语句块" class="anchor-heading" aria-labelledby="9411-函数try语句块"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.411 函数try语句块 </h4> <p>通常情况下，程序执行的任何时刻都可能发生异常，特别是异常可能发生在函数执行中。</p> <p>虽然我们可以在函数体中写上<code class="language-plaintext highlighter-rouge">try</code>语句，但是如果我们想对整个函数体进行异常处理时，就行不通了。</p> <p>还有一些特殊函数：</p> <ul> <li>比如构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的<code class="language-plaintext highlighter-rouge">try</code>语句块还未生效，所以构造函数体内的<code class="language-plaintext highlighter-rouge">catch</code>子句无法处理构造函数初始值列表抛出的异常。</li> <li>比如在析构函数体内的<code class="language-plaintext highlighter-rouge">catch</code>子句不能处理隐式析构部分抛出的异常。</li> </ul> <p>所以为了处理函数执行时抛出的异常，我们可以将这些函数写成函数<code class="language-plaintext highlighter-rouge">try</code>语句块(也称为函数测试块，function try block)的形式。</p> <p>函数<code class="language-plaintext highlighter-rouge">try</code>语句块的定义形式为：</p> <ul> <li> <blockquote> <p>对于构造函数来说：</p> <p>(可选 类型限定符) 类名 形参表 (可选 类型限定符) try 初始值列表 函数体 catch子句</p> </blockquote> </li> <li> <blockquote> <p>对于析构函数来说：</p> <p>(可选 类型限定符) ~类名 () (可选 类型限定符) try 函数体 catch子句</p> </blockquote> </li> <li> <blockquote> <p>对于其他函数来说：</p> <p>(可选 类型限定符) 返回类型 函数名 形参表 (可选 类型限定符) try 函数体 catch子句 (可选 类型限定符) auto 函数名 形参表 (可选 类型限定符) -&gt; 返回类型 try 函数体 catch子句</p> </blockquote> </li> </ul> <p>所以函数<code class="language-plaintext highlighter-rouge">try</code>语句块中的<code class="language-plaintext highlighter-rouge">try</code>部分没有复合语句块。 而且函数<code class="language-plaintext highlighter-rouge">try</code>语句块只能出现在函数定义中，不能在函数声明时出现。</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">constexpr</code>构造函数不能使用函数<code class="language-plaintext highlighter-rouge">try</code>语句块。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="n">Cls</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
    <span class="c1">// 静态成员函数try语句块</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">prints</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="k">try</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cls</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="kt">int</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="s">" error</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 成员函数try语句块</span>
    <span class="k">auto</span> <span class="n">ret</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="k">try</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="o">*</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="kt">int</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="s">" error</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 析构函数try语句块</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Cls</span><span class="p">()</span> <span class="k">try</span> <span class="p">{}</span> <span class="k">catch</span><span class="p">(</span><span class="kt">int</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="s">" error</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 构造函数try语句块</span>
<span class="kr">inline</span> <span class="n">Cls</span><span class="o">::</span><span class="n">Cls</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="k">try</span><span class="o">:</span> <span class="n">ins</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="p">{}</span> <span class="k">catch</span><span class="p">(</span><span class="kt">int</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="s">" error</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 普通函数try语句块</span>
<span class="kt">void</span> <span class="n">prints2</span><span class="p">()</span> <span class="k">try</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"External</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="kt">int</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="s">" error</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <p>对于函数<code class="language-plaintext highlighter-rouge">try</code>语句块来说，其关联的<code class="language-plaintext highlighter-rouge">catch</code>子句既能处理构造函数体(或者析构函数体和普通函数体)，也能处理构造函数的初始化部分(或析构函数的析构部分)。</p> <blockquote> <p>对于成员函数<code class="language-plaintext highlighter-rouge">try</code>语句块(包括构造和析构函数)来说，其关联的<code class="language-plaintext highlighter-rouge">catch</code>子句能像该成员函数本身一样对该类其他成员有着一些访问权限；且该<code class="language-plaintext highlighter-rouge">catch</code>子句还能使用这些函数的形参(但不能用函数体定义的局部变量)，所以<code class="language-plaintext highlighter-rouge">catch</code>子句的异常声明不能与这些形参同名。</p> </blockquote> <p>对于构造和析构函数<code class="language-plaintext highlighter-rouge">try</code>语句块来说，当这些函数<code class="language-plaintext highlighter-rouge">try</code>语句块关联的<code class="language-plaintext highlighter-rouge">catch</code>子句处理完异常后，编译器还会在这些函数的调用位置重新抛出该异常并继续执行异常处理。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span><span class="p">;</span>
    <span class="n">Cls</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="k">try</span><span class="o">:</span> <span class="n">ins</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="p">{</span> <span class="k">throw</span> <span class="mi">56</span><span class="p">;</span> <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="kt">int</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="s">" error</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="k">try</span> <span class="p">{</span> <span class="k">throw</span> <span class="s">"prints"</span><span class="p">;</span> <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">" error</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="cm">/* 输出
prints error 
56 error     
capture again*/</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">prints</span><span class="p">();</span>
    <span class="n">Cls</span> <span class="n">ob</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="kt">int</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"capture again</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <p>不管某函数是不是函数<code class="language-plaintext highlighter-rouge">try</code>语句块形式，该函数的所有形参的初始化都不属于函数<code class="language-plaintext highlighter-rouge">try</code>语句块的一部分，在形参的初始化过程中发生的异常是属于调用表达式的。 所以在函数形参初始化过程中发生的异常只能在其调用表达式的上下文中处理了。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Ex</span>
<span class="p">{</span> <span class="n">Ex</span><span class="p">()</span> <span class="p">{</span> <span class="k">throw</span> <span class="s">"Ex"</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">Cls</span>
<span class="p">{</span>
    <span class="n">Ex</span> <span class="n">ins</span><span class="p">;</span>
    <span class="n">Cls</span><span class="p">(</span><span class="n">Ex</span> <span class="n">val</span><span class="p">)</span> <span class="k">try</span><span class="o">:</span> <span class="n">ins</span><span class="p">()</span> <span class="p">{}</span> <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">" error</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 输出Ex capture</span>
<span class="k">try</span> <span class="p">{</span> <span class="n">Cls</span> <span class="n">ob</span><span class="p">({});</span> <span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="s">" capture</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <h3 id="942-catch子句"> <a href="#942-catch子句" class="anchor-heading" aria-labelledby="942-catch子句"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.42 catch子句 </h3> <p><code class="language-plaintext highlighter-rouge">catch</code>子句的形式为：</p> <blockquote> <p>catch (异常声明) 复合语句</p> </blockquote> <p>每个<code class="language-plaintext highlighter-rouge">catch</code>子句只与同作用域下的最近的<code class="language-plaintext highlighter-rouge">try</code>语句块关联。</p> <p><code class="language-plaintext highlighter-rouge">catch</code>子句中的复合语句也是一个局部作用域，可以包含任意能在复合语句中使用的代码。</p> <p>异常声明(exception declaration)类似于<strong>只包含一个形参</strong>的函数形参列表，异常声明不能为空。 像在形参列表中一样，如果<code class="language-plaintext highlighter-rouge">catch</code>无须访问该参数的话，则我们可以在定义中省略该参数名字。</p> <p>该声明参数的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，但不能是右值引用。</p> <p>当进入一个<code class="language-plaintext highlighter-rouge">catch</code>语句后，通过异常对象初始化异常声明中的参数。</p> <p>和函数的参数类似，如果<code class="language-plaintext highlighter-rouge">catch</code>的参数类型是非引用类型，则该参数是异常对象的一个副本，在<code class="language-plaintext highlighter-rouge">catch</code>语句内改变该参数实际上改变的是局部副本而非异常对象本身；相反，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名，此时改变参数也就是改变异常对象。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">ins</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ins</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">throw</span> <span class="s">"Can't divide by zero!"</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mf">35.0</span> <span class="o">/</span> <span class="n">ins</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <blockquote> <p><code class="language-plaintext highlighter-rouge">catch</code>参数和普通函数的形参类似，支持继承的动态绑定。所以，通常情况下，如果<code class="language-plaintext highlighter-rouge">catch</code>接受的异常与某个继承体系有关，则最好将该<code class="language-plaintext highlighter-rouge">catch</code>的参数定义成引用类型。</p> </blockquote> <h4 id="9421-catch子句的匹配过程"> <a href="#9421-catch子句的匹配过程" class="anchor-heading" aria-labelledby="9421-catch子句的匹配过程"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.421 catch子句的匹配过程 </h4> <p><code class="language-plaintext highlighter-rouge">catch</code>子句的匹配过程也就叫做捕获异常过程。 子句的匹配过程是根据抛出的异常对象的类型和<code class="language-plaintext highlighter-rouge">catch</code>子句中的异常声明的类型来匹配的。</p> <p>与实参和形参的匹配规则相比，<code class="language-plaintext highlighter-rouge">catch</code>子句的匹配规则受到更多限制。 此时，绝大多数类型转换都不被允许，除了一些极细小的差別之外，要求异常的类型和<code class="language-plaintext highlighter-rouge">catch</code>声明的类型要基本上精确匹配。</p> <p>以下<code class="language-plaintext highlighter-rouge">catch</code>语句的匹配规则：</p> <ul> <li>要按照<code class="language-plaintext highlighter-rouge">catch</code>语句的出现顺序逐一进行匹配，只要出现一个语句能匹配时，就会匹配成功而忽略之后的<code class="language-plaintext highlighter-rouge">catch</code>语句。</li> <li>只允许以下的类型转换，除此之外的其他所有转换规则(包括算术类型转换和类类型转换在内)都不能使用： <ul> <li>允许非顶层const和顶层const的相互类型转换。</li> <li>允许从非底层const向底层const的类型转换。</li> <li>允许从派生类向基类的类型转换(包括其指针和引用)。</li> <li>允许数组和函数被转换成对应类型的指针。</li> </ul> </li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="c1">// 按照规则，匹配的是catch (int val)，\</span>
    <span class="err">所以输出</span><span class="n">error1</span> <span class="mi">18</span>
    <span class="k">throw</span> <span class="n">ins</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"error1 "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"error2 "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="kt">double</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"error3 "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <h4 id="9422-捕获所有异常"> <a href="#9422-捕获所有异常" class="anchor-heading" aria-labelledby="9422-捕获所有异常"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.422 捕获所有异常 </h4> <p>有时我们希望不论抛出的异常是什么类型，程序都能统一捕获它们。 为了一次性捕获所有异常，我们使用省略号<code class="language-plaintext highlighter-rouge">...</code>作为<code class="language-plaintext highlighter-rouge">catch</code>语句的异常声明，这样的处理代码称为捕获所有异常(catch-all)的处理代码，形如<code class="language-plaintext highlighter-rouge">catch(...)</code>的<code class="language-plaintext highlighter-rouge">catch</code>语句可以与任意类型的异常对象匹配(除了空异常对象，空异常对象不能被任何<code class="language-plaintext highlighter-rouge">catch</code>语句捕获)。</p> <p>形如<code class="language-plaintext highlighter-rouge">catch(...)</code>的<code class="language-plaintext highlighter-rouge">catch</code>语句既能单独关联某个<code class="language-plaintext highlighter-rouge">try</code>语句块，也能与其他几个<code class="language-plaintext highlighter-rouge">catch</code>语句一起关联，但是<code class="language-plaintext highlighter-rouge">catch(...)</code>语句必须要放在这些<code class="language-plaintext highlighter-rouge">catch</code>语句的最后一个，否则编译出错。</p> <blockquote> <p>使用省略号的异常声明中只能有省略号而不能有其他的符号或者标识符，所以对于捕获所有异常的<code class="language-plaintext highlighter-rouge">catch</code>语句来说，我们并不能直接用该异常对象。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 输出error</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="k">throw</span> <span class="n">ins</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(...)</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"error"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <h4 id="9423-重新抛出"> <a href="#9423-重新抛出" class="anchor-heading" aria-labelledby="9423-重新抛出"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.423 重新抛出 </h4> <p>有时，一个单独的<code class="language-plaintext highlighter-rouge">catch</code>语句不能完整地处理某个异常。在执行了某些校正操作之后，当前的<code class="language-plaintext highlighter-rouge">catch</code>语句可能会决定由调用链更上一层的函数接着处理异常。 一条<code class="language-plaintext highlighter-rouge">catch</code>语句通过重新抛出(rethrowing)的操作将异常传递给另外一个<code class="language-plaintext highlighter-rouge">catch</code>语句。</p> <p>重新抛出的操作就是在捕获当前异常对象的<code class="language-plaintext highlighter-rouge">catch</code>子句中写上一个<code class="language-plaintext highlighter-rouge">throw</code>表达式，由该<code class="language-plaintext highlighter-rouge">catch</code>子句再次抛出异常，让外层作用域的<code class="language-plaintext highlighter-rouge">catch</code>子句处理该异常。</p> <blockquote> <p>可以通过多个<code class="language-plaintext highlighter-rouge">catch</code>子句的<code class="language-plaintext highlighter-rouge">throw</code>表达式进行多次重新抛出。</p> </blockquote> <p>关于<code class="language-plaintext highlighter-rouge">catch</code>子句中<code class="language-plaintext highlighter-rouge">throw</code>表达式的形式，和普通的<code class="language-plaintext highlighter-rouge">throw</code>表达式一样，既可以写上异常对象，也可以省略：</p> <ul> <li>如果写上了异常对象，则编译器储存该异常对象的类型和初始值。</li> <li>如果省略，则编译器按照之前的异常对象进行传递。</li> </ul> <blockquote> <p>要注意如果catch的异常声明为引用类型，那么就会绑定到该异常对象上，所以对引用的修改也会影响到异常对象。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 输出error1 18\</span>
    <span class="n">error3</span> <span class="n">str</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
        <span class="k">throw</span> <span class="n">ins</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"error1 "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="k">throw</span> <span class="s">"str"</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span>
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"error2 "</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"error3 "</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <h2 id="95-异常说明"> <a href="#95-异常说明" class="anchor-heading" aria-labelledby="95-异常说明"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.5 异常说明 </h2> <p>对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。 首先，知道函数不会抛出异常有助于简化调用该函数的代码；其次，如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。</p> <h3 id="951-异常说明的形式"> <a href="#951-异常说明的形式" class="anchor-heading" aria-labelledby="951-异常说明的形式"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.51 异常说明的形式 </h3> <p>所以我们可以对函数进行不抛出异常说明来指定某个函数不会抛出异常，这也叫做不抛出说明(nonthrowing specification)。</p> <p>对于不抛出异常说明，有两种：</p> <ul> <li>关键字<code class="language-plaintext highlighter-rouge">throw()</code></li> <li>关键字<code class="language-plaintext highlighter-rouge">noexcept</code></li> </ul> <blockquote> <p>关键字<code class="language-plaintext highlighter-rouge">throw()</code>是c++11之前标准所设计的，而关键字<code class="language-plaintext highlighter-rouge">noexcept</code>是c++11新加的，并对用了关键字<code class="language-plaintext highlighter-rouge">noexcept</code>的函数有特殊优化。</p> </blockquote> <p>这两种说明符的放置位置是相同的，都是紧跟在函数的参数列表后面；如果函数为成员函数，则说明符还要在<code class="language-plaintext highlighter-rouge">const</code>及引用限定符之后，<code class="language-plaintext highlighter-rouge">final</code>、<code class="language-plaintext highlighter-rouge">override</code>或虚函数的<code class="language-plaintext highlighter-rouge">=0</code>之前；如果说明符要用于函数的尾置返回类型形式，则应放在返回类型之前。</p> <p>异常说明符还可以在函数指针的声明和定义中使用，但不能在<code class="language-plaintext highlighter-rouge">typedef</code>或类型别名中使用。</p> <blockquote> <p>对于每一个使用异常说明符的函数來说，异常说明符必须要在该函数的声明或定义中全都出现，否则出错。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用throw()的函数</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">()</span> <span class="k">throw</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">()</span> <span class="k">throw</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Print</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 用noexcept的函数</span>
<span class="k">auto</span> <span class="n">ret</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">15</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <h3 id="952-异常说明的作用"> <a href="#952-异常说明的作用" class="anchor-heading" aria-labelledby="952-异常说明的作用"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.52 异常说明的作用 </h3> <p>编译器并不会在编译时检查异常说明符。</p> <p>实际上，如果一个函数在说明了不抛出异常的同时又含有<code class="language-plaintext highlighter-rouge">throw</code>语句或者调用了可能抛出异常的其他函数，编译器还是会顺利编译通过，并不会因为这种违反异常说明的情况而报错(不排除个別编译器会对这种用法提出警告)。</p> <p>所以对于说明了不抛出异常但同时又可能抛出异常的函数来说，程序就会在调用该函数时调用<code class="language-plaintext highlighter-rouge">terminate</code>函数来终止程序，以确保遵守不在运行时抛出异常的承诺(但对于所有的函数<code class="language-plaintext highlighter-rouge">try</code>语句块不生效，也就是说函数<code class="language-plaintext highlighter-rouge">try</code>语句块有无异常说明符都是一样的异常处理流程)。</p> <p>异常说明符<code class="language-plaintext highlighter-rouge">noexcept</code>还接受一个可选的实参(有且仅有一个实参)，该实参的类型必须能转换为<code class="language-plaintext highlighter-rouge">bool</code>类型：如果实参是<code class="language-plaintext highlighter-rouge">true</code>，则函数不会抛出异常；如果实参是<code class="language-plaintext highlighter-rouge">false</code>，则函数可能抛出异常。 以下为含有说明符<code class="language-plaintext highlighter-rouge">noexcept</code>的函数声明，假设函数为<code class="language-plaintext highlighter-rouge">void prints()</code></p><pre><code class="language-C++">// 以下两种函数声明都为可能抛出异常的函数声明
void prints();
void prints() noexcept(false);
// 以下三种函数声明都为不抛出异常的函数声明
void prints() noexcept;
void prints() noexcept(1);
void prints() throw();
</code></pre><h3 id="953-noexcept说明符的规定"> <a href="#953-noexcept说明符的规定" class="anchor-heading" aria-labelledby="953-noexcept说明符的规定"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.53 noexcept说明符的规定 </h3> <p>尽管<code class="language-plaintext highlighter-rouge">noexcept</code>说明符不属于函数类型的一部分，但是其仍然会影响函数的使用。</p> <p>以下是<code class="language-plaintext highlighter-rouge">noexcept</code>说明符函数的几种规定：</p> <ul> <li>声明了不抛出异常的函数指针只能指向不抛出异常的函数，反之则不用。</li> <li>声明了不抛出异常的虚函数，在后续派生类的覆盖中也必须声明不抛出异常，反之则不用。</li> <li>当编译器生成合成拷贝控制成员时，同时也会为其生成一个<code class="language-plaintext highlighter-rouge">noexcept</code>说明符，该说明符的状态是根据该类成员(包括继承的)的异常说明符来决定的： 如果合成的拷贝控制成员将会调用的任意函数都承诺不会抛出异常，则该合成的拷贝控制成员是<code class="language-plaintext highlighter-rouge">noexcept</code>的，反之则是<code class="language-plaintext highlighter-rouge">noexcept(false)</code>。</li> <li>如果我们定义的析构函数中没有提供异常说明符，则编译器将会为其添加一个<code class="language-plaintext highlighter-rouge">noexcept</code>说明符。 和编译器生成合成拷贝控制成员时一样，该说明符的状态是根据该析构函数将会调用的所有函数的异常说明符来决定的。</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Ba</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ins</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">prints2</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ins</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">De</span><span class="o">:</span> <span class="n">Ba</span>
<span class="p">{</span>
    <span class="c1">// 正确覆盖</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{}</span>
    <span class="c1">// 正确覆盖</span>
    <span class="kt">void</span> <span class="n">prints2</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">ret</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">int</span> <span class="n">ret2</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{}</span>

<span class="c1">// 错误：ptr只能指向noexcept函数</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
<span class="c1">// 正确覆盖</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr2</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
</code></pre></div></div> <h3 id="954-noexcept运算符"> <a href="#954-noexcept运算符" class="anchor-heading" aria-labelledby="954-noexcept运算符"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.54 noexcept运算符 </h3> <p><code class="language-plaintext highlighter-rouge">noexcept</code>运算符为一元运算符，运算对象在右侧。</p> <blockquote> <p>运算对象为右值。运算结果为右值。</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">noexcept</code>运算符接受一个或多个非声明或定义的表达式，并返回一个bool类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。</p> <blockquote> <p>所以<code class="language-plaintext highlighter-rouge">noexcept</code>运算符接受的表达式中不能含有类型名。</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">noexcept</code>运算符的使用形式有两种：</p> <ol> <li> <blockquote> <p>noexcept (<em>expr</em>)</p> </blockquote> </li> <li> <blockquote> <p>noexcept (<em>expr1</em>, <em>expr2</em>, <em>expr3</em>, ···)</p> </blockquote> </li> </ol> <p><code class="language-plaintext highlighter-rouge">noexcept</code>运算符会根据表达式结果的异常说明来决定返回<code class="language-plaintext highlighter-rouge">true</code>还是<code class="language-plaintext highlighter-rouge">false</code>： 如果该表达式调用的函数做了不抛出说明或者该表达式不是<code class="language-plaintext highlighter-rouge">throw</code>表达式，则返回<code class="language-plaintext highlighter-rouge">true</code>，否则返回<code class="language-plaintext highlighter-rouge">false</code>。</p> <p>对于第二种形式来说，必须所有的表达式都满足返回<code class="language-plaintext highlighter-rouge">true</code>的条件，运算符才会返回<code class="language-plaintext highlighter-rouge">true</code>，否则返回<code class="language-plaintext highlighter-rouge">false</code>。</p> <p>和<code class="language-plaintext highlighter-rouge">sizeof</code>类似，<code class="language-plaintext highlighter-rouge">noexcept</code>也不用求其运算对象的值而直接得出结果。</p> <blockquote> <p>对于非<code class="language-plaintext highlighter-rouge">throw</code>表达式的表达式的结果不是由函数调用所得时(也就是表达式只是普通的变量，比如一个函数名或者其他对象名)，<code class="language-plaintext highlighter-rouge">noexcept</code>运算符一律当作<code class="language-plaintext highlighter-rouge">true</code></p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">prints</span><span class="p">()</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="n">prints2</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{}</span>
<span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
<span class="c1">// 因为prints2为noexcept函数，所以\</span>
<span class="err">输出</span><span class="mi">1</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">prints2</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="c1">// 因为prints不为noexcept函数，所以\</span>
<span class="err">输出</span><span class="mi">0</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">prints</span><span class="p">(),</span> <span class="n">prints2</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
<span class="c1">// 因为ins只是对象名，所以\</span>
<span class="err">输出</span><span class="mi">1</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">ins</span><span class="p">);</span>
<span class="c1">// 因为prints只是函数名，所以\</span>
<span class="err">输出</span><span class="mi">1</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">prints</span><span class="p">);</span>
</code></pre></div></div> <h2 id="96-异常类"> <a href="#96-异常类" class="anchor-heading" aria-labelledby="96-异常类"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.6 异常类 </h2> <p>C++语言的标准库定义了一组类，用于报告标准库函数遇到的问题。 这些类也叫做异常类(exception class)。</p> <p>这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中：</p> <ul> <li><code class="language-plaintext highlighter-rouge">exception</code>头文件： 定义了最通用的异常类型<code class="language-plaintext highlighter-rouge">exception</code>。 它只报告异常的发生，不提供任何额外信息。</li> <li><code class="language-plaintext highlighter-rouge">stdexcept</code>头文件： 定义了几种常用的异常类型。</li> <li><code class="language-plaintext highlighter-rouge">new</code>头文件： 定义了<code class="language-plaintext highlighter-rouge">bad_alloc</code>异常类型。</li> <li><code class="language-plaintext highlighter-rouge">type_info</code>头文件： 定义了<code class="language-plaintext highlighter-rouge">bad_cast</code>异常类型。</li> </ul> <p>下表为<code class="language-plaintext highlighter-rouge">stdexcept</code>头文件中定义的异常类型： <img src="/Cpp_Guide_detailed/assets/images/2021-06-12-14-42-38.png" alt="stdexcept" /></p> <p>标准库所有的异常类型其实是一个继承体系，下图为该继承体系： <img src="/Cpp_Guide_detailed/assets/images/2021-06-12-14-54-53.png" alt="std_except" /></p> <p>异常类型<code class="language-plaintext highlighter-rouge">exception</code>仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为<code class="language-plaintext highlighter-rouge">what</code>的虚函数。</p> <p>其中<code class="language-plaintext highlighter-rouge">what</code>函数返回一个<code class="language-plaintext highlighter-rouge">const char*</code>，该指针指向一个以<code class="language-plaintext highlighter-rouge">'\0'</code>结尾的字符数组，并且确保不会抛出任何异常。</p> <p>对于为<code class="language-plaintext highlighter-rouge">exception</code>、<code class="language-plaintext highlighter-rouge">bad_alloc</code>、<code class="language-plaintext highlighter-rouge">bad_cast</code>类型的异常对象来说，它们只支持默认初始化，所以不允许为这些对象提供初始值；但对于为其他标准库异常类型的异常对象来说，它们不支持默认初始化，且它们只能用<code class="language-plaintext highlighter-rouge">string</code>对象或者字符串字面值来初始化。</p> <p>继承自异常类型<code class="language-plaintext highlighter-rouge">exception</code>的其他异常类型的<code class="language-plaintext highlighter-rouge">what</code>虚函数负责返回用于初始化对应类型的异常对象信息。因为<code class="language-plaintext highlighter-rouge">what</code>是虚函数，所以当我们捕获基类的引用时，对<code class="language-plaintext highlighter-rouge">what</code>函数的调用将执行与异常对象动态类型对应的版本。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">runtime_error</span><span class="p">(</span><span class="s">"error"</span><span class="p">);</span> <span class="p">}</span>
<span class="c1">// 调用runtime_error类的what函数\</span>
<span class="err">输出</span><span class="n">error</span>
<span class="nf">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">exception</span><span class="o">&amp;</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">err</span><span class="p">.</span><span class="n">what</span><span class="p">();</span> <span class="p">}</span>
</code></pre></div></div> </div> </div> </main> <hr> <footer> <!-- # Footer content # appears at the bottom of every page's main content --> <p class="text-small text-grey-dk-100 mb-0"> Copyright &copy; 2020-2024 bobokick. Distributed by an <a href="https://github.com/bobokick/Cpp_Guide_detailed/blob/master/LICENSE">Apache License 2.0.</a> </p> <div class="d-flex mt-2"> <p class="text-small text-grey-dk-000 mb-0"> <a href="https://github.com/bobokick/Cpp_Guide_detailed/tree/master/docs/my_collections/_guide_files/chap9/第9章_异常处理.md" id="edit-this-page">Edit this page on GitHub.</a> </p> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js"></script> <script> var config = {} ; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid')); </script> </body> </html>
