<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul:nth-of-type(1) > li > ul > li > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li:not(:nth-child(1)) > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li > ul > li > a { background-image: none; } .site-nav > ul:not(:nth-of-type(1)) a, .site-nav li.external a { background-image: none; } .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(12) > ul > li:nth-child(1) > a { font-weight: 600; text-decoration: none; } .site-nav > ul.nav-category-list > li > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(12) > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(12) > ul > li:nth-child(1) > button svg { transform: rotate(-90deg); } .site-nav > ul.nav-category-list > li.nav-list-item > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(12) > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(12) > ul.nav-list > li.nav-list-item:nth-child(1) > ul.nav-list { display: block; } </style> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.stemmer.support.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.zh.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.multi.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>命名空间概念详解 | C++语法教程</title> <meta name="generator" content="Jekyll v3.9.3" /> <meta property="og:title" content="命名空间概念详解" /> <meta name="author" content="BBK" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。 当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染(namespace pollution)。" /> <meta property="og:description" content="大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。 当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染(namespace pollution)。" /> <link rel="canonical" href="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html" /> <meta property="og:url" content="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html" /> <meta property="og:site_name" content="C++语法教程" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2025-02-11T03:16:47+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="命名空间概念详解" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BBK"},"dateModified":"2025-02-11T03:16:47+00:00","datePublished":"2025-02-11T03:16:47+00:00","description":"大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。 当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染(namespace pollution)。","headline":"命名空间概念详解","mainEntityOfPage":{"@type":"WebPage","@id":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html"},"url":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/Cpp_Guide_detailed/" class="site-title lh-tight"> C++语法教程 </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第一章 c++入门介绍 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap1/index.html" class="nav-list-link">第一章 c++入门介绍</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html" class="nav-list-link">预处理指令概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第二章 基本类型与变量 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap2/index.html" class="nav-list-link">第二章 基本类型与变量</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html" class="nav-list-link">类型与变量</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html" class="nav-list-link">复合类型</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html" class="nav-list-link">限定符与说明符</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第三章 表达式 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap3/index.html" class="nav-list-link">第三章 表达式</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" class="nav-list-link">表达式概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第四章 语句 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap4/index.html" class="nav-list-link">第四章 语句</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html" class="nav-list-link">语句概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第五章 函数 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap5/index.html" class="nav-list-link">第五章 函数</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html" class="nav-list-link">函数概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第六章 动态内存管理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap6/index.html" class="nav-list-link">第六章 动态内存管理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" class="nav-list-link">动态内存管理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第七章 类 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap7/index.html" class="nav-list-link">第七章 类</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">类概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第八章 重载运算符 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap8/index.html" class="nav-list-link">第八章 重载运算符</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html" class="nav-list-link">重载运算符概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第九章 异常处理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap9/index.html" class="nav-list-link">第九章 异常处理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html" class="nav-list-link">异常处理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十章 模板 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap10/index.html" class="nav-list-link">第十章 模板</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html" class="nav-list-link">模板概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十一章 派生类类型 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap11/index.html" class="nav-list-link">第十一章 派生类类型</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">派生类类型概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十二章 命名空间 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap12/index.html" class="nav-list-link">第十二章 命名空间</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html" class="nav-list-link">命名空间概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十三章 分离式编译 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap13/index.html" class="nav-list-link">第十三章 分离式编译</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html" class="nav-list-link">分离式编译概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十四章 固有的不可移植特性 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap14/index.html" class="nav-list-link">第十四章 固有的不可移植特性</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html" class="nav-list-link">固有的不可移植特性概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十五章 标准库 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap15/index.html" class="nav-list-link">第十五章 标准库</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html" class="nav-list-link">标准库详解</a></li></ul></li></ul> </nav> <footer class="site-footer"> <button type="button" id="theme_switch_button" class="site-button btn-reset" theme_id="dark" onclick="switch_theme()">切换到<b id="current_theme_name">明亮</b>主题 </button> <script src=/Cpp_Guide_detailed/assets/js/cookie_manager.js></script> <script src=/Cpp_Guide_detailed/assets/js/theme_switch.js></script> </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search C++语法教程" aria-label="Search C++语法教程" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://github.com/bobokick/Cpp_Guide_detailed" class="site-button" > Cpp_Guide_detailed on GitHub </a> </li> </ul> </nav> </div> <div class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap12/index.html">第十二章 命名空间</a></li> <li class="breadcrumb-nav-list-item"><span>命名空间概念详解</span></li> </ol> </nav> <div id="main-content" class="main-content"> <main> <div> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"><a href="#121-命名空间的定义">12.1 命名空间的定义</a> <ul> <li class="toc-entry toc-h3"><a href="#1211-命名空间的定义形式">12.11 命名空间的定义形式</a></li> <li class="toc-entry toc-h3"><a href="#1212-命名空间的不连续性">12.12 命名空间的不连续性</a></li> <li class="toc-entry toc-h3"><a href="#1213-命名空间的成员的定义">12.13 命名空间的成员的定义</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#122-命名空间的分类">12.2 命名空间的分类</a> <ul> <li class="toc-entry toc-h3"><a href="#1221-全局命名空间">12.21 全局命名空间</a></li> <li class="toc-entry toc-h3"><a href="#1222-未命名的命名空间">12.22 未命名的命名空间</a></li> <li class="toc-entry toc-h3"><a href="#1223-内联命名空间">12.23 内联命名空间</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#123-命名空间成员的使用">12.3 命名空间成员的使用</a> <ul> <li class="toc-entry toc-h3"><a href="#1231-命名空间的别名">12.31 命名空间的别名</a></li> <li class="toc-entry toc-h3"><a href="#1232-拓展成员的作用域">12.32 拓展成员的作用域</a> <ul> <li class="toc-entry toc-h4"><a href="#12321-using声明">12.321 using声明</a></li> <li class="toc-entry toc-h4"><a href="#12322-using指示">12.322 using指示</a></li> </ul> </li> </ul> </li> <li class="toc-entry toc-h2"><a href="#124-命名空间与函数匹配">12.4 命名空间与函数匹配</a> <ul> <li class="toc-entry toc-h3"><a href="#1241-命名空间的名字查找">12.41 命名空间的名字查找</a></li> <li class="toc-entry toc-h3"><a href="#1242-函数匹配">12.42 函数匹配</a></li> </ul> </li> </ul> </div> <div id="markdown-content"> <p>大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。 当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染(namespace pollution)。</p> <p>为了防止名字冲突，也为了简化命名操作，C++提供了命名空间(namespace)机制。 命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者(以及用户)可以避免全局名字可能会造成的冲突。</p> <h2 id="121-命名空间的定义"> <a href="#121-命名空间的定义" class="anchor-heading" aria-labelledby="121-命名空间的定义"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.1 命名空间的定义 </h2> <p>一个命名空间的定义包含三部分：首先是关键字<code class="language-plaintext highlighter-rouge">namespace</code>，随后是命名空间的名字；最后在命名空间名字后面是一个复合语句，复合语句中包含一系列的声明和定义。</p> <p>命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是<strong>不能定义在函数或类的内部</strong>。</p> <h3 id="1211-命名空间的定义形式"> <a href="#1211-命名空间的定义形式" class="anchor-heading" aria-labelledby="1211-命名空间的定义形式"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.11 命名空间的定义形式 </h3> <p>定义形式为：</p> <blockquote> <p>(可选 inline) namespace (可选 命名空间名) 复合语句</p> </blockquote> <p>对于命名空间的复合语句来说，只要能出现在全局作用域中的声明或定义，就能置于命名空间的复合语句内，主要包括：类、变量(及其初始化操作)、函数(及其定义)、模板和其他命名空间，这些都可以称为该命名空间的成员。</p> <blockquote> <p>也就是说，命名空间中只能存在各种声明和定义语句，不能存在其他类型的语句。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{};</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ty</span><span class="p">&gt;</span>
    <span class="kr">inline</span> <span class="n">ty</span> <span class="n">prints</span><span class="p">(</span><span class="kt">double</span> <span class="n">val</span> <span class="o">=</span> <span class="n">inst</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="k">return</span> <span class="n">ty</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">namespace</span> <span class="n">nest</span> <span class="p">{</span> <span class="kt">double</span> <span class="n">dou</span> <span class="o">=</span> <span class="mf">7.8</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>命名空间是无法声明的，只能定义。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 错误：不能声明命名空间</span>
<span class="k">namespace</span> <span class="n">ns</span><span class="p">;</span>
<span class="c1">// 正确：定义命名空间</span>
<span class="k">namespace</span> <span class="n">ns</span> <span class="p">{}</span>
</code></pre></div></div> <p>因为每个复合语句就是一个作用域，所以每个命名空间也就是一个作用域。 对于在大多数命名空间作用域之外的实体来说，如果想使用命名空间内的成员，就必须要使用作用域运算符来操作，形式为：</p> <blockquote> <p>命名空间名::成员名</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ins</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 输出365</span>
<span class="n">ns</span><span class="o">::</span><span class="n">ins</span> <span class="o">=</span> <span class="mi">365</span><span class="p">;</span>
<span class="n">ns</span><span class="o">::</span><span class="n">prints</span><span class="p">();</span>
</code></pre></div></div> <h3 id="1212-命名空间的不连续性"> <a href="#1212-命名空间的不连续性" class="anchor-heading" aria-labelledby="1212-命名空间的不连续性"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.12 命名空间的不连续性 </h3> <p>命名空间可以是不连续的，这一点与其他作用域不太一样。 我们每次定义命名空间时，编译器会检查定义位置的作用域中是否存在同名的命名空间： 如果存在，则我们随后声明或定义的成员将会被添加到之前同名的命名空间中；否则就新建一个命名空间来保存成员。 所以不同作用域中的同名命名空间并不是指的是同一个命名空间。</p> <blockquote> <p>命名空间的作用域范围是根据第一次定义的的范围所决定的，之后对该命名空间的添加语句的位置不会影响该命名空间的作用域范围。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">prints2</span><span class="p">();</span>
    <span class="k">namespace</span> <span class="n">ns</span> <span class="p">{</span> <span class="kt">double</span> <span class="n">dou</span> <span class="o">=</span> <span class="mf">6.8</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">namespace</span> <span class="n">ns</span> <span class="p">{</span> <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"external"</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 正确：str为ns的成员</span>
<span class="kt">void</span> <span class="n">ns</span><span class="o">::</span><span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 错误：dou不为外层ns的成员，是为内层的ns成员</span>
<span class="kt">void</span> <span class="n">ns</span><span class="o">::</span><span class="n">prints2</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dou</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <p>因为命名空间的不连续性，我们甚至可以在某个命名空间的作用域外定义或声明该命名空间的成员，只要用作用域运算符显式指明所要被添加成员的命名空间。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ins</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">namespace</span> <span class="n">ns2</span>
    <span class="p">{</span>
        <span class="kt">double</span> <span class="n">dou</span> <span class="o">=</span> <span class="mf">3.45</span><span class="p">;</span>
        <span class="kt">void</span> <span class="n">prints2</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dou</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">namespace</span> <span class="n">ns</span><span class="o">::</span><span class="n">ns2</span>
<span class="p">{</span> <span class="kt">void</span> <span class="n">prints3</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dou</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="c1">// 正确：输出3.45</span>
<span class="n">ns</span><span class="o">::</span><span class="n">ns2</span><span class="o">::</span><span class="n">prints3</span><span class="p">();</span>
</code></pre></div></div> <h3 id="1213-命名空间的成员的定义"> <a href="#1213-命名空间的成员的定义" class="anchor-heading" aria-labelledby="1213-命名空间的成员的定义"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.13 命名空间的成员的定义 </h3> <p>和类类型一样，命名空间的成员也可以在命名空间之外定义，不过也需要在其命名空间内有声明且定义时要用作用域运算符显式指明为命名空间的成员。</p> <p>在命名空间内的所有成员都默认为该命名空间的成员或嵌套在该命名空间的命名空间的成员以及其嵌套命名空间的嵌套命名空间的成员(以此类推，直到最里层的命名空间成员)，所以不能在命名空间内定义非嵌套在该命名空间的其他命名空间的成员，否则出错。 (反过来说，嵌套的命名空间的成员可以定义在其外层命名空间内，包括外层的外层，以此类推，直到最外层的命名空间内)</p> <p>所以，我们不把<code class="language-plaintext highlighter-rouge">#include</code>放在命名空间内部。如果我们这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">();</span>
    <span class="k">namespace</span> <span class="n">ns2</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">prints2</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">ns2</span><span class="o">::</span><span class="n">prints2</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">88</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ns</span><span class="o">::</span><span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ins</span><span class="p">;</span> <span class="p">}</span>

<span class="n">ns</span><span class="o">::</span><span class="n">ins</span> <span class="o">=</span> <span class="mi">365</span><span class="p">;</span>
<span class="c1">// 输出365</span>
<span class="n">ns</span><span class="o">::</span><span class="n">prints</span><span class="p">();</span>
<span class="c1">// 输出88</span>
<span class="n">ns</span><span class="o">::</span><span class="n">ns2</span><span class="o">::</span><span class="n">prints2</span><span class="p">();</span>
</code></pre></div></div> <p><strong>模板特例化必须要在原始模板所属的命名空间中声明，不能在该命名空间之外声明</strong>。 和其他命名空间名字类似，只要我们在命名空间中声明了特例化，就能在该命名空间外部定义它了。</p> <h2 id="122-命名空间的分类"> <a href="#122-命名空间的分类" class="anchor-heading" aria-labelledby="122-命名空间的分类"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.2 命名空间的分类 </h2> <p>根据命名空间的性质，可以将所有的命名空间分为以下几种：</p> <ol> <li>全局命名空间</li> <li>未命名的命名空间</li> <li>内联命名空间</li> </ol> <p>除了全局命名空间以外，其他所有的命名空间都能为未命名或者内联的。</p> <h3 id="1221-全局命名空间"> <a href="#1221-全局命名空间" class="anchor-heading" aria-labelledby="1221-全局命名空间"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.21 全局命名空间 </h3> <p>全局命名空间(global namespace)是隐式定义的命名空间，我们不能定义显式全局命名空间。 全局命名空间在所有程序中都存在。 所有在全局作用域中声明或定义的名字(即在所有类、函数及命名空间之外定义的名字)都是全局命名空间的成员。</p> <p>作用域运算符同样能作用于全局命名空间的成员，因为它是隐式的，所以它并没有名字。 以下表示访问一个全局命名空间中的成员：</p> <blockquote> <p>::成员名</p> </blockquote> <h3 id="1222-未命名的命名空间"> <a href="#1222-未命名的命名空间" class="anchor-heading" aria-labelledby="1222-未命名的命名空间"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.22 未命名的命名空间 </h3> <p>未命名的命名空间(unnamed namespace)是指定义时没有名字的命名空间。</p> <p>未命名的命名空间和普通命名空间一样，可以不连续，但是对于定义在全局作用域中的未命名的命名空间，它的不连续性只能在某个给定的文件内，不能跨越多个文件。</p> <p>所以每个文件定义自己的全局作用域中的未命名的命名空间，如果两个文件都含有全局作用域的未命名的命名空间，则这两个空间互相无关。 这两个未命名的命名空间中可以定义相同名字的实体，并且这些定义表示的是不同实体。 因此<strong>如果一个头文件定义了全局作用域中的未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体</strong>。</p> <blockquote> <p>所以和其他命名空间不同，全局作用域中的未命名的命名空间仅在特定的文件内部有效，其作用范围不会橫跨多个不同的文件，所以可以用全局作用域中的未命名的命名空间来代替每个文件中的静态声明。</p> </blockquote> <p>定义在未命名的命名空间中的名字可以在该命名空间所在的作用域中直接使用，毕竟我们找不到什么命名空间的名字来限定它们；同样的，我们也不能在该命名空间所在的作用域中对其成员使用作用域运算符。</p> <p>未命名的命名空间中的实体名字可以与该命名空间所在的作用域的其他实体名字相同，不会出现重复定义，但是会出现二义性问题，此时可以用作用域运算符来消除二义性(但因为未命名的命名空间不能用作用域运算符，所以也就用不了其同名成员了)。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="k">namespace</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">84</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 错误：二义性</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ins</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 正确：显式调用ns命名空间的成员</span>
    <span class="kt">void</span> <span class="n">prints2</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ns</span><span class="o">::</span><span class="n">ins</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="1223-内联命名空间"> <a href="#1223-内联命名空间" class="anchor-heading" aria-labelledby="1223-内联命名空间"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.23 内联命名空间 </h3> <p>C++11新标准引入了一种新的嵌套命名空间，称为内联命名空间(inline namespace)。 对于每个声明为inline的命名空间，都叫做内联命名空间。</p> <blockquote> <p>内联的未命名的命名空间以未命名的命名空间的规则为主。</p> </blockquote> <p>和普通的嵌套命名空间不同，内联命名空间中的名字可以被其外层的命名空间直接使用。 也就是说，我们无须使用作用域运算符，就可以在其外层命名空间的作用域中直接访问它的成员(当然也可以用作用域运算符访问)。</p> <p>和未命名的命名空间一样，内联命名空间中的名字可以与该命名空间所在的作用域的实体名字相同，不会出现重复定义，但是会出现二义性问题，此时可以用作用域运算符来消除二义性。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">ne</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">84</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 错误：二义性</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ins</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 正确：显式调用ns命名空间的成员</span>
    <span class="kt">void</span> <span class="n">prints2</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ns</span><span class="o">::</span><span class="n">ins</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 正确：显式调用ne命名空间的成员</span>
    <span class="kt">void</span> <span class="n">prints2</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ne</span><span class="o">::</span><span class="n">ins</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>内联命名空间与未命名的命名空间的区别也就是全局作用域中的内联的已命名的命名空间可以在多个文件中不连续，且可以使用作用域运算符访问。</p> </blockquote> <h2 id="123-命名空间成员的使用"> <a href="#123-命名空间成员的使用" class="anchor-heading" aria-labelledby="123-命名空间成员的使用"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.3 命名空间成员的使用 </h2> <p>我们之前介绍过访问命名空间成员的方法是用作用域运算符的方式，但是当命名空间太长时，访问成员就会异常的麻烦，所以为了解决这个问题，我们有两种方法：</p> <ul> <li>定义命名空间的别名</li> <li>拓展成员的作用域 <ul> <li><code class="language-plaintext highlighter-rouge">using</code>声明</li> <li><code class="language-plaintext highlighter-rouge">using</code>指示</li> </ul> </li> </ul> <h3 id="1231-命名空间的别名"> <a href="#1231-命名空间的别名" class="anchor-heading" aria-labelledby="1231-命名空间的别名"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.31 命名空间的别名 </h3> <p>命名空间的别名(namespace alias)使得我们可以为命名空间的名字设定一个短得多的同义词，我们可以像对原命名空间一样对该别名作出任何可以的操作。</p> <blockquote> <p>命名空间的别名只在该别名声明语句所在的作用域中生效。</p> </blockquote> <blockquote> <p>一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价。</p> </blockquote> <blockquote> <p>命名空间别名的声明语句除了不能存在于类内以外，其他的和类型别名一样，可以存在于全局作用域、命名空间和函数内。</p> </blockquote> <p>命名空间的别名声明语句是以关键字<code class="language-plaintext highlighter-rouge">namespace</code>开始，后面是别名所用的名字、赋值号<code class="language-plaintext highlighter-rouge">=</code>、命名空间原来的名字以及一个分号<code class="language-plaintext highlighter-rouge">;</code>。</p> <p>别名声明语句的形式为：</p> <blockquote> <p>namespace 别名 = 命名空间名;</p> </blockquote> <p>声明的别名不能是该语句所在作用域中的其他命名空间名，否则会有重复定义错误。 而且声明后的别名不能用于该命名空间成员的声明或定义，只能用于被调用。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="c1">// 正确，ns命名空间的成员定义</span>
<span class="k">namespace</span> <span class="n">ns</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">55</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 正确，ns命名空间的成员定义</span>
<span class="k">namespace</span> <span class="n">ns</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">dou</span> <span class="o">=</span> <span class="mf">55.5</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 全局作用域中，的命名空间别名nc</span>
<span class="k">namespace</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>

<span class="c1">// 函数内，的命名空间别名fns</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">namespace</span> <span class="n">fns</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fns</span><span class="o">::</span><span class="n">dou</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 命名空间内，的命名空间别名nns</span>
<span class="k">namespace</span> <span class="n">nestn</span>
<span class="p">{</span>
    <span class="k">namespace</span> <span class="n">nns</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
    <span class="n">nns</span><span class="o">::</span><span class="n">ins</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 重复定义错误，别名nc不能用于后续ns命名空间成员的声明或定义</span>
<span class="k">namespace</span> <span class="n">nc</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">dou2</span> <span class="o">=</span> <span class="mf">55.5</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 正确，ns命名空间的成员定义</span>
<span class="k">namespace</span> <span class="n">ns</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">dou3</span> <span class="o">=</span> <span class="mf">55.55</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>但可以与所在作用域的外层作用域的命名空间同名，此时会在该语句所在作用域中隐藏掉外层的同名命名空间。</p> <p>声明语句中的命名空间名可以是嵌套在命名空间中的命名空间，但不能是未命名或者未定义的命名空间。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="k">namespace</span> <span class="n">nest</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ins</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 别名声明语句</span>
<span class="k">namespace</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">ns</span><span class="o">::</span><span class="n">nest</span><span class="p">;</span>
<span class="c1">// 正确：输出35</span>
<span class="n">ns</span><span class="o">::</span><span class="n">nest</span><span class="o">::</span><span class="n">prints</span><span class="p">();</span>
<span class="n">nc</span><span class="o">::</span><span class="n">prints</span><span class="p">();</span>
</code></pre></div></div> <h3 id="1232-拓展成员的作用域"> <a href="#1232-拓展成员的作用域" class="anchor-heading" aria-labelledby="1232-拓展成员的作用域"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.32 拓展成员的作用域 </h3> <p>我们也可以直接拓展某个命名空间的成员作用域来直接访问该空间的某些成员。</p> <p>拓展成员的作用域的方法有两种：</p> <ul> <li><code class="language-plaintext highlighter-rouge">using</code>声明</li> <li><code class="language-plaintext highlighter-rouge">using</code>指示</li> </ul> <blockquote> <p>这两种方法只在该方法语句所在的作用域中生效。</p> </blockquote> <p>不管是哪种方法，在被拓展的作用域内出现的实体都可以直接访问这些被拓展的命名空间成员而不需要用到作用域运算符(当然也可以用)。</p> <blockquote> <p>拓展成员的作用域后，我们还是可以用作用域运算符来访问这些成员，不过要注意： 如果在使用<code class="language-plaintext highlighter-rouge">using</code>指示后还是用作用域运算符来访问这些成员，则该命名空间中不能有与其同名的内嵌命名空间，否则使用作用域运算符访问的就是内嵌命名空间的成员了。</p> </blockquote> <blockquote> <p>这两种方法和类型别名一样，可以存在于全局作用域，命名空间、函数内或者是类内。</p> </blockquote> <h4 id="12321-using声明"> <a href="#12321-using声明" class="anchor-heading" aria-labelledby="12321-using声明"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.321 using声明 </h4> <p><code class="language-plaintext highlighter-rouge">using</code>声明(using declaration)语句一次只能拓展命名空间的一个非命名空间成员。</p> <p>被拓展的成员的==作用域范围是从<code class="language-plaintext highlighter-rouge">using</code>声明语句的出现位置到该语句所在作用域的末尾==。</p> <p><code class="language-plaintext highlighter-rouge">using</code>声明语句为：</p> <blockquote> <p>using 命名空间名::成员名;</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">using</code>声明语句中的命名空间名可以是嵌套的命名空间，但不能是未命名或者未定义的命名空间。</p> <p><code class="language-plaintext highlighter-rouge">using</code>声明语句中的成员名不能为命名空间成员。 而且对于非函数成员名来说，不能与该语句所在作用域中的其他实体同名；对于函数成员名来说，不能与该语句所在作用域中的其他函数定义语句中的函数首部有冲突。否则会有重复定义错误。 但可以与所在作用域的外层作用域的实体同名，此时会在该语句所在作用域中隐藏掉外层的所有同名实体。</p> <blockquote> <p>当<code class="language-plaintext highlighter-rouge">using</code>声明语句中的成员名为重载函数名时，该函数在命名空间的所有版本都会被拓展。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ins</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">namespace</span> <span class="n">ns2</span>
    <span class="p">{</span>
        <span class="kt">double</span> <span class="n">dou</span> <span class="o">=</span> <span class="mf">3.45</span><span class="p">;</span>
        <span class="kt">void</span> <span class="n">prints2</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dou</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 错误：不能直接访问ns中的ns2的成员</span>
<span class="n">prints2</span><span class="p">();</span>
<span class="c1">// using声明语句</span>
<span class="k">using</span> <span class="n">ns</span><span class="o">::</span><span class="n">ns2</span><span class="o">::</span><span class="n">prints2</span><span class="p">;</span>
<span class="c1">// 正确：输出3.45</span>
<span class="n">prints2</span><span class="p">();</span>
</code></pre></div></div> <h4 id="12322-using指示"> <a href="#12322-using指示" class="anchor-heading" aria-labelledby="12322-using指示"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.322 using指示 </h4> <p><code class="language-plaintext highlighter-rouge">using</code>指示(using directive)是另一种拓展成员作用域的方法。 和<code class="language-plaintext highlighter-rouge">using</code>声明不一样的地方是，<code class="language-plaintext highlighter-rouge">using</code>指示会拓展给定命名空间的所有成员的作用域(包括在<code class="language-plaintext highlighter-rouge">using</code>指示语句之后添加进该空间的成员)。</p> <p>所有被拓展的成员的作用域范围==被提升到与包含该命名空间本身和该using指示语句的最近作用域范围一样的范围==。</p> <p><code class="language-plaintext highlighter-rouge">using</code>指示语句的形式为：</p> <blockquote> <p>using namespace 命名空间名;</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">using</code>指示语句中的命名空间名可以是嵌套的命名空间，但不能是未命名或者未定义的命名空间。</p> <p>对于<code class="language-plaintext highlighter-rouge">using</code>指示语句中给定的命名空间中的成员来说：</p> <ul> <li>非函数成员名不能与该语句所在作用域中的其他实体同名，否则在使用该同名时会出现二义性错误。</li> <li>函数成员名不能与该语句所在作用域中的其他函数定义语句中的函数首部有冲突，否则在使用该同名时会出现二义性错误。</li> </ul> <p>但该<code class="language-plaintext highlighter-rouge">using</code>指示语句所提升的作用域中的内层作用域的实体可以与该命名空间的成员同名，此时会在内层作用域中隐藏掉该命名空间的所有同名成员。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">49</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">double</span> <span class="n">dou</span> <span class="o">=</span> <span class="mf">3.45</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">56</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">ns</span> <span class="p">{</span> <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"good"</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// using指示语句</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">ns</span><span class="p">;</span>
    <span class="c1">// 隐藏了ns的dou成员</span>
    <span class="kt">double</span> <span class="n">dou</span> <span class="o">=</span> <span class="mf">94.45</span><span class="p">;</span>
    <span class="c1">// 正确：输出49</span>
    <span class="n">prints</span><span class="p">();</span>
    <span class="c1">// 正确：输出good</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span><span class="p">;</span>
    <span class="c1">// 隐藏了ns的dou成员，所以\</span>
    <span class="err">输出</span><span class="mf">94.45</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dou</span><span class="p">;</span>
    <span class="c1">// 错误：ns中的ins成员与外层成员ins起冲突\</span>
    <span class="err">导致二义性错误</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ins</span><span class="p">;</span>
    <span class="c1">// 正确：显式调用ns中的ins成员\</span>
    <span class="err">输出</span><span class="mi">35</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ns</span><span class="o">::</span><span class="n">ins</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="124-命名空间与函数匹配"> <a href="#124-命名空间与函数匹配" class="anchor-heading" aria-labelledby="124-命名空间与函数匹配"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.4 命名空间与函数匹配 </h2> <h3 id="1241-命名空间的名字查找"> <a href="#1241-命名空间的名字查找" class="anchor-heading" aria-labelledby="1241-命名空间的名字查找"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.41 命名空间的名字查找 </h3> <p>对命名空间内部名字的查找(包括类的成员)遵循常规的查找规则：即由内向外依次査找每个外层作用域。</p> <p>外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过程终止。只有位于使用点之前声明的名字才被考虑。</p> <blockquote> <p>所以如果某命名空间中不含嵌套的同名命名空间，则该命名空间的成员定义可以使用本身自己的命名空间名及作用域运算符来调用本身自己命名空间的成员。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 命名空间ns</span>
<span class="k">namespace</span> <span class="n">ns</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">g_ins</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 命名空间ns</span>
<span class="k">namespace</span> <span class="n">ns</span>
<span class="p">{</span>
    <span class="c1">// 查找到本身ns的g_ins</span>
    <span class="kt">int</span> <span class="n">g_ins2</span> <span class="o">=</span> <span class="n">g_ins</span><span class="p">;</span>
    <span class="c1">// 查找到本身ns的g_ins</span>
    <span class="kt">int</span> <span class="n">g_ins3</span> <span class="o">=</span> <span class="n">ns</span><span class="o">::</span><span class="n">g_ins</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 命名空间ns2</span>
<span class="k">namespace</span> <span class="n">ns2</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">g_dou</span> <span class="o">=</span> <span class="mf">5.5</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 命名空间ns2</span>
<span class="k">namespace</span> <span class="n">ns2</span>
<span class="p">{</span>
    <span class="c1">// 命名空间ns2::ns2</span>
    <span class="k">namespace</span> <span class="n">ns2</span>
    <span class="p">{</span>
        <span class="kt">double</span> <span class="n">g_dou</span> <span class="o">=</span> <span class="mf">7.99</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 查找到本身ns2的g_dou</span>
    <span class="kt">double</span> <span class="n">g_dou3</span> <span class="o">=</span> <span class="n">g_dou</span><span class="p">;</span>
    <span class="c1">// 查找到ns2::ns2的g_dou2</span>
    <span class="kt">double</span> <span class="n">g_dou4</span> <span class="o">=</span> <span class="n">ns2</span><span class="o">::</span><span class="n">g_dou</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="1242-函数匹配"> <a href="#1242-函数匹配" class="anchor-heading" aria-labelledby="1242-函数匹配"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 12.42 函数匹配 </h3> <p>命名空间成员的函数匹配与普通的函数匹配的流程大部分一样，只不过有以下的这些区别：</p> <ol> <li>函数匹配时的名字查找还会在实参类所属的命名空间中进行： 按照调用表达式的实参顺序，在每个实参类(以及实参类的基类)所属的命名空间中进行查找(只会在这个命名空间中查找，<em>不会在该命名空间的外层作用域(包括外层空间)中进行查找</em>)，并将查找到的所有同名函数加入到候选函数集中(即使该函数所属的命名空间在调用点不可见，也会将其加入)。</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span>
<span class="p">{</span>
    <span class="k">namespace</span> <span class="n">nest</span> 
    <span class="p">{</span> 
        <span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{</span> <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Cls"</span><span class="p">;</span> <span class="p">};</span>
        <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">Cls</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">" nest</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span> 
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">nest</span><span class="o">::</span><span class="n">Cls</span> <span class="n">obj</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">" ns</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ns</span><span class="o">::</span><span class="n">nest</span><span class="o">::</span><span class="n">Cls</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">" external</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ns</span><span class="o">::</span><span class="n">nest</span><span class="o">::</span><span class="n">Cls</span> <span class="n">ob</span><span class="p">;</span>
    <span class="c1">// 调用void prints(ns::nest::Cls obj, int)\</span>
    <span class="err">输出</span><span class="n">Cls</span> <span class="n">external</span>
    <span class="n">prints</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="c1">// 调用void ns::nest::prints(ns::nest::Cls obj, double)\</span>
    <span class="err">输出</span><span class="n">Cls</span> <span class="n">nest</span>
    <span class="n">prints</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="mf">5.1</span><span class="p">);</span>
    <span class="c1">// 错误：void ns::prints(ns::nest::Cls obj, string)在调用点不可见</span>
    <span class="n">prints</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="s">"str"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <ol> <li>命名空间中的类的友元声明会被隐式当成该类所属命名空间的成员声明： 命名空间中的类的友元声明不再仅仅只是一个权限说明了，也是一个该类所属命名空间的隐式成员声明。 所以命名空间中的类的友元只能是该命名空间的成员。</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Cls</span>
    <span class="p">{</span>
        <span class="c1">// 友元声明</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">Cls</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">prints2</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// 错误：Cls的友元必须要为ns的成员，该函数不是友元\</span>
<span class="err">所以该函数无法访问</span><span class="n">Cls</span><span class="err">的</span><span class="n">ins</span><span class="err">成员</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="n">ns</span><span class="o">::</span><span class="n">Cls</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">ins</span> <span class="o">&lt;&lt;</span> <span class="s">" Cls</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 正确：为Cls的友元void prints(Cls obj, int val)的定义</span>
<span class="kt">void</span> <span class="n">ns</span><span class="o">::</span><span class="n">prints</span><span class="p">(</span><span class="n">Cls</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">ins</span> <span class="o">&lt;&lt;</span> <span class="s">" Cls2</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ns</span><span class="o">::</span><span class="n">Cls</span> <span class="n">ob</span><span class="p">;</span>
    <span class="c1">// 错误：有多个函数匹配</span>
    <span class="n">prints</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="c1">// 正确：调用Cls类的友元\</span>
    <span class="err">输出</span><span class="mi">3</span> <span class="mi">15</span> <span class="n">Cls2</span>
    <span class="n">ns</span><span class="o">::</span><span class="n">prints</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="c1">// 错误：prints2为ns的成员，所以不可见</span>
    <span class="n">prints2</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>当我们使用了拓展命名空间成员的作用域的方法时，被拓展的函数成员同样遵循普通的函数匹配规则。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" ns</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">string</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" ns</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="kt">double</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" external</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// using声明语句</span>
<span class="k">using</span> <span class="n">ns</span><span class="o">::</span><span class="n">prints</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 调用void ns::prints(std::string val)\</span>
    <span class="err">输出</span><span class="n">str</span> <span class="n">ns</span>
    <span class="n">prints</span><span class="p">(</span><span class="s">"str"</span><span class="p">);</span>
    <span class="c1">// 调用void ns::prints(int val)\</span>
    <span class="err">输出</span><span class="mi">5</span> <span class="n">ns</span>
    <span class="n">prints</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="c1">// 调用void prints(double val)\</span>
    <span class="err">输出</span><span class="mf">3.58</span> <span class="n">external</span>
    <span class="n">prints</span><span class="p">(</span><span class="mf">3.58</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">ns</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="kt">double</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" ns</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">prints</span><span class="p">(</span><span class="n">string</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" ns</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" external</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">prints</span><span class="p">(</span><span class="kt">double</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" external</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// using指示语句</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">ns</span><span class="p">;</span>
    <span class="c1">// 正确：调用void ns::prints(std::string val)\</span>
    <span class="err">输出</span><span class="n">str</span> <span class="n">ns</span>
    <span class="n">prints</span><span class="p">(</span><span class="s">"str"</span><span class="p">);</span>
    <span class="c1">// 正确：调用void ns::prints(int val)\</span>
    <span class="err">输出</span><span class="mi">5</span> <span class="n">ns</span>
    <span class="n">prints</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="c1">// 错误：ns中和全局作用域的void prints(double val)函数都是最佳匹配</span>
    <span class="n">prints</span><span class="p">(</span><span class="mf">3.58</span><span class="p">);</span>
    <span class="c1">// 正确：显式调用void ns::prints(double val)\</span>
    <span class="err">输出</span><span class="mf">3.58</span> <span class="n">ns</span>
    <span class="n">ns</span><span class="o">::</span><span class="n">prints</span><span class="p">(</span><span class="mf">3.58</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> </div> </div> </main> <hr> <footer> <!-- # Footer content # appears at the bottom of every page's main content --> <p class="text-small text-grey-dk-100 mb-0"> Copyright &copy; 2020-2024 bobokick. Distributed by an <a href="https://github.com/bobokick/Cpp_Guide_detailed/blob/master/LICENSE">Apache License 2.0.</a> </p> <div class="d-flex mt-2"> <p class="text-small text-grey-dk-000 mb-0"> <a href="https://github.com/bobokick/Cpp_Guide_detailed/tree/master/docs/my_collections/_guide_files/chap12/第12章_命名空间.md" id="edit-this-page">Edit this page on GitHub.</a> </p> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js"></script> <script> var config = {} ; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid')); </script> </body> </html>
