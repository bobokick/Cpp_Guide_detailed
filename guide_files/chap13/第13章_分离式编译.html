<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul:nth-of-type(1) > li > ul > li > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li:not(:nth-child(1)) > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li > ul > li > a { background-image: none; } .site-nav > ul:not(:nth-of-type(1)) a, .site-nav li.external a { background-image: none; } .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(13) > ul > li:nth-child(1) > a { font-weight: 600; text-decoration: none; } .site-nav > ul.nav-category-list > li > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(13) > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(13) > ul > li:nth-child(1) > button svg { transform: rotate(-90deg); } .site-nav > ul.nav-category-list > li.nav-list-item > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(13) > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(13) > ul.nav-list > li.nav-list-item:nth-child(1) > ul.nav-list { display: block; } </style> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.stemmer.support.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.zh.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.multi.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>分离式编译概念详解 | C++语法教程</title> <meta name="generator" content="Jekyll v3.9.3" /> <meta property="og:title" content="分离式编译概念详解" /> <meta name="author" content="BBK" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="13.1 概念" /> <meta property="og:description" content="13.1 概念" /> <link rel="canonical" href="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html" /> <meta property="og:url" content="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html" /> <meta property="og:site_name" content="C++语法教程" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2025-02-11T03:16:47+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="分离式编译概念详解" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BBK"},"dateModified":"2025-02-11T03:16:47+00:00","datePublished":"2025-02-11T03:16:47+00:00","description":"13.1 概念","headline":"分离式编译概念详解","mainEntityOfPage":{"@type":"WebPage","@id":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html"},"url":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/Cpp_Guide_detailed/" class="site-title lh-tight"> C++语法教程 </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第一章 c++入门介绍 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap1/index.html" class="nav-list-link">第一章 c++入门介绍</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html" class="nav-list-link">预处理指令概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第二章 基本类型与变量 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap2/index.html" class="nav-list-link">第二章 基本类型与变量</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html" class="nav-list-link">类型与变量</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html" class="nav-list-link">复合类型</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html" class="nav-list-link">限定符与说明符</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第三章 表达式 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap3/index.html" class="nav-list-link">第三章 表达式</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" class="nav-list-link">表达式概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第四章 语句 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap4/index.html" class="nav-list-link">第四章 语句</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html" class="nav-list-link">语句概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第五章 函数 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap5/index.html" class="nav-list-link">第五章 函数</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html" class="nav-list-link">函数概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第六章 动态内存管理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap6/index.html" class="nav-list-link">第六章 动态内存管理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" class="nav-list-link">动态内存管理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第七章 类 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap7/index.html" class="nav-list-link">第七章 类</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">类概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第八章 重载运算符 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap8/index.html" class="nav-list-link">第八章 重载运算符</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html" class="nav-list-link">重载运算符概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第九章 异常处理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap9/index.html" class="nav-list-link">第九章 异常处理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html" class="nav-list-link">异常处理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十章 模板 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap10/index.html" class="nav-list-link">第十章 模板</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html" class="nav-list-link">模板概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十一章 派生类类型 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap11/index.html" class="nav-list-link">第十一章 派生类类型</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">派生类类型概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十二章 命名空间 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap12/index.html" class="nav-list-link">第十二章 命名空间</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html" class="nav-list-link">命名空间概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十三章 分离式编译 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap13/index.html" class="nav-list-link">第十三章 分离式编译</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html" class="nav-list-link">分离式编译概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十四章 固有的不可移植特性 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap14/index.html" class="nav-list-link">第十四章 固有的不可移植特性</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html" class="nav-list-link">固有的不可移植特性概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十五章 标准库 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap15/index.html" class="nav-list-link">第十五章 标准库</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html" class="nav-list-link">标准库详解</a></li></ul></li></ul> </nav> <footer class="site-footer"> <button type="button" id="theme_switch_button" class="site-button btn-reset" theme_id="dark" onclick="switch_theme()">切换到<b id="current_theme_name">明亮</b>主题 </button> <script src=/Cpp_Guide_detailed/assets/js/cookie_manager.js></script> <script src=/Cpp_Guide_detailed/assets/js/theme_switch.js></script> </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search C++语法教程" aria-label="Search C++语法教程" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://github.com/bobokick/Cpp_Guide_detailed" class="site-button" > Cpp_Guide_detailed on GitHub </a> </li> </ul> </nav> </div> <div class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap13/index.html">第十三章 分离式编译</a></li> <li class="breadcrumb-nav-list-item"><span>分离式编译概念详解</span></li> </ol> </nav> <div id="main-content" class="main-content"> <main> <div> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h1"><a href="#131-概念">13.1 概念</a></li> <li class="toc-entry toc-h1"><a href="#132-代码的翻译过程">13.2 代码的翻译过程</a> <ul> <li class="toc-entry toc-h2"><a href="#1321-预处理阶段">13.21 预处理阶段</a></li> <li class="toc-entry toc-h2"><a href="#1322-编译阶段">13.22 编译阶段</a></li> <li class="toc-entry toc-h2"><a href="#1323-汇编阶段">13.23 汇编阶段</a></li> <li class="toc-entry toc-h2"><a href="#1324-链接阶段">13.24 链接阶段</a></li> </ul> </li> <li class="toc-entry toc-h1"><a href="#133-代码翻译过程的注意事项">13.3 代码翻译过程的注意事项</a></li> </ul> </div> <div id="markdown-content"> <h1 id="131-概念"> <a href="#131-概念" class="anchor-heading" aria-labelledby="131-概念"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 13.1 概念 </h1> <p>随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同文件中。在一般的程序中，不可能只有单个文件的。 我们在写代码的时候，通常会对各种代码的结构进行组织，从而使之后的调试修改等工作更加方便。</p> <p>C++语言支持所谓的分离式编译（separate compilation）。 分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译，最后再链接到一起。</p> <p>一般来说，我们可以将实体的定义与其声明分离，使它们的定义与其声明分属不同的文件中，从而方便管理组织程序的代码。</p> <h1 id="132-代码的翻译过程"> <a href="#132-代码的翻译过程" class="anchor-heading" aria-labelledby="132-代码的翻译过程"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 13.2 代码的翻译过程 </h1> <p>我们的程序代码通常是由多个代码文件组成的，其中包含头文件和源文件(对于Windows系统来说，C++语言的头文件通常以<code class="language-plaintext highlighter-rouge">.h</code>为后缀，源文件通常以<code class="language-plaintext highlighter-rouge">.cpp</code>为后缀)。 从程序代码到程序运行，我们需要进行程序代码的翻译工作，翻译工作都是由c++的编译器驱动程序进行的，编译器驱动程序会对程序所有的代码进行一些操作，这些操作也就是我们之前所讲的C++代码翻译的四大阶段。</p> <p>我们再回顾以下这四个阶段，其中有需要注意的几个地方：</p> <h2 id="1321-预处理阶段"> <a href="#1321-预处理阶段" class="anchor-heading" aria-labelledby="1321-预处理阶段"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 13.21 预处理阶段 </h2> <ol> <li>在预处理阶段，预处理器会对程序代码中的每个代码文件<code class="language-plaintext highlighter-rouge">.cpp/.h</code>独立地执行其所有的预处理指令，并将其中的每行注释替换成一行空行。每个文件处理完后的所有代码保存在一个预处理文本文件<code class="language-plaintext highlighter-rouge">.i</code>中。 <code class="language-plaintext highlighter-rouge">#include</code>也是预处理指令之一，它的作用就是将指定的文件的所有内容包含在指令出现的位置，该指令会自动展开包含文件的代码到该使用位置，如果该包含文件也有预处理指令，则也执行该指令。 所以为了防止包含文件时出现重复定义，我们需要在被包含文件中使用宏和条件编译(这几个操作的综合也就叫做头文件保护符(header guard))来防止多次包含该文件的内容。</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在windows系统上使用GNU编译器套件进行C++的代码翻译</span>
<span class="c1">// 以下是test.cpp源文件中的代码</span>
<span class="cp">#include "te.h"
#define MA(a,b) a * b;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="n">MA</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="mi">13</span><span class="p">)</span>
    <span class="kt">double</span> <span class="n">dou</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
    <span class="c1">// 这是一行注释，会被替换成一行空行。</span>
    <span class="cm">/* 这是两行注释，会被替换成四行空行。
    这是两行注释，会被替换成四行空行。*/</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// te.h头文件与test.cpp源文件为同一路径。</span>
<span class="c1">// te.h头文件使用了头文件保护符操作。</span>
<span class="c1">// 以下是te.h头文件中的代码</span>
<span class="cp">#ifndef TE_H 
#define TE_H 
</span><span class="k">extern</span> <span class="kt">int</span> <span class="n">ins</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">double</span> <span class="n">dou</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cm">/* 在命令行中的这两个文件所在路径下输入以下命令进行test.cpp文件的预处理操作：
g++ -E test.cpp -o t.i
-o指令是指定生成文件的文件名(可包含路径信息)，
因为GNU预处理指令-E默认在命令行输出预处理文本文件(.i)，
而不保存下来，所以需要显式指定文件名。
预处理后生成的文件为同路径下的t.i
*/</span>
<span class="c1">// 以下都是t.i文件中的代码</span>
<span class="cp"># 1 "test.cpp"
# 1 "&lt;built-in&gt;"
# 1 "&lt;command-line&gt;"
# 1 "test.cpp"
# 1 "te.h" 1
</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ins</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">double</span> <span class="n">dou</span><span class="p">;</span>
<span class="cp"># 2 "test.cpp" 2
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">23</span> <span class="o">*</span> <span class="mi">13</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">dou</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>



    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="1322-编译阶段"> <a href="#1322-编译阶段" class="anchor-heading" aria-labelledby="1322-编译阶段"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 13.22 编译阶段 </h2> <ol> <li>在编译阶段，编译器会独立地检查所有从程序代码转换而成的预处理文本文件<code class="language-plaintext highlighter-rouge">.i</code>，也就是只检查该文件中的代码，而不会考虑其他文件对其的影响。当某个预处理文本文件通过了编译检查时，编译器会将该文件里的所有代码翻译成一种能被汇编语言程序所识别的代码，所有翻译后的代码保存在一个汇编文本文件<code class="language-plaintext highlighter-rouge">.s</code>中。 其中，有以下几点需要注意： <ol> <li>编译器在进行编译检查时，如果我们使用了某个对象(包括普通函数、类的非类类型成员、类的非成员模板成员和模板实例)时，编译器会检查这些对象的声明是否在该作用域中存在： <ul> <li>对于声明存在但定义不存在的对象，编译器会在汇编文本文件<code class="language-plaintext highlighter-rouge">.s</code>中做一个标记，告诉之后的链接器在链接的时候去找该对象的定义，把问题移交给链接器，此时不会触发编译出错。</li> <li>如果该对象的声明不存在，或者声明存在但与其定义不匹配，或者该对象有多个不匹配的声明或定义时，就会编译出错。</li> </ul> </li> <li>但是当我们在不符合不完全类型的使用情形时使用了某类型(包括类类型和类模板)，则编译器不仅会检查其声明，还会检查是否存在对应的定义，否则编译出错。</li> <li>对于模板来说，模板的实例化只会在编译阶段进行，生成的实例(也就是实例定义)包含以下部分： <ul> <li>对于类模板来说： 编译器生成的实例包含该类的定义和其所有成员的声明(不包含其成员的定义)。</li> <li>对于函数模板来说： 编译器生成的实例包含该函数的定义。</li> </ul> </li> <li>编译器实例化模板的时机： <ul> <li>当遇到模板或者模板部分特例化的声明以及定义语句时，编译器不进行实例化。</li> <li>当遇到使用非类模板的模板语句(隐式实例化)，且该语句不是显式实例化定义或者全部特例化时，编译器还是按常规进行声明检查： <ul> <li>如果满足以下任意一项，则编译器不会生成任何实例，否则编译器就会生成对应的实例定义： <ol> <li>该模板只有声明而不存在定义。</li> <li>同作用域中已存在该处所使用的对应的<strong>实例声明</strong>。</li> <li>同作用域中已存在该处所使用的对应的<strong>实例定义</strong>(由其他隐式或显式实例化所产生的)。</li> </ol> </li> </ul> </li> <li>当遇到全部特例化的声明或定义语句时： 如果满足以下任意一项，则会编译出错，否则编译器就会生成对应特殊实例的声明或定义： <ol> <li>原始模板的声明不存在时。</li> <li>该特例化语句是定义语句，且该文件中已存在该特例化对应的<strong>实例定义</strong>(由其他隐式或显式实例化所产生的)。</li> </ol> <p>对于全部特例化声明所生成的特殊实例声明，后续会在链接阶段与该模板的其他同声明的实例定义链接上。</p> </li> <li>当遇到显式实例化的定义语句时： <ul> <li>如果满足以下任意一项，则会编译出错： <ol> <li>同作用域中不存在该模板的定义。</li> <li>同作用域中已存在同与其相同的显式实例化定义。</li> </ol> </li> <li>如果满足以下任意一项，则编译器不会生成对应的实例： <ol> <li>同作用域中已存在该处所使用的对应的<strong>实例定义</strong>(由其他隐式实例化所产生的)。</li> </ol> </li> </ul> <p>否则，编译器就会生成对应的实例定义。</p> </li> </ul> </li> </ol> <p>所以为了生成一个模板的实例，编译器可能既需要模板自身的定义，也需要模板成员的定义。因此与其他对象不同的是，模板通常将其声明和定义放在同一个文件中。</p> </li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在windows系统上使用GNU编译器套件进行C++的代码翻译</span>
<span class="c1">// 以下是test.cpp源文件中的代码</span>
<span class="cp">#include "te.h"
</span><span class="k">extern</span> <span class="k">template</span> <span class="kt">int</span> <span class="nf">t_ret</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">var</span> <span class="o">=</span> <span class="n">ins</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">ret</span><span class="p">();</span>
    <span class="n">ret</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">var3</span> <span class="o">=</span> <span class="n">t_ret</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
    <span class="n">t_ret</span><span class="p">(</span><span class="n">t_ret</span><span class="p">(</span><span class="mi">152</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// te.h头文件与test.cpp源文件为同一路径。</span>
<span class="c1">// te.h头文件使用了头文件保护符操作。</span>
<span class="c1">// 以下是te.h头文件中的代码</span>
<span class="cp">#ifndef TE_H 
#define TE_H 
</span><span class="k">extern</span> <span class="kt">int</span> <span class="n">ins</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">ret</span><span class="p">();</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="n">ty</span> <span class="nf">t_ret</span><span class="p">(</span><span class="n">ty</span> <span class="n">val</span><span class="p">);</span>
<span class="cp">#endif
</span>
<span class="cm">/* 在命令行中的这两个文件所在路径下输入以下命令进行test.cpp文件的预处理以及编译操作：
g++ -S test.cpp
因为GNU预处理加编译的合成操作-S(该操作也可接受预处理文本文件，
从而只对该文件进行编译操作)默认在同路径下创建一个同名的汇编文本文件(.s)，
所以可以不用-o显式指定文件名。

编译成功，在同路径下生成文件test.s
*/</span>
<span class="c1">// 以下都是test.s文件中的代码</span>
	<span class="p">.</span><span class="n">file</span>	<span class="s">"test.cpp"</span>
	<span class="p">.</span><span class="n">text</span>
	<span class="p">.</span><span class="n">def</span>	<span class="n">__main</span><span class="p">;</span>	<span class="p">.</span><span class="n">scl</span>	<span class="mi">2</span><span class="p">;</span>	<span class="p">.</span><span class="n">type</span>	<span class="mi">32</span><span class="p">;</span>	<span class="p">.</span><span class="n">endef</span>
	<span class="p">.</span><span class="n">globl</span>	<span class="n">main</span>
	<span class="p">.</span><span class="n">def</span>	<span class="n">main</span><span class="p">;</span>	<span class="p">.</span><span class="n">scl</span>	<span class="mi">2</span><span class="p">;</span>	<span class="p">.</span><span class="n">type</span>	<span class="mi">32</span><span class="p">;</span>	<span class="p">.</span><span class="n">endef</span>
	<span class="p">.</span><span class="n">seh_proc</span>	<span class="n">main</span>
<span class="n">main</span><span class="o">:</span>
<span class="p">.</span><span class="n">LFB0</span><span class="o">:</span>
	<span class="n">pushq</span>	<span class="o">%</span><span class="n">rbp</span>
	<span class="p">.</span><span class="n">seh_pushreg</span>	<span class="o">%</span><span class="n">rbp</span>
	<span class="n">movq</span>	<span class="o">%</span><span class="n">rsp</span><span class="p">,</span> <span class="o">%</span><span class="n">rbp</span>
	<span class="p">.</span><span class="n">seh_setframe</span>	<span class="o">%</span><span class="n">rbp</span><span class="p">,</span> <span class="mi">0</span>
	<span class="n">subq</span>	<span class="err">$</span><span class="mi">48</span><span class="p">,</span> <span class="o">%</span><span class="n">rsp</span>
	<span class="p">.</span><span class="n">seh_stackalloc</span>	<span class="mi">48</span>
	<span class="p">.</span><span class="n">seh_endprologue</span>
	<span class="n">call</span>	<span class="n">__main</span>
	<span class="n">movq</span>	<span class="p">.</span><span class="n">refptr</span><span class="p">.</span><span class="n">ins</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span> <span class="o">%</span><span class="n">rax</span>
	<span class="n">movl</span>	<span class="p">(</span><span class="o">%</span><span class="n">rax</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
	<span class="n">movl</span>	<span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
	<span class="n">call</span>	<span class="n">_Z3retv</span>
	<span class="n">movl</span>	<span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
	<span class="n">call</span>	<span class="n">_Z3retv</span>
	<span class="n">movl</span>	<span class="err">$</span><span class="mi">15</span><span class="p">,</span> <span class="o">%</span><span class="n">ecx</span>
	<span class="n">call</span>	<span class="n">_Z5t_retIiET_S0_</span>
	<span class="n">movl</span>	<span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
	<span class="n">movl</span>	<span class="err">$</span><span class="mi">152</span><span class="p">,</span> <span class="o">%</span><span class="n">ecx</span>
	<span class="n">call</span>	<span class="n">_Z5t_retIiET_S0_</span>
	<span class="n">movl</span>	<span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">ecx</span>
	<span class="n">call</span>	<span class="n">_Z5t_retIiET_S0_</span>
	<span class="n">movl</span>	<span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
	<span class="n">addq</span>	<span class="err">$</span><span class="mi">48</span><span class="p">,</span> <span class="o">%</span><span class="n">rsp</span>
	<span class="n">popq</span>	<span class="o">%</span><span class="n">rbp</span>
	<span class="n">ret</span>
	<span class="p">.</span><span class="n">seh_endproc</span>
	<span class="p">.</span><span class="n">ident</span>	<span class="s">"GCC: (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0"</span>
	<span class="p">.</span><span class="n">def</span>	<span class="n">_Z3retv</span><span class="p">;</span>	<span class="p">.</span><span class="n">scl</span>	<span class="mi">2</span><span class="p">;</span>	<span class="p">.</span><span class="n">type</span>	<span class="mi">32</span><span class="p">;</span>	<span class="p">.</span><span class="n">endef</span>
	<span class="p">.</span><span class="n">def</span>	<span class="n">_Z5t_retIiET_S0_</span><span class="p">;</span>	<span class="p">.</span><span class="n">scl</span>	<span class="mi">2</span><span class="p">;</span>	<span class="p">.</span><span class="n">type</span>	<span class="mi">32</span><span class="p">;</span>	<span class="p">.</span><span class="n">endef</span>
	<span class="p">.</span><span class="n">section</span>	<span class="p">.</span><span class="n">rdata</span><span class="err">$</span><span class="p">.</span><span class="n">refptr</span><span class="p">.</span><span class="n">ins</span><span class="p">,</span> <span class="s">"dr"</span>
	<span class="p">.</span><span class="n">globl</span>	<span class="p">.</span><span class="n">refptr</span><span class="p">.</span><span class="n">ins</span>
	<span class="p">.</span><span class="n">linkonce</span>	<span class="n">discard</span>
<span class="p">.</span><span class="n">refptr</span><span class="p">.</span><span class="n">ins</span><span class="o">:</span>
	<span class="p">.</span><span class="n">quad</span>	<span class="n">ins</span>

</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在windows系统上使用GNU编译器套件进行C++的代码翻译</span>
<span class="c1">// 以下是test.cpp源文件中的代码</span>
<span class="cp">#include "te.h"
</span><span class="c1">// 函数模板t_ret的显式实例化定义</span>
<span class="c1">// 编译会出错，</span>
<span class="c1">// 因为te.h中的函数模板t_ret只有声明没有定义</span>
<span class="k">template</span> <span class="kt">int</span> <span class="nf">t_ret</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="c1">// 类类型Cls对象的定义</span>
   <span class="c1">// 编译会出错，</span>
   <span class="c1">// 因为te.h中的类类型Cls只有声明没有定义</span>
    <span class="n">Cls</span> <span class="n">obj</span><span class="p">;</span>
   <span class="c1">// 类模板T_cls对象的定义</span>
   <span class="c1">// 编译会出错，</span>
   <span class="c1">// 因为te.h中的类模板T_cls只有声明没有定义</span>
    <span class="n">T_cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">48</span><span class="o">&gt;</span> <span class="n">t_obj</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// te.h头文件与test.cpp源文件为同一路径。</span>
<span class="c1">// te.h头文件使用了头文件保护符操作。</span>
<span class="c1">// 以下是te.h头文件中的代码</span>
<span class="cp">#ifndef TE_H 
#define TE_H 
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="n">ty</span> <span class="nf">t_ret</span><span class="p">(</span><span class="n">ty</span> <span class="n">val</span><span class="p">);</span>
<span class="k">struct</span> <span class="nc">Cls</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">T_cls</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cm">/* 在命令行中的这两个文件所在路径下输入以下命令进行test.cpp文件的预处理以及编译操作：
g++ -S test.cpp
因为GNU预处理加编译的合成操作-S(该操作也可接受预处理文本文件，
从而只对该文件进行编译操作)默认在同路径下创建一个同名的汇编文本文件(.s)，
所以可以不用-o显式指定文件名。

编译失败，没有生成任何文件。
*/</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在windows系统上使用GNU编译器套件进行C++的代码翻译</span>
<span class="c1">// 以下是test.cpp源文件中的代码</span>
<span class="cp">#include "te.h"
</span><span class="c1">// 函数模板t_ret的显式实例化定义</span>
<span class="c1">// 编译会通过，</span>
<span class="c1">// 因为te.h中，函数模板t_ret的全部特例化声明会生成一个对应的实例声明</span>
<span class="k">template</span> <span class="kt">int</span> <span class="nf">t_ret</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="c1">// 类模板T_cls的显式实例化定义</span>
<span class="c1">// 编译会通过，</span>
<span class="c1">// 因为te.h中，类模板T_cls的全部特例化定义会生成一个对应的实例定义，其中包含其成员prints的声明。</span>
<span class="k">template</span> <span class="k">struct</span> <span class="nc">T_cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">48</span><span class="p">&gt;;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">var3</span> <span class="o">=</span> <span class="n">t_ret</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
    <span class="n">t_ret</span><span class="p">(</span><span class="n">t_ret</span><span class="p">(</span><span class="mi">152</span><span class="p">));</span>
   <span class="c1">// 类类型Cls对象的定义</span>
   <span class="c1">// 编译会通过，</span>
   <span class="c1">// 因为te.h中有类类型Cls的定义。</span>
    <span class="n">Cls</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">T_cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">48</span><span class="o">&gt;</span> <span class="n">t_obj</span><span class="p">;</span>
   <span class="c1">// 编译会通过，</span>
   <span class="c1">// 因为te.h中有函数prints的声明。</span>
    <span class="n">t_obj</span><span class="p">.</span><span class="n">prints</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// te.h头文件与test.cpp源文件为同一路径。</span>
<span class="c1">// te.h头文件使用了头文件保护符操作。</span>
<span class="c1">// 以下是te.h头文件中的代码</span>
<span class="cp">#ifndef TE_H
#define TE_H
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="n">ty</span> <span class="nf">t_ret</span><span class="p">(</span><span class="n">ty</span> <span class="n">val</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="kt">int</span> <span class="nf">t_ret</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">T_cls</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">T_cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">48</span><span class="o">&gt;</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">();</span> <span class="p">};</span>
<span class="cp">#endif
</span>
<span class="cm">/* 在命令行中的这两个文件所在路径下输入以下命令进行test.cpp文件的预处理以及编译操作：
g++ -S test.cpp
因为GNU预处理加编译的合成操作-S(该操作也可接受预处理文本文件，
从而只对该文件进行编译操作)默认在同路径下创建一个同名的汇编文本文件(.s)，
所以可以不用-o显式指定文件名。

编译成功，在同路径下生成文件test.s。
*/</span>
</code></pre></div></div> <h2 id="1323-汇编阶段"> <a href="#1323-汇编阶段" class="anchor-heading" aria-labelledby="1323-汇编阶段"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 13.23 汇编阶段 </h2> <ol> <li>在汇编阶段期间，汇编器会独立地将所有从程序代码转换而成的汇编文本文件<code class="language-plaintext highlighter-rouge">.s</code>翻译成机器代码，也叫做机器语言指令(也就是由二进制值组成的代码，计算器能够识别的代码)，并将这些机器语言指令打包成一种叫做可重定位目标程序(relocate object program)的格式，最后将每个文件的打包结果保存在一个为其创建的可重定位目标文件<code class="language-plaintext highlighter-rouge">.o</code>中。</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在windows系统上使用GNU编译器套件进行C++的代码翻译</span>
<span class="c1">// 以下是test.cpp源文件中的代码</span>
<span class="cp">#include "te.h"
</span><span class="k">template</span> <span class="kt">int</span> <span class="nf">t_ret</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">template</span> <span class="k">struct</span> <span class="nc">T_cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">48</span><span class="p">&gt;;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">var3</span> <span class="o">=</span> <span class="n">t_ret</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
    <span class="n">t_ret</span><span class="p">(</span><span class="n">t_ret</span><span class="p">(</span><span class="mi">152</span><span class="p">));</span>
    <span class="n">Cls</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">T_cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">48</span><span class="o">&gt;</span> <span class="n">t_obj</span><span class="p">;</span>
    <span class="n">t_obj</span><span class="p">.</span><span class="n">prints</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// te.h头文件与test.cpp源文件为同一路径。</span>
<span class="c1">// te.h头文件使用了头文件保护符操作。</span>
<span class="c1">// 以下是te.h头文件中的代码</span>
<span class="cp">#ifndef TE_H
#define TE_H
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="n">ty</span> <span class="nf">t_ret</span><span class="p">(</span><span class="n">ty</span> <span class="n">val</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="kt">int</span> <span class="nf">t_ret</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">T_cls</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">T_cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">48</span><span class="o">&gt;</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">();</span> <span class="p">};</span>
<span class="cp">#endif
</span>
<span class="cm">/* 在命令行中的这两个文件所在路径下输入以下命令进行test.cpp文件的预处理、编译以及汇编的合成操作：
g++ -c test.cpp
因为GNU预处理加编译加汇编的合成操作-c(该操作也可接受预处理文本文件或者汇编文本文件，
从而进行对应文件的合成操作)默认在同路径下创建一个同名的目标文件(.o)，
所以可以不用-o显式指定文件名。

汇编成功，在同路径下生成文件test.o。
*/</span>
</code></pre></div></div> <h2 id="1324-链接阶段"> <a href="#1324-链接阶段" class="anchor-heading" aria-labelledby="1324-链接阶段"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 13.24 链接阶段 </h2> <ol> <li>在链接阶段，链接器会把所有从程序代码转换而成的目标文件<code class="language-plaintext highlighter-rouge">.o</code>链接到一起，并进行检查合并： 链接器会将所有文件中的对象的声明和定义链接在一起，如果链接器在链接时发现有对象进行了重复定义，或者是该对象的声明和定义不匹配，又或者是某句使用了未定义的对象(此时，使用了未实例化的实例的地方就会被认为是使用了未定义对象)，则会链接出错。 当所有地方都链接无误后，链接器就会形成一个可执行文件<code class="language-plaintext highlighter-rouge">.exe/.out</code>，此时程序才真正可以在操作系统中运行。</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在windows系统上使用GNU编译器套件进行C++的代码翻译</span>
<span class="c1">// 以下是test.cpp源文件中的代码</span>
<span class="cp">#include "te.h"
</span><span class="k">template</span> <span class="k">struct</span> <span class="nc">T_cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">48</span><span class="p">&gt;;</span>
<span class="k">template</span> <span class="kt">int</span> <span class="nf">t_ret</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">var</span> <span class="o">=</span> <span class="n">ins</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">ret</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">var3</span> <span class="o">=</span> <span class="n">t_ret</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
    <span class="c1">// 输出74 60 169</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">var</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">var2</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">var3</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">Cls</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">T_cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">48</span><span class="o">&gt;</span> <span class="n">t_obj</span><span class="p">;</span>
    <span class="c1">// 输出spec</span>
    <span class="n">t_obj</span><span class="p">.</span><span class="n">prints</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// te.h头文件与test.cpp源文件为同一路径。</span>
<span class="c1">// te.h头文件使用了头文件保护符操作。</span>
<span class="c1">// 以下是te.h头文件中的代码</span>
<span class="cp">#ifndef TE_H 
#define TE_H 
#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ins</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">ret</span><span class="p">();</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="n">ty</span> <span class="nf">t_ret</span><span class="p">(</span><span class="n">ty</span> <span class="n">val</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="kt">int</span> <span class="nf">t_ret</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="k">struct</span> <span class="nc">Cls</span> <span class="p">{};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">T_cls</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">prints</span><span class="p">();</span> <span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="n">T_cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">48</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">();</span>
<span class="cp">#endif
</span>
<span class="c1">// te.cpp源文件与te.h头文件为同一路径。</span>
<span class="c1">// 以下是te.cpp源文件中的代码</span>
<span class="cp">#include "te.h"
</span><span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">74</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">ret</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">60</span><span class="p">;</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">&gt;</span>
<span class="n">ty</span> <span class="nf">t_ret</span><span class="p">(</span><span class="n">ty</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">25</span><span class="p">;</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="kt">int</span> <span class="nf">t_ret</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">154</span><span class="p">;</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">T_cls</span><span class="o">&lt;</span><span class="n">ty</span><span class="p">,</span> <span class="n">val</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"original</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="n">T_cls</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">48</span><span class="o">&gt;::</span><span class="n">prints</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"spec</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>


<span class="cm">/* 在命令行中的这几个文件所在路径下输入以下命令进行test.cpp、te.cpp文件的预处理、编译、汇编以及链接的合成操作：
g++ test.cpp te.cpp
GNU的默认操作就是预处理加编译加汇编加链接的合成操作(该操作也可接受预处理文本文件、汇编文本文件或者目标文件，从而进行对应文件的合成操作)。
GNU的默认操作默认在同路径下创建一个文件名为a的可执行文件(.exe)，所以可以不用-o显式指定文件名。

链接成功，在同路径下生成文件a.exe。
*/</span>
</code></pre></div></div> <h1 id="133-代码翻译过程的注意事项"> <a href="#133-代码翻译过程的注意事项" class="anchor-heading" aria-labelledby="133-代码翻译过程的注意事项"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 13.3 代码翻译过程的注意事项 </h1> <p>综上来说，我们建议：</p> <ul> <li>所有头文件应使用头文件保护符来防止重复定义。</li> <li>各种变量、函数，类的非类类型或者非成员模板成员应该在头文件中独立声明，而它们的定义部分可以放在其它的源文件中，且这些源文件应该把包含其对应声明的头文件包含进来，这样就可以使编译器来验证其定义和声明是否匹配。</li> <li>对于模板来说，要么提前实例化模板的所有所需实例(一般不推荐，因为需要提前实例化多个，很麻烦)，要么就将模板的声明和定义(不包括类模板的非类类型或者非成员模板成员的定义)放在同一个头文件中。</li> <li>当我们的某些文件需要使用这些实体时，只需要用包含预编译指令将包含该实体声明的头文件包含进来就行了，而不需要将这些实体的定义文件包含进来。</li> <li>链接时不要忘记链接这些实体的定义文件。</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 
 * 综合示例
 */</span>

<span class="c1">// 在windows系统上使用GNU编译器套件进行C++的代码翻译</span>
<span class="c1">// 以下是test.cpp源文件中的代码</span>
<span class="cp">#include "test.h"
</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">ret</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"linker"</span><span class="p">);</span> <span class="p">}</span>


<span class="c1">// test.h头文件与test.cpp源文件为同一路径。</span>
<span class="c1">// test.h头文件使用了头文件保护符操作。</span>
<span class="c1">// 以下是test.h头文件中的代码</span>
<span class="cp">#ifndef TEST_H_
#define TEST_H_
#include &lt;string&gt;
</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">ret</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">sprints</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ret</span><span class="p">();</span> <span class="p">}</span>

<span class="cp">#endif
</span>

<span class="c1">// main.cpp源文件与test.h头文件为同一路径。</span>
<span class="c1">// 以下是main.cpp源文件中的代码</span>
<span class="cp">#include &lt;iostream&gt;
#include "test.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sprints</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* 
在命令行中的这几个文件所在路径下输入以下命令进行test.cpp、main.cpp文件的预处理、编译、汇编以及链接的合成操作：
g++ test.cpp main.cpp
此时会链接出错，提示sprints函数重定义。
造成重定义的原因为：
test.cpp和main.cpp在经过预处理阶段后，这两个文件都包含了sprints的定义，
编译时编译器只单独检查每个文件，因此这两个文件都通过了编译，
但在链接阶段，链接器整合这两个文件的所有对象进行链接时就发现了sprints的定义重复的现象，于是报错。
正确做法是将sprints的定义移到test.cpp，test.h只包含sprints的声明，也就是：
// 以下是修改后的test.cpp源文件中的代码
#include "test.h"
std::string ret() { return std::string("linker"); }
std::string sprints() { return ret(); }
// 以下是修改后的test.h头文件中的代码
#ifndef TEST_H_
#define TEST_H_
#include &lt;string&gt;
std::string ret();
std::string sprints();
#endif

这样修改后重新运行以下操作：
g++ test.cpp main.cpp

此时就会链接成功，在同路径下生成文件a.exe。
*/</span>
</code></pre></div></div> </div> </div> </main> <hr> <footer> <!-- # Footer content # appears at the bottom of every page's main content --> <p class="text-small text-grey-dk-100 mb-0"> Copyright &copy; 2020-2024 bobokick. Distributed by an <a href="https://github.com/bobokick/Cpp_Guide_detailed/blob/master/LICENSE">Apache License 2.0.</a> </p> <div class="d-flex mt-2"> <p class="text-small text-grey-dk-000 mb-0"> <a href="https://github.com/bobokick/Cpp_Guide_detailed/tree/master/docs/my_collections/_guide_files/chap13/第13章_分离式编译.md" id="edit-this-page">Edit this page on GitHub.</a> </p> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js"></script> <script> var config = {} ; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid')); </script> </body> </html>
