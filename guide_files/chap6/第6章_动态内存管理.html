<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/Cpp_Guide_detailed/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul:nth-of-type(1) > li > ul > li > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li:not(:nth-child(1)) > a, .site-nav > ul:nth-of-type(1) > li > ul > li > ul > li > ul > li > a { background-image: none; } .site-nav > ul:not(:nth-of-type(1)) a, .site-nav li.external a { background-image: none; } .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(6) > ul > li:nth-child(1) > a { font-weight: 600; text-decoration: none; } .site-nav > ul.nav-category-list > li > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(6) > button svg, .site-nav > ul:nth-of-type(1) > li > ul > li:nth-child(6) > ul > li:nth-child(1) > button svg { transform: rotate(-90deg); } .site-nav > ul.nav-category-list > li.nav-list-item > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(6) > ul.nav-list, .site-nav > ul:nth-of-type(1) > li > ul > li.nav-list-item:nth-child(6) > ul.nav-list > li.nav-list-item:nth-child(1) > ul.nav-list { display: block; } </style> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.stemmer.support.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.zh.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/vendor/lunr.multi.min.js"></script> <script src="/Cpp_Guide_detailed/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>动态内存管理概念详解 | C++语法教程</title> <meta name="generator" content="Jekyll v3.9.3" /> <meta property="og:title" content="动态内存管理概念详解" /> <meta name="author" content="BBK" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="6.1 动态内存管理概念" /> <meta property="og:description" content="6.1 动态内存管理概念" /> <link rel="canonical" href="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" /> <meta property="og:url" content="https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" /> <meta property="og:site_name" content="C++语法教程" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2025-02-11T03:16:47+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="动态内存管理概念详解" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BBK"},"dateModified":"2025-02-11T03:16:47+00:00","datePublished":"2025-02-11T03:16:47+00:00","description":"6.1 动态内存管理概念","headline":"动态内存管理概念详解","mainEntityOfPage":{"@type":"WebPage","@id":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},"url":"https://bobokick.github.io/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/Cpp_Guide_detailed/" class="site-title lh-tight"> C++语法教程 </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第一章 c++入门介绍 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap1/index.html" class="nav-list-link">第一章 c++入门介绍</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap1/%E7%AC%AC1%E7%AB%A0_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html" class="nav-list-link">预处理指令概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第二章 基本类型与变量 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap2/index.html" class="nav-list-link">第二章 基本类型与变量</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F.html" class="nav-list-link">类型与变量</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F2.html" class="nav-list-link">复合类型</a></li><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap2/%E7%AC%AC2%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F3.html" class="nav-list-link">限定符与说明符</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第三章 表达式 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap3/index.html" class="nav-list-link">第三章 表达式</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap3/%E7%AC%AC3%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" class="nav-list-link">表达式概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第四章 语句 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap4/index.html" class="nav-list-link">第四章 语句</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap4/%E7%AC%AC4%E7%AB%A0_%E8%AF%AD%E5%8F%A5.html" class="nav-list-link">语句概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第五章 函数 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap5/index.html" class="nav-list-link">第五章 函数</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap5/%E7%AC%AC5%E7%AB%A0_%E5%87%BD%E6%95%B0.html" class="nav-list-link">函数概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第六章 动态内存管理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap6/index.html" class="nav-list-link">第六章 动态内存管理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap6/%E7%AC%AC6%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" class="nav-list-link">动态内存管理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第七章 类 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap7/index.html" class="nav-list-link">第七章 类</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap7/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">类概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第八章 重载运算符 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap8/index.html" class="nav-list-link">第八章 重载运算符</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap8/%E7%AC%AC8%E7%AB%A0_%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html" class="nav-list-link">重载运算符概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第九章 异常处理 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap9/index.html" class="nav-list-link">第九章 异常处理</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap9/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html" class="nav-list-link">异常处理概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十章 模板 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap10/index.html" class="nav-list-link">第十章 模板</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap10/%E7%AC%AC10%E7%AB%A0_%E6%A8%A1%E6%9D%BF.html" class="nav-list-link">模板概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十一章 派生类类型 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap11/index.html" class="nav-list-link">第十一章 派生类类型</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap11/%E7%AC%AC11%E7%AB%A0_%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%B1%BB%E5%9E%8B.html" class="nav-list-link">派生类类型概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十二章 命名空间 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap12/index.html" class="nav-list-link">第十二章 命名空间</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap12/%E7%AC%AC12%E7%AB%A0_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html" class="nav-list-link">命名空间概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十三章 分离式编译 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap13/index.html" class="nav-list-link">第十三章 分离式编译</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap13/%E7%AC%AC13%E7%AB%A0_%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91.html" class="nav-list-link">分离式编译概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十四章 固有的不可移植特性 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap14/index.html" class="nav-list-link">第十四章 固有的不可移植特性</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap14/%E7%AC%AC14%E7%AB%A0_%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7.html" class="nav-list-link">固有的不可移植特性概念详解</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in 第十五章 标准库 category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/Cpp_Guide_detailed/guide_files/chap15/index.html" class="nav-list-link">第十五章 标准库</a><ul class="nav-list"><li class="nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap15/%E7%AC%AC15%E7%AB%A0_%E6%A0%87%E5%87%86%E5%BA%93.html" class="nav-list-link">标准库详解</a></li></ul></li></ul> </nav> <footer class="site-footer"> <button type="button" id="theme_switch_button" class="site-button btn-reset" theme_id="dark" onclick="switch_theme()">切换到<b id="current_theme_name">明亮</b>主题 </button> <script src=/Cpp_Guide_detailed/assets/js/cookie_manager.js></script> <script src=/Cpp_Guide_detailed/assets/js/theme_switch.js></script> </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search C++语法教程" aria-label="Search C++语法教程" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://github.com/bobokick/Cpp_Guide_detailed" class="site-button" > Cpp_Guide_detailed on GitHub </a> </li> </ul> </nav> </div> <div class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/Cpp_Guide_detailed/guide_files/chap6/index.html">第六章 动态内存管理</a></li> <li class="breadcrumb-nav-list-item"><span>动态内存管理概念详解</span></li> </ol> </nav> <div id="main-content" class="main-content"> <main> <div> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h3"><a href="#61-动态内存管理概念">6.1 动态内存管理概念</a> <ul> <li class="toc-entry toc-h4"><a href="#611-动态内存管理的基本操作">6.11 动态内存管理的基本操作</a></li> <li class="toc-entry toc-h4"><a href="#612-对象的基本操作">6.12 对象的基本操作</a></li> <li class="toc-entry toc-h4"><a href="#613-动态内存管理工作的步骤">6.13 动态内存管理工作的步骤</a></li> <li class="toc-entry toc-h4"><a href="#614-动态内存管理方法分类">6.14 动态内存管理方法分类</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#62-内存与对象操作分离的管理方法">6.2 内存与对象操作分离的管理方法</a> <ul> <li class="toc-entry toc-h4"><a href="#621-malloc等函数">6.21 malloc等函数</a> <ul> <li class="toc-entry toc-h5"><a href="#6211-malloc函数">6.211 malloc函数</a></li> <li class="toc-entry toc-h5"><a href="#6212-calloc函数">6.212 calloc函数</a></li> <li class="toc-entry toc-h5"><a href="#6213-realloc函数">6.213 realloc函数</a></li> <li class="toc-entry toc-h5"><a href="#6213-free函数">6.213 free函数</a></li> <li class="toc-entry toc-h5"><a href="#6214-malloc等函数的使用">6.214 malloc等函数的使用</a></li> </ul> </li> <li class="toc-entry toc-h4"><a href="#622-allocator类">6.22 allocator类</a> <ul> <li class="toc-entry toc-h5"><a href="#6221-allocator类的操作">6.221 allocator类的操作</a></li> <li class="toc-entry toc-h5"><a href="#6222-allocator类的快捷对象构建操作">6.222 allocator类的快捷对象构建操作</a></li> </ul> </li> </ul> </li> <li class="toc-entry toc-h3"><a href="#63-内存与对象操作组合的管理方法">6.3 内存与对象操作组合的管理方法</a> <ul> <li class="toc-entry toc-h4"><a href="#631-new和delete运算符">6.31 new和delete运算符</a> <ul> <li class="toc-entry toc-h5"><a href="#6311-new表达式">6.311 new表达式</a></li> <li class="toc-entry toc-h5"><a href="#6312-delete表达式">6.312 delete表达式</a></li> <li class="toc-entry toc-h5"><a href="#6313-new-表达式">6.313 new[ ]表达式</a></li> <li class="toc-entry toc-h5"><a href="#6314-delete-表达式">6.314 delete[ ]表达式</a></li> <li class="toc-entry toc-h5"><a href="#6315-定位new表达式">6.315 定位new表达式</a> <ul> <li class="toc-entry toc-h6"><a href="#63151-定位new用于阻止内存异常">6.3151 定位new用于阻止内存异常</a></li> <li class="toc-entry toc-h6"><a href="#63152-定位new用于构造对象">6.3152 定位new用于构造对象</a></li> </ul> </li> <li class="toc-entry toc-h5"><a href="#6316-自定义运算符函数">6.316 自定义运算符函数</a> <ul> <li class="toc-entry toc-h6"><a href="#63161-new和delete运算符工作原理">6.3161 new和delete运算符工作原理</a></li> <li class="toc-entry toc-h6"><a href="#63162-自定义new和delete运算符函数">6.3162 自定义new和delete运算符函数。</a></li> </ul> </li> </ul> </li> </ul> </li> <li class="toc-entry toc-h3"><a href="#64-raii思想的管理方法">6.4 RAII思想的管理方法</a> <ul> <li class="toc-entry toc-h4"><a href="#641-智能指针">6.41 智能指针</a> <ul> <li class="toc-entry toc-h5"><a href="#6411-shared_ptr类">6.411 shared_ptr类</a> <ul> <li class="toc-entry toc-h6"><a href="#64111-shared_ptr类的操作">6.4111 shared_ptr类的操作</a></li> <li class="toc-entry toc-h6"><a href="#64112-计数器">6.4112 计数器</a></li> </ul> </li> <li class="toc-entry toc-h5"><a href="#6412-智能指针的清理操作">6.412 智能指针的清理操作</a></li> <li class="toc-entry toc-h5"><a href="#6413-weak_ptr伴随类">6.413 weak_ptr伴随类</a></li> <li class="toc-entry toc-h5"><a href="#6414-unique_ptr类">6.414 unique_ptr类</a> <ul> <li class="toc-entry toc-h6"><a href="#64141-unique_ptr类所支持的操作">6.4141 unique_ptr类所支持的操作</a></li> </ul> </li> <li class="toc-entry toc-h5"><a href="#6415-智能指针的动态数组">6.415 智能指针的动态数组</a></li> </ul> </li> </ul> </li> </ul> </div> <div id="markdown-content"> <h3 id="61-动态内存管理概念"> <a href="#61-动态内存管理概念" class="anchor-heading" aria-labelledby="61-动态内存管理概念"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.1 动态内存管理概念 </h3> <p>之前我们在介绍对象生命周期时谈到过了编译器在分配内存时根据不同策略将系统内存分为三种：</p> <ul> <li>静态存储区(static)</li> <li>动态存储区/栈区(stack)</li> <li>自由空间区(free store)/堆区(heap)</li> </ul> <p>前两个是由编译器自主控制分配和释放的，而最后一个堆区里的对象，是由我们自己的代码来控制其对象的生存期。自由空间区的对象也叫做动态内存对象，所以我们这章所介绍的就是对动态内存的管理。</p> <h4 id="611-动态内存管理的基本操作"> <a href="#611-动态内存管理的基本操作" class="anchor-heading" aria-labelledby="611-动态内存管理的基本操作"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.11 动态内存管理的基本操作 </h4> <p>一般来说，动态内存的管理有两种基本操作：</p> <ul> <li>内存分配</li> <li>内存释放</li> </ul> <p>内存分配就是获取一块原始的，未被使用的动态内存空间。 内存释放就是将这块动态内存的使用权还给系统，表示不需要使用里面的数据了，以供系统作其他用途。</p> <h4 id="612-对象的基本操作"> <a href="#612-对象的基本操作" class="anchor-heading" aria-labelledby="612-对象的基本操作"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.12 对象的基本操作 </h4> <p>而大多数时候，动态内存的操作往往会跟着对象的某种基本操作：</p> <ul> <li>对象创建(构造)</li> <li>对象销毁(析构)</li> </ul> <p>对象创建是指在所给的动态内存中建立一个给定的对象，并对该对象进行初始化。 对象销毁是指释放该动态内存对象所使用的所有资源(也就是对该对象所使用的其他动态内存对象执行对象销毁和内存释放的操作)。</p> <blockquote> <p>对象销毁不等于内存释放，一个动态内存对象的销毁并不会释放该对象本身的内存。 也就是调用某对象的析构函数只会销毁该对象，不会释放该对象的内存。</p> </blockquote> <blockquote> <p>在一个动态内存对象没有被销毁时，最好不要直接释放该对象的内存，因为==释放该对象的内存仅仅是对该对象的内存的释放，而没有释放该对象所使用的其他对象的内存==，导致这些对象的内存无法被释放了。 所以对动态内存对象的管理，应该是先对该对象执行销毁，然后再是释放该对象的内存。</p> </blockquote> <h4 id="613-动态内存管理工作的步骤"> <a href="#613-动态内存管理工作的步骤" class="anchor-heading" aria-labelledby="613-动态内存管理工作的步骤"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.13 动态内存管理工作的步骤 </h4> <p>所以，对于动态内存对象的构建以及用完后的对象清理工作，大多数管理工作是以以下这4个步骤进行的：</p> <ol> <li>内存分配</li> <li>对象构造</li> <li>对象销毁</li> <li>内存释放</li> </ol> <p>任何一个步骤如果有省略或者步骤顺序不对，都有可能会造成动态内存管理操作的失败以及出现未定义行为。</p> <blockquote> <p>在堆区分配的内存是无名的，因此无法为其中创建的对象命名。</p> </blockquote> <h4 id="614-动态内存管理方法分类"> <a href="#614-动态内存管理方法分类" class="anchor-heading" aria-labelledby="614-动态内存管理方法分类"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.14 动态内存管理方法分类 </h4> <p>根据动态内存操作与对象操作的组合，动态内存管理的方法可以分为三种：</p> <ul> <li>内存与对象操作分离 <ul> <li><code class="language-plaintext highlighter-rouge">malloc</code>, <code class="language-plaintext highlighter-rouge">calloc</code>等函数</li> <li><code class="language-plaintext highlighter-rouge">allocator</code>类</li> </ul> </li> <li>内存与对象操作组合 <ul> <li><code class="language-plaintext highlighter-rouge">new</code>, <code class="language-plaintext highlighter-rouge">delete</code>运算符</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">RAII</code> <ul> <li>智能指针 <ul> <li><code class="language-plaintext highlighter-rouge">shared_ptr</code> <ul> <li><code class="language-plaintext highlighter-rouge">weak_ptr</code></li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">unique_ptr</code></li> </ul> </li> </ul> </li> </ul> <ol> <li> <p>内存与对象操作分离的管理方法是指动态内存的分配与释放与对象的创建与销毁是分开的。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</p> </li> <li> <p>内存与对象操作组合的管理方法是指在执行动态内存分配时就自动创建了对象，在执行内存释放时自动先执行了对象销毁。</p> </li> <li> <p>RAII(Resource Acquisition Is Initialization)是指资源获取即初始化，也就是说：在内存分配时就自动创建了对象。但其实这还有一半意思是指：内存释放时执行对象的销毁操作。 所以运用RAII思想的动态内存管理的方法是将内存的操作和对象的操作一起结合起来，该方法创建的对象在创建时自动分配内存，不需要用时自动执行销毁和内存释放操作，而无需手动操作。</p> </li> </ol> <h3 id="62-内存与对象操作分离的管理方法"> <a href="#62-内存与对象操作分离的管理方法" class="anchor-heading" aria-labelledby="62-内存与对象操作分离的管理方法"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.2 内存与对象操作分离的管理方法 </h3> <p>内存与对象操作分离的管理方法是指动态内存的分配与释放与对象的创建与销毁是分开的。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</p> <p>内存与对象操作分离的管理方法可以分为两种，一种是从C语言继承的，第二种是C++标准库的：</p> <ul> <li><code class="language-plaintext highlighter-rouge">malloc</code>, <code class="language-plaintext highlighter-rouge">calloc</code>等函数</li> <li><code class="language-plaintext highlighter-rouge">allocator</code>类</li> </ul> <h4 id="621-malloc等函数"> <a href="#621-malloc等函数" class="anchor-heading" aria-labelledby="621-malloc等函数"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.21 malloc等函数 </h4> <p>接下来介绍的几个函数是从C语言中继承的，它们都定义在<code class="language-plaintext highlighter-rouge">cstdlib</code>头文件中。</p> <p>这几个函数只负责内存的分配与释放，不负责对象的创建与销毁，所以我们必须自己来操作对象的创建与销毁。</p> <h5 id="6211-malloc函数"> <a href="#6211-malloc函数" class="anchor-heading" aria-labelledby="6211-malloc函数"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.211 malloc函数 </h5> <p><code class="language-plaintext highlighter-rouge">malloc</code>函数接受一个表示待分配字节数的<code class="language-plaintext highlighter-rouge">size_t</code>(<code class="language-plaintext highlighter-rouge">unsigned int</code>)，返回一个指向分配空间的第一个字节的地址的空类型指针，如果分配失败(如内存不足)，则返回空指针。</p> <p><code class="language-plaintext highlighter-rouge">malloc</code>函数的函数声明为:</p> <blockquote> <p>void* malloc(size_t size);</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">malloc</code>函数一般配合<code class="language-plaintext highlighter-rouge">sizeof</code>运算符来创建特定类型的某个对象。</p> <h5 id="6212-calloc函数"> <a href="#6212-calloc函数" class="anchor-heading" aria-labelledby="6212-calloc函数"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.212 calloc函数 </h5> <p>和<code class="language-plaintext highlighter-rouge">malloc</code>函数类似，<code class="language-plaintext highlighter-rouge">calloc</code>函数接受一个表示分配内存空间数量<code class="language-plaintext highlighter-rouge">size_t</code>和表示每个内存空间所占的字节数的<code class="language-plaintext highlighter-rouge">size_t</code>，该函数分配的空间的地址是连续的。 返回一个指向分配空间的第一个字节的地址的空类型指针，如果分配失败(如内存不足)，则返回空指针。</p> <p><code class="language-plaintext highlighter-rouge">calloc</code>函数的函数声明为:</p> <blockquote> <p>void* calloc(size_t n, size_t size);</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">calloc</code>函数一般配合<code class="language-plaintext highlighter-rouge">sizeof</code>运算符来创建以特定类型的对象为元素的类数组结构，所以该指针可以像指向容器元素的指针一样进行元素访问的操作。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 分配含有5个int类型字节大小的内存空间</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ptr_arr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="c1">// 对这5个空间进行对象创建</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
    <span class="o">*</span><span class="p">(</span><span class="n">ptr_arr</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="c1">// 输出5 6 7 8 9</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">ptr_arr</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
</code></pre></div></div> <h5 id="6213-realloc函数"> <a href="#6213-realloc函数" class="anchor-heading" aria-labelledby="6213-realloc函数"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.213 realloc函数 </h5> <p><code class="language-plaintext highlighter-rouge">realloc</code>函数接受一个<code class="language-plaintext highlighter-rouge">void*</code>和表示分配字节数的<code class="language-plaintext highlighter-rouge">size_t</code>，该<code class="language-plaintext highlighter-rouge">void*</code>必须是<code class="language-plaintext highlighter-rouge">malloc</code>或者<code class="language-plaintext highlighter-rouge">calloc</code>返回的指针或者其指针的副本，否则会出错，如果是空指针则该函数直接新分配一个给定字节数的内存空间。 <code class="language-plaintext highlighter-rouge">realloc</code>函数将给定指针所指的所有分配内存的大小改为给定的分配字节数，并重新返回给定的指针(指向已修改大小的分配空间的第一个字节的地址的空类型指针)，如果修改失败(如内存不足)，则返回空指针。</p> <blockquote> <p>对<code class="language-plaintext highlighter-rouge">calloc</code>返回的指针使用时，是将<code class="language-plaintext highlighter-rouge">calloc</code>所分配的<code class="language-plaintext highlighter-rouge">n*size</code>大小的空间修改为给定的分配字节数。</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">realloc</code>函数的函数声明为:</p> <blockquote> <p>void* realloc(void* ptr, size_t size);</p> </blockquote> <h5 id="6213-free函数"> <a href="#6213-free函数" class="anchor-heading" aria-labelledby="6213-free函数"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.213 free函数 </h5> <p><code class="language-plaintext highlighter-rouge">free</code>函数接受一个<code class="language-plaintext highlighter-rouge">void*</code>，该空类型指针必须是<code class="language-plaintext highlighter-rouge">malloc</code>或者<code class="language-plaintext highlighter-rouge">calloc</code>返回的指针或者其指针的副本，否则会出错，如果是空指针则该函数不做任何操作。 <code class="language-plaintext highlighter-rouge">free</code>函数将给定指针所指的内存释放。</p> <p><code class="language-plaintext highlighter-rouge">free</code>函数的函数声明为:</p> <blockquote> <p>void free(void* ptr);</p> </blockquote> <h5 id="6214-malloc等函数的使用"> <a href="#6214-malloc等函数的使用" class="anchor-heading" aria-labelledby="6214-malloc等函数的使用"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.214 malloc等函数的使用 </h5> <p>因为这几个函数只负责内存的分配与释放，所以我们要自己对其内存进行对象创建与销毁。</p> <p>因为这几个函数都是返回指针，所以只能通过有关指针的操作来进行动态内存对象的创建：</p> <ol> <li>用对应对象来赋值。 用对应对象来赋值需要该类型的拷贝赋值运算符不能是删除的。</li> <li>调用对应类型的构造函数来赋值(临时对象)。 调用对应类型的构造函数来赋值需要该类型的拷贝或者移动赋值运算符不能是删除的。</li> <li>用定位<code class="language-plaintext highlighter-rouge">new</code>表达式直接在内存中创建对象。 用定位<code class="language-plaintext highlighter-rouge">new</code>表达式直接在内存中创建对象是最好的方法，只要对应类型有构造函数就能创建对象，且该方法对对应类型没有前两个方法所需的限制。</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cm">/* 使用定位new表达式的创建方法：
定义了一个含有
非静态的string类型的数据成员
的类型Te，该类型可以用定位new表达式创建对象
*/</span>
<span class="k">struct</span> <span class="nc">Te</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">string</span> <span class="n">sta_str</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">str</span><span class="p">;</span>
    <span class="n">Te</span><span class="p">(</span><span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span> <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Te_str"</span><span class="p">)</span><span class="o">:</span> <span class="n">ins</span><span class="p">(</span><span class="n">ins</span><span class="p">),</span> <span class="n">str</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> 
    <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"constructed!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Te</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Te</span><span class="o">&amp;</span> <span class="n">cls</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="o">~</span><span class="n">Te</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"deleted!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">string</span> <span class="n">Te</span><span class="o">::</span><span class="n">sta_str</span> <span class="o">=</span> <span class="s">"Te_static_str"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 分配内存</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">vp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Te</span><span class="p">));</span>
    <span class="c1">// 创建对象</span>
    <span class="n">Te</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">vp</span><span class="p">)</span> <span class="n">Te</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="s">"good_created"</span><span class="p">);</span>
    <span class="cm">/* 两个指针保存同一个地址，输出
    constructed!
    good_created good_created
    deleted!
    */</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">Te</span><span class="o">*</span><span class="p">)</span><span class="n">vp</span><span class="p">).</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">tp</span><span class="p">).</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 销毁对象</span>
    <span class="n">tp</span><span class="o">-&gt;~</span><span class="n">Te</span><span class="p">();</span>
    <span class="c1">// 释放内存</span>
    <span class="n">free</span><span class="p">(</span><span class="n">vp</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>要注意用1，2这两个方法时，malloc等函数不能创建含有非静态的类类型数据成员的类型的对象，否则会出错。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cm">/* 使用第二种创建方法：
定义了一个含有
非静态的string类型的数据成员
的类型Te，此时
该类型不能用
malloc等函数创建对象*/</span>
<span class="k">struct</span> <span class="nc">Te</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">str</span><span class="p">;</span>
    <span class="n">Te</span><span class="p">(</span><span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span> <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Te_str"</span><span class="p">)</span><span class="o">:</span> <span class="n">ins</span><span class="p">(</span><span class="n">ins</span><span class="p">),</span> <span class="n">str</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">Te</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Te</span><span class="o">&amp;</span> <span class="n">cls</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">ins</span> <span class="o">=</span> <span class="n">cls</span><span class="p">.</span><span class="n">ins</span><span class="p">;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">=</span> <span class="n">cls</span><span class="p">.</span><span class="n">str</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="n">Te</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Te</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Te</span><span class="p">));</span>
<span class="c1">// 出错！</span>
<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">Te</span><span class="p">();</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">;</span>
<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cm">/* 使用第二种创建方法：
定义了一个类类型Te，
该类型没有
非静态的类类型数据成员。
所以该类型可以用
malloc等函数创建对象。*/</span>
<span class="k">struct</span> <span class="nc">Te</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ins</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">string</span> <span class="n">str</span><span class="p">;</span>
    <span class="n">Te</span><span class="p">(</span><span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">18</span><span class="p">)</span><span class="o">:</span> <span class="n">ins</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">Te</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Te</span><span class="o">&amp;</span> <span class="n">cls</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">ins</span> <span class="o">=</span> <span class="n">cls</span><span class="p">.</span><span class="n">ins</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
<span class="n">string</span> <span class="n">Te</span><span class="o">::</span><span class="n">str</span> <span class="o">=</span> <span class="s">"Te_static_str"</span><span class="p">;</span>

<span class="n">Te</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Te</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Te</span><span class="p">));</span>
<span class="c1">// 正确：用调用对应类型的构造函数来赋值</span>
<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">Te</span><span class="p">();</span>
<span class="c1">// 输出Te_static_str</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">;</span>
<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</code></pre></div></div> <blockquote> <p>要记住当分配的内存不需要再使用后要即使释放。</p> </blockquote> <h4 id="622-allocator类"> <a href="#622-allocator类" class="anchor-heading" aria-labelledby="622-allocator类"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.22 allocator类 </h4> <p>标准库<code class="language-plaintext highlighter-rouge">allocator</code>类定义在头文件<code class="language-plaintext highlighter-rouge">memory</code>中，它帮助我们将内存分配和对象构造分离开来。</p> <p>和<code class="language-plaintext highlighter-rouge">malloc</code>等函数不一样。<code class="language-plaintext highlighter-rouge">allocator</code>类既提供内存分配和释放操作，也提供对象创建和销毁操作。</p> <p><code class="language-plaintext highlighter-rouge">allocator</code>是一个类模板。为了定义一个<code class="language-plaintext highlighter-rouge">allocator</code>对象，我们必须指明这个<code class="language-plaintext highlighter-rouge">allocator</code>可以分配的对象类型。当一个<code class="language-plaintext highlighter-rouge">allocator</code>对象分配内存时，它会根据给定的对象类型來确定恰当的内存大小和对齐位置。</p> <blockquote> <p>一个<code class="language-plaintext highlighter-rouge">allocator</code>对象只能分配其给定类型的对象。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">allocator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span> <span class="c1">// 可以分配string的allocator对象</span>
<span class="k">auto</span> <span class="k">const</span> <span class="n">p</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">//分配n个string类型大小的空间。</span>
</code></pre></div></div> <h5 id="6221-allocator类的操作"> <a href="#6221-allocator类的操作" class="anchor-heading" aria-labelledby="6221-allocator类的操作"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.221 allocator类的操作 </h5> <p>以下是<code class="language-plaintext highlighter-rouge">allocator</code>类所支持的操作：</p> <ul> <li>内存分配 <ol> <li>指明可以分配的对象类型: <blockquote> <p>allocator<指明的类型T> 对象名a</指明的类型T></p> </blockquote> <p>定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存。</p> </li> <li>指明分配对象的数量: <blockquote> <p>对象名a.allocate(数量n)</p> </blockquote> <p>分配一段原始的、未构造的内存，含有n个类型为T的对象的空间，并返回一个指向该内存开始地址的T*类型的指针。</p> </li> </ol> </li> <li>对象创建 <blockquote> <p>对象名a.construct(指针p, 需要传递给指明类型构造函数的实参们args)</p> </blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  p必须是指向a所的分配的内存的类型为T*的指针(不能是指向其他allocator对象或其他对象的指针)；arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象。
</code></pre></div> </div> </li> <li>对象销毁 <blockquote> <p>对象名a.destroy(指针p)</p> </blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  p必须是指向a所的分配的内存的类型为T*的指针(不能是指向其他allocator对象或其他对象的指针)，该函数对p指向的对象执行析构函数。
</code></pre></div> </div> </li> <li>内存释放 <blockquote> <p>对象名a.deallocate(指针p, 数量n)</p> </blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  p必须是先前由a.allocate函数所返回的指针或者其副本；n必须是先前a.allocate函数所指定的数量。
  释放从T*指针p中地址开始的内存，这块内存的大小为n\*sizeof(T)。
</code></pre></div> </div> </li> </ul> <p>和<code class="language-plaintext highlighter-rouge">calloc</code>函数类似，我们对于<code class="language-plaintext highlighter-rouge">allocate</code>函数返回的指针，可以像指向容器元素的指针一样进行元素访问的操作。</p> <p>和之前提到的步骤一样，我们在使用<code class="language-plaintext highlighter-rouge">allocator</code>类构建动态内存对象时也需要按照这四个步骤进行。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 内存分配：分配一个能保存5个string类型大小的空间</span>
<span class="n">allocator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strs</span><span class="p">;</span>
<span class="n">string</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">strs</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="c1">// 对象创建：遍历每个string空间并在其中构造string对象</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">strs</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="s">"str"</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">));</span>
<span class="c1">// 遍历每个string空间并输出对应string对象的值</span>
<span class="c1">// 输出为str5 str6 str7 str8 str9</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="c1">// 对象销毁：遍历每个string空间并销毁在其中的string对象</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">strs</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
<span class="c1">// 内存释放：释放之前分配的保存5个string类型大小的空间</span>
<span class="n">strs</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</code></pre></div></div> <blockquote> <p>不能使用未构造对象的内存，其行为是未定义的。</p> </blockquote> <blockquote> <p>我们只能对真正构造了对象的内存空间进行destroy操作，否则行为是未定义的。</p> </blockquote> <blockquote> <p>当某空间的对象被销毁后，还可以重新使用这部分内存來保存其他同类型的对象。</p> </blockquote> <h5 id="6222-allocator类的快捷对象构建操作"> <a href="#6222-allocator类的快捷对象构建操作" class="anchor-heading" aria-labelledby="6222-allocator类的快捷对象构建操作"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.222 allocator类的快捷对象构建操作 </h5> <p>标准库还为<code class="language-plaintext highlighter-rouge">allocator</code>类定义了两种算法，可以在未构造对象的内存中创建对象，它们都定义在头文件<code class="language-plaintext highlighter-rouge">memory</code>中。</p> <p><img src="/Cpp_Guide_detailed/assets/images/2021-05-24-14-31-52.png" alt="allocator2" /></p> <h3 id="63-内存与对象操作组合的管理方法"> <a href="#63-内存与对象操作组合的管理方法" class="anchor-heading" aria-labelledby="63-内存与对象操作组合的管理方法"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.3 内存与对象操作组合的管理方法 </h3> <p>内存与对象操作组合的管理方法是指：</p> <ol> <li>在执行动态内存分配操作后，该操作自动创建了给定类型的对象。</li> <li>在执行内存释放操作时，该操作自动先执行了给定对象的销毁操作。</li> </ol> <p>所以我们在使用这些管理方法时，就不必考虑对象的构造与销毁了。</p> <p>内存与对象操作组合的管理方法有一种，这种操作支持某部分的自定义，接下来会来介绍这种操作：</p> <h4 id="631-new和delete运算符"> <a href="#631-new和delete运算符" class="anchor-heading" aria-labelledby="631-new和delete运算符"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.31 new和delete运算符 </h4> <p>C++语言定义了两个运算符来分配和释放动态内存。</p> <p>运算符<code class="language-plaintext highlighter-rouge">new</code>分配内存并创建对象。 <code class="language-plaintext highlighter-rouge">delete</code>销毁所给指针所指的对象并释放该对象的内存。</p> <h5 id="6311-new表达式"> <a href="#6311-new表达式" class="anchor-heading" aria-labelledby="6311-new表达式"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.311 new表达式 </h5> <p><code class="language-plaintext highlighter-rouge">new</code>表达式的使用形式为：</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">new</code> 类型(包含类型修饰符) (可选 显式初始化)</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">new</code>表达式一个所给类型尺寸大小的内存并在其中创建一个该类型的对象。 <code class="language-plaintext highlighter-rouge">new</code>表达式返回一个指向该类型对象的指针。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// pi指向一个动态分配的、默认初始化的无名int对象。</span>
</code></pre></div></div> <p>和普通的声明或定义语句一样，<code class="language-plaintext highlighter-rouge">new</code>里的类型可以有各种类型修饰符。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">ins</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ins</span><span class="p">;</span>
<span class="c1">// 分配并初始化一个int*</span>
<span class="kt">int</span> <span class="o">**</span><span class="n">ppi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">*</span><span class="p">(</span><span class="n">pi</span><span class="p">);</span>
<span class="c1">// 输出8</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">**</span><span class="n">ppi</span><span class="p">;</span>
<span class="c1">// 分配并初始化一个const int</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pci</span> <span class="o">=</span> <span class="k">new</span> <span class="k">const</span> <span class="nf">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
</code></pre></div></div> <p>在没有给定显式初始化时，动态分配的对象是默认初始化的，所以对于默认构造函数的类型，必须要显示初始化。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">;</span> <span class="c1">// 初始化为空string</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// pi指向一个未初始化的int</span>
</code></pre></div></div> <p>对给定类型的显式初始化，只能用直接初始化的方式进行初始化。 所以调用类型的值初始化要在类型后面加圆括号<code class="language-plaintext highlighter-rouge">()</code>或花括号<code class="language-plaintext highlighter-rouge">{}</code>。</p> <blockquote> <p>和一般变量的初始化一样，用列表初始化时，列表所给的初始值数量不能超过所给类型所规定的初始值数量。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="o">*</span><span class="n">psl</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">;</span> <span class="c1">//默认初始化为空string </span>
<span class="n">string</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">string</span><span class="p">();</span> <span class="c1">//值初始化为空string </span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pil</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">//默认初始化；*pil的值未定义 </span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi2</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">int</span><span class="p">();</span> <span class="c1">//值初始化为0; *pi2为0</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">{};</span> <span class="c1">//值初始化为0; *pi3为0</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi4</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span> <span class="c1">//初始化为3; *pi4为3</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi5</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span> <span class="c1">//错误：初始化值数量过多。</span>
</code></pre></div></div> <p>我们可以用auto类型来让编译器来自动推断所要分配的内存以及创建对象的类型，和一般变量的初始化一样，要显式初始化动态对象才能使用auto。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 正确：初始化为36; *pi为36</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="k">auto</span><span class="p">{</span><span class="mi">36</span><span class="p">};</span>
<span class="c1">// 正确：初始化为3.66; *pd为3.66</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">auto</span><span class="p">(</span><span class="mf">3.66</span><span class="p">);</span>
<span class="c1">// 正确：初始化为strs; **ps为strs</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">auto</span><span class="p">(</span><span class="s">"strs"</span><span class="p">);</span>
<span class="c1">// 错误：用auto必须要显式初始化。</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi2</span> <span class="o">=</span> <span class="k">new</span> <span class="k">auto</span><span class="p">;</span>
</code></pre></div></div> <h5 id="6312-delete表达式"> <a href="#6312-delete表达式" class="anchor-heading" aria-labelledby="6312-delete表达式"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.312 delete表达式 </h5> <p><code class="language-plaintext highlighter-rouge">delete</code>表达式是专门用于释放<code class="language-plaintext highlighter-rouge">new</code>表达式所分配的内存的。 <code class="language-plaintext highlighter-rouge">delete</code>销毁所给指针所指的对象并释放该对象的内存。</p> <p><code class="language-plaintext highlighter-rouge">delete</code>表达式的形式为：</p> <blockquote> <p>delete 指针</p> </blockquote> <p>我们传递给<code class="language-plaintext highlighter-rouge">delete</code>的指针必须是指向<code class="language-plaintext highlighter-rouge">new</code>所分配的内存，或者是一个空指针。 释放一块并非<code class="language-plaintext highlighter-rouge">new</code>分配的内存，或者将相同的指针值释放多次，其行为是未定义的。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">pil</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">pi2</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">(</span><span class="mi">33</span><span class="p">),</span> <span class="o">*</span><span class="n">pd2</span> <span class="o">=</span> <span class="n">pd</span><span class="p">;</span> 
<span class="k">delete</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//错误：i不是一个指针</span>
<span class="k">delete</span> <span class="n">pil</span><span class="p">;</span> <span class="c1">//未定义：pil指向一个局部变量 </span>
<span class="k">delete</span> <span class="n">pd</span><span class="p">;</span> <span class="c1">//正确</span>
<span class="k">delete</span> <span class="n">pd2</span><span class="p">;</span> <span class="c1">//未定义：pd2指向的内存已经被释放了</span>
<span class="k">delete</span> <span class="n">pi2</span><span class="p">;</span> <span class="c1">//正确：释放一个空指针总是没有错</span>
</code></pre></div></div> <h5 id="6313-new-表达式"> <a href="#6313-new-表达式" class="anchor-heading" aria-labelledby="6313-new-表达式"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.313 new[ ]表达式 </h5> <p>之前我们说过<code class="language-plaintext highlighter-rouge">new</code>里的类型可以有各种类型修饰符，那么理所当然，我们可以通过将其类型写为数组类型来创建一个动态对象的数组。 所以，当我们想要一次性分配多个同类型的对象时，就可以使用<code class="language-plaintext highlighter-rouge">new[ ]</code>表达式。</p> <p><code class="language-plaintext highlighter-rouge">new[ ]</code>的普通使用形式为：</p> <blockquote> <p>new 类型(包含类型修饰符) [容量大小] (可选 显式初始化)</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">new[ ]</code>表达式分配一个能包含所有所给容量大小数量的对象的内存并在其中创建所给容量大小数量的对象。 <code class="language-plaintext highlighter-rouge">new[ ]</code>表达式返回一个指向动态对象数组的首元素的指针。</p> <p>和数组的初始化一样: 没有显式初始化时，其里面的元素都为默认初始化； <code class="language-plaintext highlighter-rouge">auto</code>不能用于数组类型。</p> <p>和数组不一样的是： 类型修饰符<code class="language-plaintext highlighter-rouge">[ ]</code>内的==容量大小不能省略==。</p> <p>和数组一样的是： 可以用空圆/花括号来值初始化。</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">new[ ]</code>表达式的初始化规则与<code class="language-plaintext highlighter-rouge">new</code>表达式一样。</p> </blockquote> <p>和数组类似，可以将其返回的指针当做指向容器内元素的指针一样进行元素访问。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 正确：输出为2 6 8 1 3</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]{</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="c1">// 正确：值初始化，输出为0 0 0 0 0</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
</code></pre></div></div> <blockquote> <p>当定义一个动态对象的多维数组时，数组不一样的是，如果列表初始化的列表不为空，则初始值必须要嵌套才行，否则会出错。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 正确：初始值已嵌套，输出为6 9 8 4 5 3 6 2 -8</span>
<span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">a2p</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]{{</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">},{</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">},{</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">}};</span>
<span class="c1">// 正确：两种定义的列表都为空，输出为0 0 0 0 0 0 0 0 0</span>
<span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">a2p</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]{};</span>
<span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">a2p</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">a2p</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
</code></pre></div></div> <h5 id="6314-delete-表达式"> <a href="#6314-delete-表达式" class="anchor-heading" aria-labelledby="6314-delete-表达式"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.314 delete[ ]表达式 </h5> <p><code class="language-plaintext highlighter-rouge">delete[ ]</code>表达式是专门用于释放<code class="language-plaintext highlighter-rouge">new[ ]</code>表达式所分配的内存的。 <code class="language-plaintext highlighter-rouge">delete[ ]</code>表达式先自动将所给指针中所保存的内存中的每个对象进行销毁(逆序销毁：即，最后一个元素首先被销毁，然后是倒数第二个，依此类推)，然后释放所给指针中所保存的所有内存。</p> <p>和<code class="language-plaintext highlighter-rouge">new[ ]</code>表达式类似，<code class="language-plaintext highlighter-rouge">delete[ ]</code>表达式的普通形式为：</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">delete[ ]</code> 指针</p> </blockquote> <p>我们传递给<code class="language-plaintext highlighter-rouge">delete[ ]</code>的指针必须是指向<code class="language-plaintext highlighter-rouge">new[ ]</code>所分配的内存的第一个元素，或者是一个空指针。 释放一块并非<code class="language-plaintext highlighter-rouge">new[ ]</code>分配的内存，或者将相同的指针值释放多次，其行为是未定义的。</p> <blockquote> <p>在释放一个数组指针时必须使用方括号，不能用普通的<code class="language-plaintext highlighter-rouge">delete</code>表达式，否则其行为是未定义的。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">type</span> <span class="n">def</span> <span class="kt">int</span> <span class="n">arrT</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// arrT是42个int的数组的类型别名</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">arrT</span><span class="p">;</span> <span class="c1">//分配一个42个int的数组；p指向第一个元素</span>
<span class="k">delete</span> <span class="p">[]</span> <span class="n">p</span><span class="p">;</span> <span class="c1">//方括号是必需的，因为我们当初分配的是一个</span>
</code></pre></div></div> <h5 id="6315-定位new表达式"> <a href="#6315-定位new表达式" class="anchor-heading" aria-labelledby="6315-定位new表达式"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.315 定位new表达式 </h5> <p>有时候，我们为了一些操作，需要向<code class="language-plaintext highlighter-rouge">new</code>传递一些额外的参数，此时可以用<code class="language-plaintext highlighter-rouge">new</code>相关表达式的另一种形式，这种形式也叫做定位<code class="language-plaintext highlighter-rouge">new</code>(placement new)。 定位<code class="language-plaintext highlighter-rouge">new</code>表达式的形式为：</p> <blockquote> <p>new (指针/nothrow对象) 类型(包含类型修饰符) (可选 [容量大小]) (可选 显式初始化)</p> </blockquote> <p>定位<code class="language-plaintext highlighter-rouge">new</code>表达式传递的实参为<code class="language-plaintext highlighter-rouge">nothrow</code>对象时，是用于阻止内存异常的。</p> <p>定位<code class="language-plaintext highlighter-rouge">new</code>表达式传递的实参为指针时，是用于在指针所指的地址中创建给定类型的对象的。</p> <blockquote> <p>定位<code class="language-plaintext highlighter-rouge">new</code>表达式只能额外传递最多一个参数，且必须是指针(或者能隐式转换成指针)或者<code class="language-plaintext highlighter-rouge">nothrow</code>对象。</p> </blockquote> <p>接下来会详细介绍这两个用途。</p> <h6 id="63151-定位new用于阻止内存异常"> <a href="#63151-定位new用于阻止内存异常" class="anchor-heading" aria-labelledby="63151-定位new用于阻止内存异常"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.3151 定位new用于阻止内存异常 </h6> <blockquote> <p><code class="language-plaintext highlighter-rouge">badalloc</code>和<code class="language-plaintext highlighter-rouge">nothrow</code>都定义在头文件<code class="language-plaintext highlighter-rouge">new</code>中。</p> </blockquote> <p>虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。 一旦一个程序用光了它所有可用的自由空间内存，<code class="language-plaintext highlighter-rouge">new</code>相关表达式就会失败。 默认情况下，如果<code class="language-plaintext highlighter-rouge">new</code>不能分配所要求的内存空间，它会抛出一个类型为<code class="language-plaintext highlighter-rouge">bad_alloc</code>的异常。</p> <p>所以为了阻止<code class="language-plaintext highlighter-rouge">new</code>相关表达式的表达式发出异常，我们可以使用定位<code class="language-plaintext highlighter-rouge">new</code>表达式并传递一个由标准库定义的名为<code class="language-plaintext highlighter-rouge">nothrow</code>的对象。 如果将<code class="language-plaintext highlighter-rouge">nothrow</code>传递给<code class="language-plaintext highlighter-rouge">new</code>，则<code class="language-plaintext highlighter-rouge">new</code>相关表达式就不会再抛出异常了，如果这时的<code class="language-plaintext highlighter-rouge">new</code>不能分配所需内存，则它会返回一个空指针。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//如果分配失败，new返回一个空指针</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pl</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// 如果分配失败，new抛出std::bad_alloc</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">//如果分配失败，new返回一个空指针</span>
</code></pre></div></div> <h6 id="63152-定位new用于构造对象"> <a href="#63152-定位new用于构造对象" class="anchor-heading" aria-labelledby="63152-定位new用于构造对象"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.3152 定位new用于构造对象 </h6> <p>当我们希望在某个内存地址上构造一个对象时，就可以使用定位<code class="language-plaintext highlighter-rouge">new</code>表达式并传递一个保存该地址的指针来在该地址上构造并初始化一个给定类型的对象。</p> <p>此时<code class="language-plaintext highlighter-rouge">new</code>==不分配任何内存==，它只是在指定的地址上构造对象并初始化，然后返回一个和实参指针相同地址的，指向给定类型的指针。</p> <blockquote> <p>要注意此时的定位<code class="language-plaintext highlighter-rouge">new</code>是构造一个新的对象，就算之前的地址有对象，定位<code class="language-plaintext highlighter-rouge">new</code>也是==直接抹除该对象数据==(不进行对象销毁，所以也就不调用其析构函数)，然后在该地址上直接创建一个新的对象。</p> </blockquote> <p>给定地址的字节大小必须不小于定位<code class="language-plaintext highlighter-rouge">new</code>所指定的类型的尺寸大小，否则会出错。</p> <blockquote> <p>不管所给的地址中是否已经含有某对象的数据，定位<code class="language-plaintext highlighter-rouge">new</code>会从低位开始直接覆盖掉所需要的空间的所有数据，然后==调用所给类型的对应构造函数==来构造对象。</p> <p>所以当给定地址的字节大小大于定位<code class="language-plaintext highlighter-rouge">new</code>所指定的类型的尺寸大小时，定位<code class="language-plaintext highlighter-rouge">new</code>所构造的对象地址只占低位所需要的字节，高位字节的数据仍然保留了下来。</p> </blockquote> <p>要注意此时的定位<code class="language-plaintext highlighter-rouge">new</code>不分配任何内存，所以当定位<code class="language-plaintext highlighter-rouge">new</code>用于对动态内存中创建对象时，使用完毕的清理工作不应该由<code class="language-plaintext highlighter-rouge">new</code>对应的<code class="language-plaintext highlighter-rouge">delete</code>来做，应该由当初分配内存操作所对应的清理操作来进行清理工作。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">string</span><span class="p">));</span>
<span class="c1">// 正确：sp所保存的地址不小于string类型的尺寸。\</span>
<span class="err">构造一个</span><span class="n">string</span><span class="err">对象，并初始化为</span><span class="n">strs1</span>
<span class="n">string</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="n">string</span><span class="p">(</span><span class="s">"strs1"</span><span class="p">);</span>
<span class="c1">// 正确：两个指针保存同一个地址，所以输出strs1 strs1</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">string</span><span class="o">*</span><span class="p">)</span><span class="n">sp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="c1">// 正确：因为内存是由malloc函数分配的\</span>
<span class="err">，所以要调用对应的</span><span class="n">free</span><span class="err">函数。</span>
<span class="n">free</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">sp2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
<span class="c1">// 正确：sp2所保存的地址不小于string类型的尺寸。\</span>
<span class="err">构造一个</span><span class="n">string</span><span class="err">对象，并初始化为</span><span class="n">strs2</span>
<span class="n">string</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">sp2</span><span class="p">)</span> <span class="n">string</span><span class="p">(</span><span class="s">"strs2"</span><span class="p">);</span>
<span class="c1">// 正确：两个指针保存同一个地址，所以输出strs2 strs2</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">string</span><span class="o">*</span><span class="p">)</span><span class="n">sp2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="c1">// 错误：内存是由malloc函数分配的\</span>
<span class="err">，与</span><span class="k">new</span><span class="err">无关。</span>
<span class="k">delete</span> <span class="n">p2</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">sp3</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// 错误：sp3所保存的地址小于string类型的尺寸，会出错。</span>
<span class="n">string</span><span class="o">*</span> <span class="n">p3</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">sp3</span><span class="p">)</span> <span class="n">string</span><span class="p">(</span><span class="s">"strs3"</span><span class="p">);</span>
</code></pre></div></div> <p>这种用法的定位<code class="language-plaintext highlighter-rouge">new</code>表达式所传递的地址甚至不需要是动态内存，此时定位<code class="language-plaintext highlighter-rouge">new</code>可以用来对该地址重新创建一个对象。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// double对象dou被默认初始化，\</span>
<span class="err">不能直接使用。</span>
<span class="kt">double</span> <span class="n">dou</span><span class="p">;</span>
<span class="c1">// 所以重新在该地址上创建了一个dou对象，值为3.48。</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dou</span><span class="p">)</span> <span class="kt">double</span><span class="p">(</span><span class="mf">3.48</span><span class="p">);</span>
<span class="c1">// 输出3.48 3.48</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dou</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
</code></pre></div></div> <h5 id="6316-自定义运算符函数"> <a href="#6316-自定义运算符函数" class="anchor-heading" aria-labelledby="6316-自定义运算符函数"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.316 自定义运算符函数 </h5> <p>某些应用程序对内存分配有特殊的需求，因此我们无法将标准内存管理机制直接应用于这些程序。它们常常需要自定义内存分配的细节，比如使用关键字<code class="language-plaintext highlighter-rouge">new</code>将对象放置在特定的内存空间中。为了实现这一目的，应用程序需要自定义某些部分以控制内存分配的过程。</p> <p>之前我们也谈到过，<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>相关表达式是将内存操作与对象操作组合起来的操作。</p> <h6 id="63161-new和delete运算符工作原理"> <a href="#63161-new和delete运算符工作原理" class="anchor-heading" aria-labelledby="63161-new和delete运算符工作原理"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.3161 new和delete运算符工作原理 </h6> <p>具体来说，对于<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">new[ ]</code>表达式，该操作有三个步骤：</p> <ol> <li>调用一个名为<code class="language-plaintext highlighter-rouge">operator new</code>(或者<code class="language-plaintext highlighter-rouge">operator new[ ]</code>)的标准库函数，分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象(或者对象的数组)。</li> <li>编译器运行相应的构造函数以构造这些对象，并为其传入初始值。</li> <li>对象被构造完成后，返回一个指向该对象的指针。</li> </ol> <p>对于<code class="language-plaintext highlighter-rouge">delete</code>和<code class="language-plaintext highlighter-rouge">delete[ ]</code>表达式，该操作有三个步骤：</p> <ol> <li>对所给指针所指的对象或者数组中的元素执行对应的析构函数。</li> <li>编译器调用名为<code class="language-plaintext highlighter-rouge">operator delete</code>(或者<code class="language-plaintext highlighter-rouge">operator delete[ ]</code>)的标准库函数释放内存空间。</li> </ol> <p>所以我们可以看出来在使用<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>相关表达式时，<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>运算符函数在其中只是充当内存方面的操作，而其他操作是由编译器自动执行。</p> <blockquote> <p>要注意<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>运算符与<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>运算符函数不是同一个操作： <code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>运算符函数只有内存方面的操作；而<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>运算符既有内存方面的操作，又有对象方面的操作。</p> </blockquote> <h6 id="63162-自定义new和delete运算符函数"> <a href="#63162-自定义new和delete运算符函数" class="anchor-heading" aria-labelledby="63162-自定义new和delete运算符函数"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.3162 自定义new和delete运算符函数。 </h6> <p>我们可以自定义<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>的运算符函数。但是和其他运算符函数不同（比如<code class="language-plaintext highlighter-rouge">operator=</code>），这两个函数并没有重载<code class="language-plaintext highlighter-rouge">new</code>或<code class="language-plaintext highlighter-rouge">delete</code>运算符。实际上，我们根本无法自定义<code class="language-plaintext highlighter-rouge">new</code>或<code class="language-plaintext highlighter-rouge">delete</code>运算符的行为。</p> <blockquote> <p>我们提供新的<code class="language-plaintext highlighter-rouge">operator new</code>函数和<code class="language-plaintext highlighter-rouge">operator delete</code>函数的目的在于改变内存分配的方式，但是不管怎样，我们都不能改变<code class="language-plaintext highlighter-rouge">new</code>运算符和<code class="language-plaintext highlighter-rouge">delete</code>运算符的基本含义。</p> </blockquote> <p>当我们定义了<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>的运算符函数时，编译器将使用我们自定义的版本替换标准库定义的版本。</p> <p><strong>可重载的运算符函数</strong></p> <p>不是所有的<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>的运算符函数我们都可以重载，我们只能重载某些部分的运算符函数，以下是可重载的运算符函数的声明：</p> <blockquote> <p>标准库定义了<code class="language-plaintext highlighter-rouge">operator new</code>函数和<code class="language-plaintext highlighter-rouge">operator delete</code>函数的8个重载版本。其中前4个版本可能抛出<code class="language-plaintext highlighter-rouge">bad_alloc</code>异常，后4个版本则不会抛出异常。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//这些版本可能抛出异常</span>
<span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="kt">size_t</span><span class="p">);</span> 
<span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">[](</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">//这些版本承诺不会抛出异常</span>
<span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">nothrow_t</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> 
<span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">nothrow_t</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> 
<span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="n">nothrow_t</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">[](</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="n">nothrow_t</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</code></pre></div></div> <ul> <li>对于可重载的所有运算符函数来说： <ol> <li>类型<code class="language-plaintext highlighter-rouge">nothrow_t</code>是定义在<code class="language-plaintext highlighter-rouge">new</code>头文件中的一个<code class="language-plaintext highlighter-rouge">struct</code>,在这个类型中不包含任何成员。 <blockquote> <p><code class="language-plaintext highlighter-rouge">new</code>头文件还定义了一个类型为<code class="language-plaintext highlighter-rouge">nothrow_t</code>，名为<code class="language-plaintext highlighter-rouge">nothrow</code>的<code class="language-plaintext highlighter-rouge">const</code>对象，用户可以通过这个对象请求<code class="language-plaintext highlighter-rouge">new</code>的非抛出版本。</p> </blockquote> </li> <li>当我们将上述运算符函数定义成类的成员时，它们是<strong>隐式静态</strong>的。我们无须显式地声明static，当然这么做也不会引发错误。</li> </ol> </li> <li>对于<code class="language-plaintext highlighter-rouge">new</code>运算符函数来说： <ol> <li>返回类型必须是<code class="language-plaintext highlighter-rouge">void*</code>，且第一个形参的类型必须是<code class="language-plaintext highlighter-rouge">size_t</code>且该形参不能含有默认实参。 <blockquote> <p>当编译器调用<code class="language-plaintext highlighter-rouge">operator new</code>时，是把存储指定类型对象所需的字节数传给<code class="language-plaintext highlighter-rouge">size_t</code>形参；当调用<code class="language-plaintext highlighter-rouge">operator new[]</code>时，传给<code class="language-plaintext highlighter-rouge">size_t</code>形参的则是存储数组中所有元素所需的空间。</p> </blockquote> </li> <li>我们可以为<code class="language-plaintext highlighter-rouge">new</code>运算符函数提供额外的多个形参，但是第一个额外的形参类型不能是<code class="language-plaintext highlighter-rouge">void*</code>。 <blockquote> <p>此时，用到该函数的<code class="language-plaintext highlighter-rouge">new</code>表达式必须使用<code class="language-plaintext highlighter-rouge">new</code>的定位形式将实参传给额外形参。</p> </blockquote> </li> </ol> </li> <li>对于<code class="language-plaintext highlighter-rouge">delete</code>运算符函数来说： <ol> <li>返回类型必须是<code class="language-plaintext highlighter-rouge">void</code>，且第一个形参的类型必须是<code class="language-plaintext highlighter-rouge">void*</code>且该形参不能含有默认实参。 <blockquote> <p>执行一条<code class="language-plaintext highlighter-rouge">delete</code>表达式将调用相应的<code class="language-plaintext highlighter-rouge">operator</code>函数，并用指向待释放内存的指针来初始化<code class="language-plaintext highlighter-rouge">void*</code>形参。</p> </blockquote> </li> <li>我们可以为<code class="language-plaintext highlighter-rouge">delete</code>运算符函数提供额外的多个形参。 <blockquote> <p>此时，用到该函数的<code class="language-plaintext highlighter-rouge">delete</code>表达式的形式和<code class="language-plaintext highlighter-rouge">new</code>的定位形式类似，用于将实参传给额外形参。</p> </blockquote> </li> <li>当<code class="language-plaintext highlighter-rouge">delete</code>运算符函数定义成类的成员时，第一个额外的形参类型可以是<code class="language-plaintext highlighter-rouge">size_t</code>，此时，该形参的初始值是第一个形参所指对象的字节数，<code class="language-plaintext highlighter-rouge">size_t</code>形参可用于删除继承体系中的对象。 如果基类有一个虚析构函数，则传递给<code class="language-plaintext highlighter-rouge">operator delete</code>的字节数将因待删除指针所指对象的动态类型不同而有所区别。而且实际运行的<code class="language-plaintext highlighter-rouge">operator delete</code>函数版本也由对象的动态类型决定。</li> <li>因为<code class="language-plaintext highlighter-rouge">operator delete</code>函数只是释放内存，基本不会抛出异常，所以当我们重载<code class="language-plaintext highlighter-rouge">delete</code>运算符函数时，需要使用<code class="language-plaintext highlighter-rouge">noexcept</code>异常说明符指定其不抛出异常。</li> </ol> </li> </ul> <p><strong>运算符函数的查找顺序</strong></p> <p>我们既可以在全局作用域和命名空间中定义<code class="language-plaintext highlighter-rouge">operator new</code>函数和<code class="language-plaintext highlighter-rouge">operator delete</code>函数，也可以将它们定义为成员函数。</p> <p>当编译器发现一条<code class="language-plaintext highlighter-rouge">new</code>表达式或<code class="language-plaintext highlighter-rouge">delete</code>表达式后，将在程序中查找可供调用的<code class="language-plaintext highlighter-rouge">operator</code>函数，查找顺序为：</p> <ol> <li>如果<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>所指定的对象的类型及其该类型的基类里有成员函数版本的对应运算符函数，则<strong>优先调用成员函数版本</strong>。</li> <li>如果没有成员函数版本，则比较其他可见版本的函数并匹配最优函数调用。</li> </ol> <p>我们可以使用作用域运算符显式指定<code class="language-plaintext highlighter-rouge">new</code>表达式或<code class="language-plaintext highlighter-rouge">delete</code>表达式中的运算符函数。例如，<code class="language-plaintext highlighter-rouge">::new</code>只在全局作用域中查找匹配的<code class="language-plaintext highlighter-rouge">operator new</code>函数， <code class="language-plaintext highlighter-rouge">::delete</code>与之类似。</p> <h3 id="64-raii思想的管理方法"> <a href="#64-raii思想的管理方法" class="anchor-heading" aria-labelledby="64-raii思想的管理方法"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.4 RAII思想的管理方法 </h3> <p>运用<code class="language-plaintext highlighter-rouge">RAII</code>思想的动态内存管理的方法是将内存的操作和对象的操作一起结合起来。 该方法模拟编译器在管理局部对象的操作。创建对象时自动分配内存，不需要用时自动执行销毁和内存释放操作，而无需手动操作。</p> <p>运用<code class="language-plaintext highlighter-rouge">RAII</code>思想的动态内存管理的方法主要是运用智能指针。</p> <p>接下来我们会主要介绍这几种智能指针：</p> <ul> <li><code class="language-plaintext highlighter-rouge">shared_ptr</code>类 <ul> <li><code class="language-plaintext highlighter-rouge">weak_ptr</code>伴随类</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">unique_ptr</code>类</li> </ul> <h4 id="641-智能指针"> <a href="#641-智能指针" class="anchor-heading" aria-labelledby="641-智能指针"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.41 智能指针 </h4> <blockquote> <p>智能指针类型都定义在<code class="language-plaintext highlighter-rouge">memory</code>头文件中。</p> </blockquote> <p>标准库提供了叫做智能指针类型的类模板来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动销毁和释放所指向的对象。</p> <p>其中提供了两大智能指针以及一个伴随类智能指针：</p> <ul> <li><code class="language-plaintext highlighter-rouge">shared_ptr</code>类 <ul> <li><code class="language-plaintext highlighter-rouge">weak_ptr</code>伴随类</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">unique_ptr</code>类</li> </ul> <p>这两种智能指针的区别在于管理底层指针的方式：</p> <ul> <li><code class="language-plaintext highlighter-rouge">shared_ptr</code>允许多个指针指向同一个对象。</li> <li><code class="language-plaintext highlighter-rouge">unique_ptr</code>则“独占”所指向的对象。</li> <li><code class="language-plaintext highlighter-rouge">weak_ptr</code>是一种弱引用，指向<code class="language-plaintext highlighter-rouge">shared_ptr</code>所管理的对象。</li> </ul> <p>除了<code class="language-plaintext highlighter-rouge">weak_ptr</code>类指针能被<code class="language-plaintext highlighter-rouge">shared_ptr</code>类指针拷贝和赋值以外，不同类型的智能指针之间不能拷贝和赋值。 但除了<code class="language-plaintext highlighter-rouge">unique_ptr</code>类指针以外，同类型的智能指针之间能拷贝和赋值。</p> <blockquote> <p>所有智能指针都不能指向非动态分配的对象。</p> </blockquote> <blockquote> <p>所有智能指针都不支持算术运算，但除了<code class="language-plaintext highlighter-rouge">weak_ptr</code>类指针，其他同类型的指针支持关系运算。</p> </blockquote> <p>以下是<code class="language-plaintext highlighter-rouge">shared_ptr</code>和<code class="language-plaintext highlighter-rouge">unique_ptr</code>都支持的操作：</p> <p>支持的操作|解释</p> <ul> <li>|- shared_ptr&lt;T&gt; sp<br />unique_ptr&lt;T&gt; up | 空智能指针sp或up，可以指向类型为T的对象<br />(当空智能指针为shared_ptr类时，该指针计数器为0) p|将智能指针p用作一个条件判断，若p指向一个对象，则为true <em>p|解引用智能指针p,获得它指向的对象 p-&gt;mem|访问智能指针p所指向对象的成员<br />等价于(</em>p).mem p.get()|返回一个指向智能指针p所指对象的对应类型的指针。<br />(不会引起p计数器的变化)<br />要小心使用，因为此时智能指针仍有该对象的内存管理所有权。因此，若智能指针释放了其对象，返回的指针所指向的对象也就消失了。 swap(p,q) <br /> p.swap(q)|交换同类型的智能指针p和q中的保存的地址。(还会交换p和q中计数器的值、分配器以及删除器等)</li> </ul> <h5 id="6411-shared_ptr类"> <a href="#6411-shared_ptr类" class="anchor-heading" aria-labelledby="6411-shared_ptr类"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.411 shared_ptr类 </h5> <p>因为智能指针也都是模板，所以当我们创建一个智能指针时，必须提供指针可以指向的类型。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">pl</span><span class="p">;</span> <span class="c1">// shared_ptr，可以指向string</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">p2</span><span class="p">;</span> <span class="c1">//shared_ptr,可以指向int的list</span>
</code></pre></div></div> <h6 id="64111-shared_ptr类的操作"> <a href="#64111-shared_ptr类的操作" class="anchor-heading" aria-labelledby="64111-shared_ptr类的操作"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.4111 shared_ptr类的操作 </h6> <p>以下是<code class="language-plaintext highlighter-rouge">shared_ptr</code>类独有的操作：</p> <p>支持的操作|解释</p> <ul> <li>|- make_shared&lt;T&gt; (args)|返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用实参表args初始化此对象。<br /> 如果args为空，则执行值初始化。 sharedptr&lt;T&gt; sp(sq/q) <br /> sharedptr&lt;T&gt; sp(q, d)|sq是非unique_ptr的智能指针；q只能是能够隐式转换为T<em>类型的普通类型指针或空指针，且如果没有传递d，则必须保存的是动态内存；d是可调用对象。<br /><br />如果传递的是sq，则shared_ptr类型指针sp是sq的拷贝(先加1再拷贝，注意拷贝会将sp的分配器和删除器都设置为sq对应的)，且sq中的计数器会加1。 <br />如果传递的是q，则指针sp保存q中的地址，并且sp的计数器设为1。<br /> 如果传递了d，则sp将用d来代替关联对象的清理工作。 sp.reset() <br /> sp.reset(q) <br /> sp.reset(q,d)|q只能是能够隐式转换为T</em>类型的普通类型指针或空指针，且如果sp没有改变其清理方式，则必须保存的是动态内存；d是可调用对象。<br /><br /> 不管调用的是哪种原型，首先，如果sp的计数器为0，则计数器不变；否则所有共享该指针所指的对象的指针(包括自己)的计数器都减1，如果减1后有任意一个共享该对象的指针的计数器为0，则对该对象执行清理工作。<br /><br />如果没有传递任何实参，则会将sp设为空智能指针。<br />如果传递了q，则sp保存q中的地址，并且sp的计数器设为1。<br />如果还传递了d，则sp将用d来代替关联对象的清理工作。 sp = sq|sp和sq必须都是shared_ptr，且其类型必须能相互隐式转换。<br /><br /> 此操作会递减sp的引用计数(若sp的引用计数变为0, 则将对其管理的对象执行清理操作)，接着递増sq的引用计数，最后sp变为sq的拷贝（注意拷贝会将sp的分配器和删除器都设置为sq对应的）。 sp.use_count()|返回与shared_ptr指针sp共享对象的智能指针数量。 sp.unique()|若sp.use_count()为1，返回true；否则返回false。</li> </ul> <p>默认初始化的智能指针中保存着一个空指针，我们还可以用其他<code class="language-plaintext highlighter-rouge">shared_ptr</code>指针和保存动态内存的指针来初始化或重置<code class="language-plaintext highlighter-rouge">shared_ptr</code>指针。</p> <blockquote> <p>默认情况下，<code class="language-plaintext highlighter-rouge">shared_ptr</code>假定它们指向的是动态内存，所以在没有自定义清理操作时，其他类型的指针必须保存的是动态内存的才行，否则出现未定义行为。</p> </blockquote> <h6 id="64112-计数器"> <a href="#64112-计数器" class="anchor-heading" aria-labelledby="64112-计数器"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.4112 计数器 </h6> <p>我们可以认为每个<code class="language-plaintext highlighter-rouge">shared_ptr</code>都有一个关联的计数器，通常称其为引用计数(reference count)。</p> <p>引起<code class="language-plaintext highlighter-rouge">shared_ptr</code>的计数器变化的操作有两种：</p> <ol> <li>当进行<code class="language-plaintext highlighter-rouge">shared_ptr</code>类之间的拷贝或赋值操作时。</li> <li>当<code class="language-plaintext highlighter-rouge">shared_ptr</code>指针对象被销毁时。 <ul> <li>局部非静态<code class="language-plaintext highlighter-rouge">shared_ptr</code>指针对象离开其作用域时。</li> <li>临时<code class="language-plaintext highlighter-rouge">shared_ptr</code>指针对象完成其表达式时。</li> <li>动态分配的<code class="language-plaintext highlighter-rouge">shared_ptr</code>指针对象被销毁时。</li> </ul> </li> </ol> <p>当进行<code class="language-plaintext highlighter-rouge">shared_ptr</code>类之间的拷贝或赋值操作时，计数器就会有变化，具体变化步骤为： 1. 对于拷贝或赋值到的指针来说：如果该指针的计数器为0，则计数器不变；否则所有共享该指针所指的对象的指针(包括自己)的计数器都减1，如果减1后有任意一个共享该对象的指针的计数器为0，则对该对象执行清理工作。 2. 对于用于拷贝或赋值的指针来说：将所有共享该指针所指的对象的指针(包括自己)的计数器都加1。 3. 最后将拷贝或赋值到的指针的地址和计数器的值修改为用于拷贝或赋值的指针的地址和计数器的值。</p> <p>当<code class="language-plaintext highlighter-rouge">shared_ptr</code>指针对象被销毁时，和拷贝或赋值时一样： 如果该指针的计数器为0，则计数器不变；否则所有共享该指针所指的对象的指针(包括自己)的计数器都减1，如果减1后有任意一个共享该对象的指针的计数器为0，则对该对象执行清理工作。</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">shared_ptr</code>指针的清理操作只有在该指针的计数器为0时才执行。</p> </blockquote> <h5 id="6412-智能指针的清理操作"> <a href="#6412-智能指针的清理操作" class="anchor-heading" aria-labelledby="6412-智能指针的清理操作"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.412 智能指针的清理操作 </h5> <p>清理操作是指先销毁对象，然后释放内存的组合操作。</p> <p>对于<code class="language-plaintext highlighter-rouge">shared_ptr</code>类和<code class="language-plaintext highlighter-rouge">unique_ptr</code>类来说，它们都有着自己的清理其指向对象的操作。 <code class="language-plaintext highlighter-rouge">shared_ptr</code>指针和<code class="language-plaintext highlighter-rouge">unique_ptr</code>类的清理操作在默认情况下是都使用<code class="language-plaintext highlighter-rouge">delete</code>运算符来释放它所关联的对象。</p> <p>我们也可以自定义一种可调用对象来修改某智能指针指针的清理操作，用于智能指针的清理操作的可调用对象也叫做删除器。</p> <p>用于删除器的可调用对象必须要满足以下条件：</p> <ul> <li>可调用对象的形参表的形参数量必须不小于1。</li> <li>形参表的第一个形参必须为智能指针所指定类型的指针，或者能隐式转换成所指定类型的指针。</li> <li>可调用对象的形参表如果还有其他形参，则这些形参必须都有默认实参。</li> </ul> <h5 id="6413-weak_ptr伴随类"> <a href="#6413-weak_ptr伴随类" class="anchor-heading" aria-labelledby="6413-weak_ptr伴随类"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.413 weak_ptr伴随类 </h5> <p><code class="language-plaintext highlighter-rouge">weak_ptr</code>是一种不控制所指向对象生存期的智能指针，它指向由一个<code class="language-plaintext highlighter-rouge">shared_ptr</code>管理的对象。将一个<code class="language-plaintext highlighter-rouge">weak_ptr</code>绑定到一个<code class="language-plaintext highlighter-rouge">shared_ptr</code>不会改变<code class="language-plaintext highlighter-rouge">shared_ptr</code>的计数器。</p> <p>一旦最后一个指向对象的<code class="language-plaintext highlighter-rouge">shared_ptr</code>被销毁，对象就会被释放。即使有<code class="language-plaintext highlighter-rouge">weak_ptr</code>指向对象，对象也还是会被释放，因此，<code class="language-plaintext highlighter-rouge">weak_ptr</code>的名字抓住了这种智能指针“弱”共享对象的特点。</p> <p>以下是<code class="language-plaintext highlighter-rouge">weak_ptr</code>所支持的操作：</p> <p><img src="/Cpp_Guide_detailed/assets/images/2021-05-25-15-16-59.png" alt="weak_ptr" /></p> <p>我们只能用<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>指针来拷贝和赋值<code class="language-plaintext highlighter-rouge">weak_ptr</code>的指针。</p> <blockquote> <p>不能用除了<code class="language-plaintext highlighter-rouge">shared_ptr</code>和<code class="language-plaintext highlighter-rouge">weak_ptr</code>的其他类型指针来拷贝和赋值<code class="language-plaintext highlighter-rouge">weak_ptr</code>的指针，否则会出错。</p> </blockquote> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">wp</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// wp弱共享p; p的引用计数未改变</span>
</code></pre></div></div> <p>由于对象可能不存在，我们不要使用<code class="language-plaintext highlighter-rouge">weak_ptr</code>直接访问对象，最好调用<code class="language-plaintext highlighter-rouge">lock</code>函数，此函数检查<code class="language-plaintext highlighter-rouge">weak_ptr</code>指向的对象是否仍存在。如果存在，<code class="language-plaintext highlighter-rouge">lock</code>函数返回一个指向共享对象的<code class="language-plaintext highlighter-rouge">shared_ptr</code>；否则返回一个空<code class="language-plaintext highlighter-rouge">shared_ptr</code>指针。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在这段代码中，\</span>
<span class="err">只有当</span><span class="n">lock</span><span class="err">调用返回</span><span class="n">true</span><span class="err">时</span>\
<span class="err">我们才会进入</span><span class="k">if</span><span class="err">语句体。</span>\
<span class="err">在</span><span class="k">if</span><span class="err">中，使用</span><span class="n">np</span><span class="err">访问共享对象是安全的。</span>
<span class="k">if</span> <span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">wp</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="c1">//如果np不为空则条件成立</span>
<span class="p">{</span> 
<span class="c1">//在if中，np与p共享对象</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="6414-unique_ptr类"> <a href="#6414-unique_ptr类" class="anchor-heading" aria-labelledby="6414-unique_ptr类"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.414 unique_ptr类 </h5> <p>一个<code class="language-plaintext highlighter-rouge">unique_ptr</code>“拥有”它所指向的对象。 与<code class="language-plaintext highlighter-rouge">shared_ptr</code>不同，某个时刻只能有一个<code class="language-plaintext highlighter-rouge">unique_ptr</code>指针指向一个给定对象。当某个<code class="language-plaintext highlighter-rouge">unique_ptr</code>指针被销毁时，它所指向的对象也会被清理。</p> <h6 id="64141-unique_ptr类所支持的操作"> <a href="#64141-unique_ptr类所支持的操作" class="anchor-heading" aria-labelledby="64141-unique_ptr类所支持的操作"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.4141 unique_ptr类所支持的操作 </h6> <p>以下是<code class="language-plaintext highlighter-rouge">unique_ptr</code>类独有的操作。</p> <p>支持的操作|解释</p> <ul> <li>|- unique_ptr&lt;T&gt; up(q) <br /> unique_ptr&lt;T, D&gt; up(d) <br /> unique_ptr&lt;T, D&gt; up(q, d)|q只能是能够隐式转换为T<em>类型的普通类型指针或空指针，且如果没有传递d，则必须保存的是动态内存；D是可调用对象的类型；d是D类型对应的可调用对象。<br /><br />如果传递了q，则up保存q中的地址；否则up为空unique_ptr。<br />如果指定了D，传递了d，则将用d来代替关联对象的清理工作；否则用delete运算符来进行清理工作。<br /> (第二和第三种形式中，D和d缺一不可，不能只有其中一个) up.reset() <br /> up.reset(nullptr) <br /> up.reset(q)|q只能是能够隐式转换为T</em>类型的普通类型指针或空指针，且如果up没有改变其清理方式，则必须保存的是动态内存；d是可调用对象。<br /><br /> 清理up所指向的对象 <br />如果没有传递任何实参或者只传递空指针，则会将up设为空智能指针。<br />如果传递了q，则up保存q中的地址。 up = nptr|nptr必须是空指针(不能是空智能指针)。 <br /><br /> 清理up所指向的对象，并将up设为空智能指针。 up.release()|返回一个指向指针up所指对象的对应类型的指针，并将up设为空智能指针。<br /> 此操作是指针up放弃对该对象的内存管理所有权，所以不会再执行该对象的清理工作。</li> </ul> <p>我们只能用保存动态内存的普通指针来拷贝<code class="language-plaintext highlighter-rouge">unique_ptr</code>指针。</p> <blockquote> <p>默认情况下，<code class="language-plaintext highlighter-rouge">unique_ptr</code>假定它们指向的是动态内存，所以在没有自定义清理操作时，其他类型的指针必须保存的是动态内存的才行，否则出现未定义行为。</p> </blockquote> <p>向<code class="language-plaintext highlighter-rouge">unique_ptr</code>传递的删除器必须要在尖括号中<code class="language-plaintext highlighter-rouge">unique_ptr</code>指向类型之后指定删除器类型，且提供的可调用对象也必须是指定的类型。</p> <h5 id="6415-智能指针的动态数组"> <a href="#6415-智能指针的动态数组" class="anchor-heading" aria-labelledby="6415-智能指针的动态数组"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6.415 智能指针的动态数组 </h5> <p>对于<code class="language-plaintext highlighter-rouge">shared_ptr</code>和<code class="language-plaintext highlighter-rouge">unique_ptr</code>类，标准库都提供了一个可以分配动态内存对象的数组的版本，为了用一个智能指针来管理动态数组，我们必须在对象类型后面跟一对空方括号(也就是<code class="language-plaintext highlighter-rouge">&lt;类型(可选 类型修饰符)[ ]&gt;</code>)。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// sp和up分别指向一个包含10个未初始化int的数组</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">up</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
<span class="c1">//自动用delete []销毁其指针</span>
<span class="n">sp</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="n">up</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> 
</code></pre></div></div> <p>当一个智能指针指向一个数组时，我们不能使用点和箭头成员运算符。毕竟智能指针指向的是一个数组而不是单个对象，因此这些运算符是无意义的。另外，当一个智能指针指向一个数组时，我们可以使用下标运算符来访问数组中的元素。</p> <p>以下是指向动态数组的<code class="language-plaintext highlighter-rouge">shared_ptr</code>和<code class="language-plaintext highlighter-rouge">unique_ptr</code>类所特有的操作。除了不能使用点和箭头成员运算符，<code class="language-plaintext highlighter-rouge">shared_ptr</code>和<code class="language-plaintext highlighter-rouge">unique_ptr</code>类所拥有的其他操作不变。</p> <div class="table-wrapper"><table> <thead> <tr> <th>支持的操作</th> <th>解释</th> </tr> </thead> <tbody> <tr> <td>unique_ptr&lt;T[ ]&gt; up <br /> shared_ptr&lt;T[ ]&gt; sp</td> <td>sp或up可以指向一个动态分配的数组，数组元素类型为T。</td> </tr> <tr> <td>unique_ptr&lt;T[ ]&gt; up(q) <br /> shared_ptr&lt;T[ ]&gt; sp(q)</td> <td>q只能是能够隐式转换为T*类型的指向一个动态分配的数组的指针<br /><br />动态内存sp或up指向指针q所指向的动态分配的数组。</td> </tr> <tr> <td>up[i]/sp[i]</td> <td>up或sp必须指向一个数组。<br /> 返回up或sp所拥有的数组中位置i处的对象的引用。</td> </tr> </tbody> </table></div> <p>智能指针来清理动态数组对象的默认操作为<code class="language-plaintext highlighter-rouge">delete[ ]</code>表达式，所以自定义管理动态数组的智能指针的删除器时要注意对应的形参类型。</p> </div> </div> </main> <hr> <footer> <!-- # Footer content # appears at the bottom of every page's main content --> <p class="text-small text-grey-dk-100 mb-0"> Copyright &copy; 2020-2024 bobokick. Distributed by an <a href="https://github.com/bobokick/Cpp_Guide_detailed/blob/master/LICENSE">Apache License 2.0.</a> </p> <div class="d-flex mt-2"> <p class="text-small text-grey-dk-000 mb-0"> <a href="https://github.com/bobokick/Cpp_Guide_detailed/tree/master/docs/my_collections/_guide_files/chap6/第6章_动态内存管理.md" id="edit-this-page">Edit this page on GitHub.</a> </p> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js"></script> <script> var config = {} ; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid')); </script> </body> </html>
